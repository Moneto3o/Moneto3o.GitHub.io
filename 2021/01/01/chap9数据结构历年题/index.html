

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Scarlett_D">
  <meta name="keywords" content="">
  <title>chap9数据结构历年题 - Moneto3o</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"moneto3o.github.io","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Moneto3o</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="chap9数据结构历年题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-01 13:18" pubdate>
        January 1, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">chap9数据结构历年题</h1>
            
            <div class="markdown-body">
              <ol>
<li><p>头、尾指针可能都要修改 空链表插入时，首尾指针都需要改变</p>
</li>
<li><p>必须判断是否为空, 否则为空还弹栈 ,有可能返回null </p>
</li>
<li><p>一个顶点对应于一个链表</p>
</li>
<li><p>堆排序</p>
</li>
</ol>
<p><img src="https://uploadfiles.nowcoder.com/images/20180512/7739380_1526101611347_7BFE8A73827A85C545B88FB681FADF14" srcset="/img/loading.gif"></p>
<ol start="5">
<li><p>比较次数为logN取上界 10</p>
</li>
<li><p>N0=N2+1</p>
</li>
<li><p>一个联通图的生成树是图的极小连通子图，包含图中的所有顶点，并且只含尽可能少的边</p>
</li>
</ol>
<p>连接n个顶点最小需要**(n-1)**条边</p>
<ol start="8">
<li><p>这里的“确保”意思是，6个顶点不管怎么连（平行边除外），你是找不出非连通图的情况的，首先5个顶点的全连通图需要的边为n*（n-1）/2=10，再加一条边与另一个顶点相连接，总共11条边，不管你怎么连，都可以确保这个图是连通的（不存在平行边）。 11<img src="https://uploadfiles.nowcoder.com/images/20180717/617093391_1531835097348_54BF3C45832CE7AE67FAEB9CC43DA7BE" srcset="/img/loading.gif"></p>
</li>
<li><p>40, 42,55,50,80.85</p>
</li>
<li><p>.abedfc</p>
</li>
<li><p>H</p>
</li>
<li><p>2</p>
</li>
<li><p>8/3</p>
</li>
<li><p>ABDEHCFIG</p>
</li>
<li><p>除第一和最后一个元素之外，其余元素都有且仅有一个直接前驱和直接后继</p>
</li>
</ol>
<p>综合</p>
<p>算法的<strong>五个基本特征</strong>:输入、输出、有穷性、确定性和可行性。</p>
<p>算法的好坏有<strong>四个方面的因素</strong>: 1.正确性 2.易读性 3.健壮性 4.时空性</p>
<p>选择题汇总</p>
<ol start="0">
<li><p>设某链表中最常用的操作是在链表的尾部<strong>插入或删除元素</strong>，则选用下列（ <strong>双向循环链表</strong> ）存储方式最节省运算时间。 </p>
</li>
<li><p>下面的叙述正确的是( )<br>线性表在链式存储时,查找第i个元素的时间同i的值成正比</p>
</li>
<li><p>对于顺序存储的线性表,访问结点和增加、删除结点的时间复杂度分别为( )。（0.5分）0.5 分<br>O(1),O(n)</p>
</li>
<li><p>某线性表中最常用的操作是在<strong>最后一个元素之后插入一个元素和删除第一个元素</strong>,则采用( )存储方式最节省运算时间。（0.5分）0.5 分<br>仅有尾指针的单循环链表</p>
</li>
<li><p>计算机算法必须具备输入、输出和( )等 5个特性。<br>可行性、确定性和有穷性</p>
</li>
<li><p>设进栈序列是a, b, c, d,若进栈过程中允许出栈,则不可能出现的出栈序列是( )。<br>c, d, a, b</p>
</li>
<li><p>设一个链表最常用的操作是在<strong>末尾插入结点和删除尾结点</strong>,则选用( )最节省时间。</p>
</li>
</ol>
<p>​       单向循环链表</p>
<ol start="7">
<li><p>一个单链表中,在指针p指向的结点之后插入一个由指针s指向的结点,正确的操作是( )。<br>s-&gt;next=p-&gt;next; p-&gt;next=s;</p>
</li>
<li><p>设循环队列Q的最大长度为m,rear为尾指针,则入队时的操作为( )。<br>Q.rear=(Q.rear+1) % m</p>
</li>
<li><p>以下程序段的时间复杂度为( )。<br>for( i=1; i&lt;=n; i++)<br>for(j=i; j&lt;=n; j++）</p>
<p>S;</p>
<p>O(n2)</p>
</li>
<li><p>一棵完全二叉树总共有700结点,则该树有( )个叶子结点。</p>
<p>350</p>
<p><code>树的总分支数=总节点数-1 所以这棵树有699个分支 又因为二叉树最多有2个分支，所以 </code></p>
<p> <code>699/2=349......1即有349个双分支节点和1个单分支节点，所以叶子节点的个数为700-349-1=350</code></p>
</li>
<li><p>设某无向图中有n个顶点e条边,则该无向图中所有顶点的度之和为( )。</p>
<p>2e</p>
</li>
<li><p>设有一组初始关键字序列为(24,35,12,27,18,26),则将27插入到有序序列的直接插入排序结束后的结果的是( )。<br>12,24,27,35,18,26</p>
</li>
<li><p>在顺序有序表(2、5、7、10、14、15、18、23、35、41、52)中,用二分法查找关键字14需做的比较次数为( )。<br>4</p>
</li>
<li><p>设某棵二叉树中度数为0的结点数为N0,度数为1的结点数为N1,则该二叉树中度数为2的结点数为( )。<br>N0+1</p>
</li>
<li><p>对如下图所示的有向图进行拓扑排序,得到的拓扑序列可能是( )<br>3,1,4,2,6,5</p>
</li>
<li><p><strong>判定一个有向图是否存在回路</strong>,除了可以用拓扑排序方法外,还可以利用( )。<br>深度优先遍历算法</p>
</li>
<li><p>下列排序方法中,不稳定的排序方法是( )。<br>快速排序</p>
</li>
<li><p>若一组记录的排序码为(46, 79, 56, 38, 40, 84),则利用快速排序的方法,以第一个记录为基准得到的一次划分结果为( )。<br>40,38,46,56,79,84</p>
</li>
<li><p>链式存储表示中数据元素之间的逻辑关系是由( )表示的。<br>指针</p>
</li>
<li><p>单链表带有头结点,非空,其指向头结点的指针是head,则删除首元结点的语句是( )。<br>head-&gt;next=head-&gt;next-&gt;next;</p>
</li>
<li><p>Head为带有头结点的非空循环单链表,指向尾结点的指针变量p满足( )。<br>p-&gt;next==head</p>
</li>
<li><p>利用<strong>双向链表</strong>作线性表的存储结构的<strong>优点</strong>是( )。<br>便于插入和删除操作</p>
</li>
<li><p>已知单链表A的长度为m,单链表B的长度为n,若将B链接在A的末尾,在没有尾指针的情况下,算法的时间复杂度为( )。（0.5分）0.0 分<br>O(m)</p>
</li>
<li><p>在头指针为head且表长度大于1 的循环链表中,指针p指向表中某个结点,若p-&gt;next-&gt;next==head,则正确的表述是( )</p>
<p>*<strong>p的直接后继是尾结点</strong></p>
</li>
<li><p>L是带头结点的单链表,执行以下代码后,各结点的data值分别为( )。<br>L=new Lnode; p=L;<br>for (i=1;i&lt;=4;i++){p-&gt;next=new Lnode; p=p-&gt;next; p-&gt;data=i*2-1;}<br>1,3,5,7</p>
</li>
<li><p>单链表带有头结点,非空,其指向头结点的指针是head,则删除首元结点的语句是( )。（0.5分）0.0 分<br>head-&gt;next=head-&gt;next-&gt;next;</p>
</li>
<li><p>链式存储表示中数据元素之间的逻辑关系是由( )表示的。<br>指针</p>
</li>
<li><p>下面的叙述正确的是( )</p>
</li>
</ol>
<p>​        线性表在链式存储时,查找第i个元素的时间同i的值成正比</p>
<ol start="29">
<li><p>对于顺序存储的线性表,访问结点和增加、删除结点的时间复杂度分别为( )。（0.5分）0.0 分<br>O(1),O(n)</p>
</li>
<li><p>若某线性表最常用的操作是存取任意指定序号的元素和在线性表的最后进行插入和删除元素,则利用( )存储方式最节省时间。<br>顺序表</p>
</li>
<li><p>某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素,则采用( )存储方式最节省运算时间。<br>仅有尾指针的单循环链表</p>
</li>
<li><p>Head为带有头结点的非空循环单链表,指向尾结点的指针变量p满足( )。（0.5分）0.0 分<br>p-&gt;next==head</p>
</li>
<li><p>利用双向链表作线性表的存储结构的优点是( )。（0.5分）0.0 分<br>便于插入和删除操作</p>
</li>
<li><p>已知单链表A的长度为m,单链表B的长度为n,若将B链接在A的末尾,在没有尾指针的情况下,算法的时间复杂度为( )。（0.5分）0.0 分<br>O(m)</p>
</li>
<li><p>在头指针为head且表长度大于1 的循环链表中,指针p指向表中某个结点,若p-&gt;next-next==head,则正确的表述是()（0.5分）0.0 分<br>*<strong>p的直接后继是尾结点</strong></p>
</li>
<li><p>L是带头结点的单链表,执行以下代码后,各结点的data值分别为( )。<br>L=new Lnode; p=L;<br>for (i=1;i&lt;=4;i++){p-&gt;next=new Lnode; p=p-&gt;next; p-&gt;data=i*2-1;}<br>1,3,5,7</p>
</li>
<li><p>将两个各含n个记录的有序表归并成一个新的有序表是,所需进行关键字比较次数的最小值为( )。<br>n</p>
</li>
<li><p>对于一个头指针为head的带头结点的单链表,判定该链表为空表的条件是( )。<br>head→next==NULL</p>
</li>
<li><p>链表不具有的特点是( )<br>可随机访问任一元素</p>
</li>
<li><p>若长度为n的线性表采用顺序存储结构,在第i个位置插入一个元素的算法的时间复杂度为( )(1&lt;=i&lt;=n+1)。<br>O(n)</p>
</li>
<li><p>已知L是带头结点的单链表,则删除首元结点的语句是( )。<br>L-&gt;next=L-&gt;next-&gt;next;</p>
</li>
<li><p>下面程序段的时间复杂度是_______。<br>for (i=0;i&lt;n;i++)<br>for(j=0;j&lt;m;j++)<br>A[i][j]=0;<br>O(n*m)</p>
</li>
<li><p>下面程序段的时间复杂度是_______。<br>s=0;<br>for (i=0;i&lt;n;i++)<br>for (j=0;j&lt;n;j++)<br>s+=B[i][j];<br>sum=s;<br>O(n2)</p>
</li>
<li><p>下面程序段的时间复杂度是________。<br>i=1;<br>while(i&lt;=n)<br>i=i*3;<br><strong>O(log3n)</strong></p>
</li>
<li><p>从逻辑结构上可以把数据结构分为( )。<br>线性结构和非线性结构</p>
</li>
<li><p>顺序存储表示中数据元素之间的逻辑关系是由( )表示的。<br>存储位置</p>
</li>
<li><p>链式存储表示中数据元素之间的逻辑关系是由( )表示的。<br>指针</p>
</li>
<li><p>算法的时间复杂度与( )有关。<br>问题规模</p>
</li>
<li><p>从逻辑结构上可以把数据结构分为(    )。<br>线性结构和非线性结构</p>
</li>
<li><p>下面程序段的时间复杂度是（ ）</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>( I =<span class="hljs-number">0</span>; i&lt;n; i++)<br>   <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>       s +=B[i][j];<br>		sum = s ;<br></code></pre></td></tr></table></figure>

<p>​      O(n2)</p>
<ol start="51">
<li><p>下面程序段的时间复杂度是            。</p>
<p>for( i =0; i&lt;n; i++)<br>for(j=0;j&lt;m;j++)</p>
<pre><code>   A[i][j] ＝ 0;</code></pre>
</li>
</ol>
<p>O(n*m)</p>
<ol start="52">
<li><p>下面程序段的时间复杂度是            。</p>
<p>i ＝ 0；<br>while（i&lt;=n）<br>i = i * 3；</p>
</li>
</ol>
<p>O(log3n)</p>
<ol start="53">
<li><p>以下程序段的时间复杂度为( )。<br>for( i=1; i&lt;=n; i++)<br>for(j=i; j&lt;=n; j++) S;<br>O(n2)</p>
</li>
<li><p>以下程序段中,S语句的执行次数是( )<br>for( i=1; i&lt;=n; i++)<br>for(j=i; j&lt;=n; j++）</p>
</li>
</ol>
<p>​      Ｓ；</p>
<p>​        n(n+1)/2</p>
<ol start="55">
<li><p>设进栈序列是a, b, c, d,若进栈过程中允许出栈,则不可能出现的出栈序列是( )。<br>c, d, a, b</p>
</li>
<li><p>设栈S和队列Q的初始状态均为空,假设元素a,b,c,d,e,f依次进行入栈、出栈、入队、出队操作,且入队紧跟在出栈之后,由此得到出队序列b,d,c,,f,e,a,则栈S的容量至少应该是( )。<br>3</p>
</li>
<li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队满的条件是( )。<br><strong>(Q.rear+1)% maxSize == Q.front</strong></p>
</li>
<li><p>用不带头结点的单链表(长度大于1)存储队列时,其队头指针指向队头结点,其队尾指针指向队尾结点,则在进行删除操作时( )。<br>队头,队尾指针都可能要修改</p>
</li>
<li><p>设计一个判别表达式中左,右括号是否配对出现的算法,采用( )结构最佳。<br>栈</p>
</li>
<li><p>用单链表表示的链式队列的队头在链表的( )位置。<br>表头</p>
</li>
<li><p>栈和队列的共同点是( )。<br>只允许在端点处插入和删除元素</p>
</li>
<li><p>一个栈的输入序列为1,2,3…n,若输出序列的第一个元素是n,则输出第i(1&lt;=i&lt;=n)个元素是( )。<br>n-i+1</p>
</li>
<li><p>设入栈元素序列是a, b, c, d,e,若进栈过程中允许出栈,则可能出现的出栈序列是( )。<br>bcaed</p>
</li>
<li><p>设进栈序列是a, b, c, d,若进栈过程中允许出栈,则不可能出现的出栈序列是( )。<br>c, d, a, b</p>
</li>
<li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队空的条件是( )。<br>front==rear</p>
</li>
<li><p>设循环队列Q的最大长度为m,rear为尾指针,则入队时的操作为( )。<br>Q.rear=(Q.rear+1) % m</p>
</li>
<li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队满的条件是（ ）。<br>(rear+1)% maxSize ==front</p>
</li>
<li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队列的长度是（ ）。<br>(Q.rear-Q.front+MAXQSIZE) % MAXQSIZE</p>
</li>
<li><p>在具有 1000 个单元的循环队列中,队头指针 front为4 ,队尾指针 rear为996 ,若要达到队满的条件，则需要继续入队（ ）个元素？<br>7</p>
</li>
<li><p>一个栈的入栈序列a,b,c,d,e,则栈的不可能的输出序列是____。<br>dceab</p>
</li>
<li><p>若已知一个栈的入栈序列是1,2,3,…,n,其输出序列为p1,p2,p3,…,pn,若p1=n,则pi为____。<br>n-i+1</p>
</li>
<li><p>栈结构通常采用的两种存储结构是____。<br>顺序存储结构和链式存储结构</p>
</li>
<li><p>判定一个顺序栈ST(最多元素为m0)为空的条件是____。<br>top= =0</p>
</li>
<li><p>判定一个顺序栈ST(最多元素为m0)为栈满的条件是____。<br>top= =m0-1</p>
</li>
<li><p>向一个栈顶指针为HS的链栈中插入一个s所指结点时,则执行__ __。<br>s-&gt;next= HS; HS=s;</p>
</li>
<li><p>从一个栈顶指针为HS的链栈中删除一个结点时(出栈),用x保存被删结点的值,则执行__ __。(不带空的头结点)<br>x=HS-&gt;data; HS= HS-&gt;next;</p>
</li>
<li><p>一个队列的数据入列序列是1,2,3,4,则队列的出队时输出序列是____ 。<br>1,2,3,4</p>
</li>
<li><p>判定一个循环队列QU(最多元素为m0)为空的条件是____。<br>front= = rear</p>
</li>
<li><p>判定一个循环队列QU(最多元素为m0, m0= =Maxsize-1)为满队列的条件是____。<br>((rear- front)+ Maxsize)% Maxsize = =m0</p>
</li>
<li><p>循环队列用数组A[0,m-1]存放其元素值,已知其头尾指针分别是front和rear,则当前队列中的元素个数是____。（0.5分）0.0 分<br>(rear-front+m)%m</p>
</li>
<li><p>栈和队列的共同点是____。<br>只允许在端点处插入和删除元素</p>
</li>
<li><p>在一个图中,所有顶点的度数之和等于所有边数的____倍。<br>2</p>
</li>
<li><p>任何一个无向连通图的最小生成树      。<br>有一棵或多棵</p>
</li>
<li><p>在一个有向图中,所有顶点的入度之和等于所有顶点的出度之和的__ __倍。<br>1</p>
</li>
<li><p>一个有n个顶点的无向图最多有___ _条边。<br>n(n-1)/2</p>
</li>
<li><p>具有4个顶点的无向完全图有____条边。<br>6</p>
</li>
<li><p>具有6个顶点的无向图至少应有___条边才能确保是一个连通图。<br>5</p>
</li>
<li><p>在一个具有<strong>n个顶点的无向图</strong>中,要连通全部顶点至少需要____条边。<br>n-1</p>
</li>
<li><p>对于一个具有n个顶点的无向图,若采用邻接矩阵表示,则该矩阵的大小是____。<br>n2</p>
</li>
<li><p>已知一有向图的邻接表存储结构如图7.2所示。根据有向图的深度优先遍历算法,从顶点v1出发,所得到的顶点序列是____。<br>v1,v3,v4,v5,v2</p>
</li>
<li><p>采用邻接表存储的图的深度优先遍历算法类似于二叉树的____。</p>
<p><strong>先序遍历</strong></p>
</li>
<li><p>采用邻接表存储的图的<strong>广度优先遍历</strong>算法类似于二叉树的____。<br><strong>按层遍历</strong></p>
</li>
<li><p>判定一个有向图是否存在回路除了可以利用拓扑排序方法外,还可以利用____。<br><strong>深度优先遍历算法</strong></p>
</li>
<li><p>关键路径是事件结点网络中(） 。<br>从源点到汇点的最长路径</p>
</li>
<li><p>用DFS遍历一个无环有向图,并在DFS算法退栈返回时打印出相应的顶点,则输出的顶点序列是 。</p>
<p>逆拓扑有序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">DFS是一个递归算法,在遍历的过程中,先访问的点被压入栈底。拓扑有序是指如果点U到点V有一条弧,则在拓扑序列中U一定在V之前.深度优先算法搜索路径恰恰是一条弧,栈的输出是从最后一个被访问点开始输出,最后一个输出的点是第一个被访问的点.所以是逆的拓扑有序序列<br></code></pre></td></tr></table></figure>
</li>
<li><p>在图7.3所示的拓朴排列的结果序列为 。<br>516234</p>
</li>
<li><p>一个有n个顶点的无向连通图,它所包含的连通分量个数为 。<br>1</p>
<p><code>由于该图本身就是连通图，所以只可能包含一个连通分量。若不连通才可能有多个连通分量</code></p>
</li>
<li><p>对于一个有向图,若一个顶点的入度为k1,、出度为k2,则对应邻接表中该顶点单链表中的结点数为 。<br>k2</p>
</li>
<li><p>对于一个有向图,若一个顶点的入度为k1,、出度为k2,则对应逆邻接表中该顶点单链表中的结点数为 。<br>k1</p>
</li>
<li><p>一个有向图G的邻接矩阵存储如下图,按深度优先遍历算法遍历,从顶点0出发,所得到的顶点序列是( )<br>0 1 3 2 4 6 5</p>
</li>
<li><p>如果从无向图的任一顶点出发进行一次深度优先遍历即可访问所有顶点,则该图一定是( )<br>连通图</p>
</li>
<li><p>采用邻接表存储的图的深度优先遍历算法类似于二叉树的___算法。<br>先序遍历</p>
</li>
<li><p>采用邻接表存储的图的广度优先遍历算法类似于二叉树的() 算法。<br>层次遍历</p>
</li>
<li><p>图的广度优先遍历算法中用到一个队列,每个顶点最多进队( )次<br>1</p>
<p><code>深度优先遍历：用到了栈 ；广度优先遍历：用到了队列</code></p>
</li>
<li><p>以下叙述中错误的是<br>图的深度优先遍历不适合有向图</p>
</li>
<li><p>有n个顶点的图进行深度优先遍历,其空间复杂度为</p>
<p>O(n)</p>
</li>
<li><p>一个有向图G的邻接表存储如图，按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）<br>A,B,C,E,D</p>
</li>
<li><p>一个有向图G的邻接表存储如图，按广度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）<br>A,B,C,D,E</p>
</li>
<li><p>一个有向图G的邻接矩阵存储如下图，按广度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）<br>0 2 1 3 4 5 6</p>
</li>
<li><p>一棵深度为4的二叉树的结点数至多为( )。<br>31</p>
</li>
<li><p>若一棵二叉树具有10个度为2的结点,5个度为1的结点,则度为0的结点的个数是<br>11</p>
</li>
<li><p>设森林F对应的二叉树为B,它有m个结点,B的根为p,p的右子树的结点个数为n,森林F中第一棵树的结点的个数是 。（0.5分）0.0 分<br>m-n</p>
</li>
<li><p>假设一个三叉树的结点数为36,则该树的最小高度为( )。<br>4</p>
</li>
<li><p>设高度为h的二叉树中只有度为0和度为2的结点,则该树的结点数至少为( )<br>2h-1</p>
<img src="https://i.loli.net/2020/12/20/fsDCwEPT64l1xHq.png" srcset="/img/loading.gif" style="zoom:50%;" />
</li>
<li><p>假定在一棵二叉树中,双分支结点数为15,单分支结点数为30个,则叶子结点数为 个。<br>16</p>
<p><code>n0=n2+1</code></p>
</li>
<li><p>按照二叉树的定义,具有3个结点的不同形状的二叉树有____种。<br>5</p>
</li>
<li><p>按照二叉树的定义,具有3个不同数据结点的不同的二叉树有____种。<br>30</p>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.求出三个结点组成的二叉树的所有形状个数。<br>2.计算三个不同数据的排列顺序种类个数，将每种排列按二叉树的先根遍历方式填入结点算一种情况。<br>则第一步的结果是5，第二步的结果是3<span class="hljs-number">*2</span><span class="hljs-number">*1</span> = 6<br></code></pre></td></tr></table></figure>

<ol start="118">
<li><p>深度为5的二叉树至多有个结点。<br>31 <code>2^k-1</code></p>
</li>
<li><p>设高度为h的二叉树上只有度为0和度为2的结点,则此类二叉树中所包含的结点数至少为_ ___。<br>2h-1</p>
</li>
</ol>
<p><code>2h-1,最少情况即为除了第h层，每层度为2的节点只有1个（产生2度，即产生2个结点），共有2(h-1)个，再加根节点总共2h-1个。</code></p>
<ol start="120">
<li><p>对一个满二叉树,m个树叶,n个结点,深度为h,则____ 。<br>n=2^h-1</p>
</li>
<li><p>任何一棵二叉树的叶结点在先序、中序和后序遍历序列中的相对次序____。<br>不发生改变</p>
</li>
<li><p>如果某二叉树的前根次序遍历结果为stuwv,中序遍历为uwtvs,那么该二叉树的后序为____。<br>wuvts</p>
</li>
<li><p>某二叉树的前序遍历结点访问顺序是abdgcefh,中序遍历的结点访问顺序是dgbaechf,则其后序遍历的结点访问顺序是____。<br>gdbehfca</p>
</li>
<li><p>在一非空二叉树的中序遍历序列中,根结点的右边____。<br><strong>只有右子树上的所有结点</strong></p>
</li>
<li><p>如图6.1所示二叉树的中序遍历序列是____。<br>dfebagc</p>
</li>
<li><p>一棵二叉树如图6.2所示,其中序遍历的序列为__ __。<br>dgbaechf</p>
</li>
<li><p>已知某二叉树的后序遍历序列是dabec,中序遍历序列是debac,它的前序遍历序列是____。<br>cedba</p>
</li>
<li><p><strong>实现任意二叉树的后序遍历的非递归算法而不使用栈结构,最佳方案是二叉树采用存储结构。</strong><br><strong>三叉链表</strong></p>
</li>
<li><p>在线索化二叉树中,t所指结点没有左子树的充要条件是____。<br><strong>t-&gt;ltag=1</strong></p>
</li>
<li><p>树的基本遍历策略可分为先根遍历和后根遍历;二叉树的基本遍历策略可分为先序遍历、中序遍历和后序遍历。这里,我们把由树转化得到的二叉树叫做这棵数对应的二叉树。结论____是正确的。<br>树的<strong>先根</strong>遍历序列与其对应的二叉树的<strong>先序</strong>遍历序列相同</p>
</li>
<li><p>树最适合用来表示 ____。<br>元素之间<strong>具有分支层次关系</strong>的数据</p>
</li>
<li><p>如图6.3所示的4棵二叉树，____不是完全二叉树。<br>C图</p>
</li>
<li><p>设a,b为一棵二叉树上的两个结点，在中序遍历时，a在b前的条件是       。<br>a在b的左方</p>
</li>
<li><p>下列排序方法中,不稳定的排序方法是( )（0.5分）0.0 分<br>快速排序</p>
</li>
<li><p>对n个不同的元素进行起泡排序,在下列哪种情况下比较的次数最多( )。<br>元素逆序</p>
</li>
<li><p>若一组记录的排序码为(46, 79, 56, 38, 40, 84),则利用快速排序的方法,以第一个记录为基准得到的一次划分结果为( )。<br>40, 38,46, 56, 79, 84</p>
</li>
<li><p>设有一组初始关键字序列为(24,35,12,27,18,26),则将27插入到有序序列的直接插入排序结束后的结果的是( )。<br>12,24,27,35,18,26</p>
</li>
<li><p>将两个各含n个记录的有序表归并成一个新的有序表是,所需进行关键字比较次数的最小值为( )。<br>n</p>
</li>
<li><p>设语句x++的时间是单位时间,则以下语句的时间复杂度为( )。<br>for(i=1; i&lt;=n; i++)<br>{ int p=1;<br>for(j=1;j&lt;=i;j++)<br>p*=j;<br>s+=p;<br><strong>O(n2)</strong></p>
</li>
<li><p>一个向量(即一批地址连续的存储单元)第一个元素的存储地址是100,每个元素的长度为2,则第5个元素的地址是( )。<br>108 <code>第一个元素的存储地址是100，第二个是102，第三个是104，第五个是108</code></p>
</li>
<li><p>设顺序循环队列Q[0:M-1]的头指针和尾指针分别为F和R,头指针F总是指向队头元素的前一位置,尾指针R总是指向队尾元素的当前位置,则该循环队列中的元素个数为( )。<br>(R-F+M)%M</p>
</li>
<li><p>在一个单链表中,已知q结点是p结点的前趋结点,若在q和p之间插入s结点,则须执行( )<br>q-&gt;next=s; s-&gt;next=p</p>
</li>
<li><p>设输入序列是1、2、3、……、n,经过栈的作用后输出序列的第一个元素是n,则输出序列中第i个输出元素是( )。<br>n+1-i</p>
</li>
<li><p>串是一中特殊的线性表,其特殊性体现在( )。<br>数据元素是一个字符</p>
</li>
<li><p>在具有n个单元的顺序存储的循环队列中,假定front和rear分别为队头指针和队尾指针,则判断队空的条件为( )。<br>rear== front</p>
</li>
<li><p>设有一个10阶的下三角矩阵A(包括对角线),按照从上到下、从左到右的顺序存储到连续的55个存储单元中,每个数组元素占1个字节的存储空间,则A[5][4]地址与A[0][0]的地址之差为( )。<br><strong>19</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]的地址：<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>+<span class="hljs-number">5</span>+<span class="hljs-number">6</span>=<span class="hljs-number">21</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>]地址：<span class="hljs-number">21</span>-<span class="hljs-number">1</span>=<span class="hljs-number">20</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>]-A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">20</span>-<span class="hljs-number">1</span>=<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>按照二叉树的定义,具有3个结点的不同形状的二叉树有( )种。<br>5</p>
</li>
<li><p>任何一棵二叉树的叶结点之间的相对次序在先序、中序和后序遍历序列中 ( )。<br><strong>不发生改变</strong></p>
</li>
<li><p>设有序顺序表中有n个数据元素,则利用二分查找法查找数据元素X的最多比较次数不超过( )。（0.5分）0.0 分</p>
<p>log2n+1</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">因为二分查找每次排除掉一半的不适合值，所以对于<span class="hljs-built_in">n</span>个元素的情况：<br> 一次二分剩下：<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span><br> 两次二分剩下：<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>/<span class="hljs-number">2</span> = <span class="hljs-built_in">n</span>/<span class="hljs-number">4</span><br> 。。。<br> m次二分剩下：<span class="hljs-built_in">n</span>/(<span class="hljs-number">2</span>^m)<br> 在最坏情况下是在排除到只剩下最后一个值之后得到结果，所以为<br>  <span class="hljs-built_in">n</span>/(<span class="hljs-number">2</span>^m)=<span class="hljs-number">1</span>;<br><br>  <span class="hljs-number">2</span>^m=<span class="hljs-built_in">n</span>; <br><br>  此时时间复杂度为log2（<span class="hljs-built_in">n</span>） <br><br>  再与最后一个元素比较复杂度+<span class="hljs-number">1</span> <br><br> 所以时间复杂度为：log2(<span class="hljs-built_in">n</span>)+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>设F是由T1、T2和T3三棵树组成的森林,与F对应的二叉树为B,T1、T2和T3的结点数分别为N1、N2和N3,则二叉树B的根结点的左子树的结点数为( )。（0.5分）0.0 分<br>N1-1</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(<span class="hljs-number">1</span>)<span class="hljs-built_in">T1</span>,<span class="hljs-built_in">T2</span>,<span class="hljs-built_in">T3</span>先分别转化为二叉树，除掉根结点，其它结点都转化为根结点的左孩子<br>(<span class="hljs-number">2</span>)第一棵二叉树不动，后面的二叉树分别是前面二叉树的右孩子。<br>故本题中<span class="hljs-built_in">T1</span>不动，左孩子结点N1<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>



</li>
</ol>
<ol start="151">
<li><p>在一个具有n个顶点和e条边的有向图的邻接矩阵中,表示边存在的元素个数为( )。<br>e</p>
</li>
<li><p>若一个图的边集为{(A,B),(A,C),(B,D),(C,F),(D,E),(D,F)},则从顶点A开始对该图进行深度优先搜索,得到的顶点序列可能为( )。<br>A,C,F,D,E,B</p>
</li>
<li><p>在一个具有n个顶点的无向图中,若具有e条边,则所有顶点的度数之和为( )。<br>2e</p>
</li>
<li><p>对由关键字序列(50,25,63, 18 ,42,32,90)生成的二叉排序树,由上到下、从左到右的顺序进行输出得到的序列是( )。<br>50,25,63,18,42,90,32</p>
</li>
<li><p>对下列四个序列进行快速排序,各以第一个元素为基准进行第一次划分,则在该次划分过程中需要移动元素次数最多的序列为( )。<br>5, 7, 9, 1, 3<br><code>逆序对</code></p>
</li>
<li><p>下列关键字序列中,( )是堆。<br>16, 23, 53, 31, 94, 72</p>
</li>
<li><p>一组记录的排序码为(25,48,16,35,79,82,23,40,36,72),其中含有5个长度为2 的有序表,按归并排序的方法对该序列进行一趟归并后的结果为( )。<br>16,25,35,48,23,40,79,82,36,72</p>
</li>
<li><p>下面程序的时间复杂为( )<br>for(i=1,s=0;i&lt;=n;i++)<br>{ t=1;<br>for(j=1;j&lt;=i;j++)<br>t=t*j;<br>s=s+t;<br>}<br>O(n^2)<br><code>第二层循环每次循环i次，而i是从1...n 所以循环要进行1+2+3+4+...+n次</code></p>
</li>
<li><p>设顺序循环队列Q[0:M-1]的头指针和尾指针分别为F和R,头指针F总是指向队头元素的前<br>一位置,尾指针R总是指向队尾元素的当前位置,则该循环队列中的元素个数为( )。<br>(R-F+M)%M</p>
</li>
<li><p>设某棵二叉树的中序遍历序列为ABCD,前序遍历序列为CABD,则后序遍历序列为( )。（0.5分）0.0 分<br>BADC</p>
</li>
<li><p>二叉树的第k层的结点数最多为( ).<br>2k-1</p>
</li>
<li><p>设哈夫曼树中的叶子结点总数为m,若用二叉链表作为存储结构,则该哈夫曼树中总共有( )个空指针域。<br>2m</p>
</li>
<li><p>用链表作为栈的存储结构则退栈操作( )。<br>必须判别栈是否为空</p>
</li>
<li><p>设二叉排序树中有n个结点,则二叉排序树的平均查找长度为( )<br>O(log2n)</p>
</li>
<li><p>设连通图G中的边集E={(a,b),(a,e),(a,c),(b,e),(e,d),(d,f),(f,c)},则从顶点a<br>出发不能得到一种深度优先遍历的顶点序列为( )。<br>acfebd</p>
</li>
<li><p>设指针变量p指向单链表中的某结点,q指向其后继节点,s指向一个新开辟的结点,能将s所<br>指结点插入到p所指结点后面的操作为( )<br>s-&gt;next=p-&gt;next; p-&gt;next=s;</p>
</li>
<li><p>在树中结点u与v是兄弟,将其转换为二叉树后,u和v可能具有的关系是( )<br>u是v的父结点或祖先结点</p>
</li>
<li><p>下列哪一种图的邻接矩阵是对称矩阵?( )<br>无向图</p>
</li>
<li><p>下图对应的最小生成树中,各边权值之和为:<br>18</p>
</li>
<li><p>已知有向图G=(V,E),其中V={1,2,3,4}, E={&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,4&gt;,&lt;4,2&gt;,&lt;4, 3&gt;}, 下<br>列序列中为G的拓扑排序序列的是( )。<br>1, 4, 2, 3</p>
</li>
<li><p>设一组初始记录关键字序列(5,2,6,3,8),以第一个记录关键字5为基准进行一趟快速排序<br>的结果为( )。<br>3,2,5,6,8</p>
</li>
<li><p>设一组初始记录关键字序列为((25,50),(15,35),(80,85),(20,40),(36,70)),其中含有5个长度为2的有序子表,则用2路归并升序排序的方法对该记录关键字序列进行一趟归并后的结果为__________。<br>15,25,35,50,20,40,80,85,36,70</p>
</li>
<li><p>对于线性表(7,33,55,25,64,46,20,10)进行散列存储时,若选用H(K)=K %9作为散列函数,用开放定址法的线性探测法解决冲突,在0~8的哈希地址空间中关键字64对应的散列地址为_________,（0.5分）0.0 分<br>2</p>
</li>
<li><p>设有一个二维数组A[m][n],假设A[0][0]存放位置在644(10),A[2][2]存放位置在<br>676(10),每个元素占一个空间,问A[3]<a href="10">3</a>存放在什么位置?脚注(10)表示用10进制<br>表示。<br>692</p>
</li>
<li><p>在AOE网中,如果活动aij关联的顶点为Vi和Vj,则判断aij是否为关键活动的<br>方法为( )<br>如果活动aij的最早发生时间等于它的最迟发生时间,则为关键活动</p>
</li>
<li><p>设二叉树的先序遍历序列和后序遍历序列正好相反,则该二叉树满足的条件是( )。<br>高度等于其结点数</p>
</li>
<li><p>设哈夫曼树中共有99个结点,则该树中有( )个叶子结点。<br>50</p>
</li>
<li><p>在图所示的拓朴排列的结果序列为(      )。<br>516234</p>
</li>
<li><p>设散列表的长度为8，哈希函数H(k)=k % 7，用链地址法解决冲突，则根据一组初始关键字序列(8，15，16，22，30，32)构造出的哈希表的平均查找长度是<strong>____</strong></p>
<p>（1+2+2+4+4+3）/6=8/3</p>
</li>
<li><p>采用折半查找法查找长度为n的线性表时,每个元素的平均查找长度为 。（0.5分）0.0 分<br>O(log2n)</p>
</li>
<li><p>有一个有序表为{1,3,9,12,32,41,45,62,75,77,82,95,100},当折半查找值为82的结点时, 次比较后查找成功。<br>4</p>
</li>
<li><p>二叉树为二叉排序树的充分必要条件是其任一结点的值均大于其左孩子的值、小于其右孩子的值。这种说法 。<br>错误</p>
</li>
<li><p>下面关于B树和B+树的叙述中,不正确的结论是 。<br>B树和B+树都能有效的支持顺序查找</p>
</li>
<li><p>以下说法错误的是 。<br>散列表的结点中只包含数据元素自身的信息,不包含指针。</p>
</li>
<li><p>查找效率最高的二叉排序树是 。<br>平衡二叉树。</p>
</li>
<li><p>排序方法中,从未排序序列中依次取出元素与<strong>已排序</strong>序列中的元素进行比较,将其放入已排序序列的正确位置上的方法,称为 。<br>插入排序</p>
</li>
<li><p>在所有的排序方法中,关键字比较的次数<strong>与记录的初始排列次序无关的是</strong> 。<br><strong>直接选择排序</strong></p>
</li>
<li><p>堆是一种有用的数据结构。下列关键码序列 是一个堆。<br>16,31,23,94,53,72</p>
</li>
<li><p>堆排序是一种 排序。<br>选择</p>
</li>
<li><p>在链表中进行  操作比在顺序表中进行操作效率高。<br>插入</p>
</li>
<li><p>直接选择排序的时间复杂度为 。(n 为元素个数)<br>O(n2)</p>
</li>
<li><p>对线性表进行折半查找时，要求线性表必须      。<br>以顺序方式存储，且结点按关键字有序排列</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/DSReviewPaper/">DSReviewPaper</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/01/chap8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E9%9B%86/">
                        <span class="hidden-mobile">chap8数据结构习题集</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
