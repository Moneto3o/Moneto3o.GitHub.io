<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>chap9数据结构历年题</title>
    <link href="/2021/01/01/chap9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%86%E5%B9%B4%E9%A2%98/"/>
    <url>/2021/01/01/chap9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%86%E5%B9%B4%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li><p>头、尾指针可能都要修改 空链表插入时，首尾指针都需要改变</p></li><li><p>必须判断是否为空, 否则为空还弹栈 ,有可能返回null </p></li><li><p>一个顶点对应于一个链表</p></li><li><p>堆排序</p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20180512/7739380_1526101611347_7BFE8A73827A85C545B88FB681FADF14"></p><ol start="5"><li><p>比较次数为logN取上界 10</p></li><li><p>N0=N2+1</p></li><li><p>一个联通图的生成树是图的极小连通子图，包含图中的所有顶点，并且只含尽可能少的边</p></li></ol><p>连接n个顶点最小需要**(n-1)**条边</p><ol start="8"><li><p>这里的“确保”意思是，6个顶点不管怎么连（平行边除外），你是找不出非连通图的情况的，首先5个顶点的全连通图需要的边为n*（n-1）/2=10，再加一条边与另一个顶点相连接，总共11条边，不管你怎么连，都可以确保这个图是连通的（不存在平行边）。 11<img src="https://uploadfiles.nowcoder.com/images/20180717/617093391_1531835097348_54BF3C45832CE7AE67FAEB9CC43DA7BE"></p></li><li><p>40, 42,55,50,80.85</p></li><li><p>.abedfc</p></li><li><p>H</p></li><li><p>2</p></li><li><p>8/3</p></li><li><p>ABDEHCFIG</p></li><li><p>除第一和最后一个元素之外，其余元素都有且仅有一个直接前驱和直接后继</p></li></ol><p>综合</p><p>算法的<strong>五个基本特征</strong>:输入、输出、有穷性、确定性和可行性。</p><p>算法的好坏有<strong>四个方面的因素</strong>: 1.正确性 2.易读性 3.健壮性 4.时空性</p><p>选择题汇总</p><ol start="0"><li><p>设某链表中最常用的操作是在链表的尾部<strong>插入或删除元素</strong>，则选用下列（ <strong>双向循环链表</strong> ）存储方式最节省运算时间。 </p></li><li><p>下面的叙述正确的是( )<br>线性表在链式存储时,查找第i个元素的时间同i的值成正比</p></li><li><p>对于顺序存储的线性表,访问结点和增加、删除结点的时间复杂度分别为( )。（0.5分）0.5 分<br>O(1),O(n)</p></li><li><p>某线性表中最常用的操作是在<strong>最后一个元素之后插入一个元素和删除第一个元素</strong>,则采用( )存储方式最节省运算时间。（0.5分）0.5 分<br>仅有尾指针的单循环链表</p></li><li><p>计算机算法必须具备输入、输出和( )等 5个特性。<br>可行性、确定性和有穷性</p></li><li><p>设进栈序列是a, b, c, d,若进栈过程中允许出栈,则不可能出现的出栈序列是( )。<br>c, d, a, b</p></li><li><p>设一个链表最常用的操作是在<strong>末尾插入结点和删除尾结点</strong>,则选用( )最节省时间。</p></li></ol><p>​       单向循环链表</p><ol start="7"><li><p>一个单链表中,在指针p指向的结点之后插入一个由指针s指向的结点,正确的操作是( )。<br>s-&gt;next=p-&gt;next; p-&gt;next=s;</p></li><li><p>设循环队列Q的最大长度为m,rear为尾指针,则入队时的操作为( )。<br>Q.rear=(Q.rear+1) % m</p></li><li><p>以下程序段的时间复杂度为( )。<br>for( i=1; i&lt;=n; i++)<br>for(j=i; j&lt;=n; j++）</p><p>S;</p><p>O(n2)</p></li><li><p>一棵完全二叉树总共有700结点,则该树有( )个叶子结点。</p><p>350</p><p><code>树的总分支数=总节点数-1 所以这棵树有699个分支 又因为二叉树最多有2个分支，所以 </code></p><p> <code>699/2=349......1即有349个双分支节点和1个单分支节点，所以叶子节点的个数为700-349-1=350</code></p></li><li><p>设某无向图中有n个顶点e条边,则该无向图中所有顶点的度之和为( )。</p><p>2e</p></li><li><p>设有一组初始关键字序列为(24,35,12,27,18,26),则将27插入到有序序列的直接插入排序结束后的结果的是( )。<br>12,24,27,35,18,26</p></li><li><p>在顺序有序表(2、5、7、10、14、15、18、23、35、41、52)中,用二分法查找关键字14需做的比较次数为( )。<br>4</p></li><li><p>设某棵二叉树中度数为0的结点数为N0,度数为1的结点数为N1,则该二叉树中度数为2的结点数为( )。<br>N0+1</p></li><li><p>对如下图所示的有向图进行拓扑排序,得到的拓扑序列可能是( )<br>3,1,4,2,6,5</p></li><li><p><strong>判定一个有向图是否存在回路</strong>,除了可以用拓扑排序方法外,还可以利用( )。<br>深度优先遍历算法</p></li><li><p>下列排序方法中,不稳定的排序方法是( )。<br>快速排序</p></li><li><p>若一组记录的排序码为(46, 79, 56, 38, 40, 84),则利用快速排序的方法,以第一个记录为基准得到的一次划分结果为( )。<br>40,38,46,56,79,84</p></li><li><p>链式存储表示中数据元素之间的逻辑关系是由( )表示的。<br>指针</p></li><li><p>单链表带有头结点,非空,其指向头结点的指针是head,则删除首元结点的语句是( )。<br>head-&gt;next=head-&gt;next-&gt;next;</p></li><li><p>Head为带有头结点的非空循环单链表,指向尾结点的指针变量p满足( )。<br>p-&gt;next==head</p></li><li><p>利用<strong>双向链表</strong>作线性表的存储结构的<strong>优点</strong>是( )。<br>便于插入和删除操作</p></li><li><p>已知单链表A的长度为m,单链表B的长度为n,若将B链接在A的末尾,在没有尾指针的情况下,算法的时间复杂度为( )。（0.5分）0.0 分<br>O(m)</p></li><li><p>在头指针为head且表长度大于1 的循环链表中,指针p指向表中某个结点,若p-&gt;next-&gt;next==head,则正确的表述是( )</p><p>*<strong>p的直接后继是尾结点</strong></p></li><li><p>L是带头结点的单链表,执行以下代码后,各结点的data值分别为( )。<br>L=new Lnode; p=L;<br>for (i=1;i&lt;=4;i++){p-&gt;next=new Lnode; p=p-&gt;next; p-&gt;data=i*2-1;}<br>1,3,5,7</p></li><li><p>单链表带有头结点,非空,其指向头结点的指针是head,则删除首元结点的语句是( )。（0.5分）0.0 分<br>head-&gt;next=head-&gt;next-&gt;next;</p></li><li><p>链式存储表示中数据元素之间的逻辑关系是由( )表示的。<br>指针</p></li><li><p>下面的叙述正确的是( )</p></li></ol><p>​        线性表在链式存储时,查找第i个元素的时间同i的值成正比</p><ol start="29"><li><p>对于顺序存储的线性表,访问结点和增加、删除结点的时间复杂度分别为( )。（0.5分）0.0 分<br>O(1),O(n)</p></li><li><p>若某线性表最常用的操作是存取任意指定序号的元素和在线性表的最后进行插入和删除元素,则利用( )存储方式最节省时间。<br>顺序表</p></li><li><p>某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素,则采用( )存储方式最节省运算时间。<br>仅有尾指针的单循环链表</p></li><li><p>Head为带有头结点的非空循环单链表,指向尾结点的指针变量p满足( )。（0.5分）0.0 分<br>p-&gt;next==head</p></li><li><p>利用双向链表作线性表的存储结构的优点是( )。（0.5分）0.0 分<br>便于插入和删除操作</p></li><li><p>已知单链表A的长度为m,单链表B的长度为n,若将B链接在A的末尾,在没有尾指针的情况下,算法的时间复杂度为( )。（0.5分）0.0 分<br>O(m)</p></li><li><p>在头指针为head且表长度大于1 的循环链表中,指针p指向表中某个结点,若p-&gt;next-next==head,则正确的表述是()（0.5分）0.0 分<br>*<strong>p的直接后继是尾结点</strong></p></li><li><p>L是带头结点的单链表,执行以下代码后,各结点的data值分别为( )。<br>L=new Lnode; p=L;<br>for (i=1;i&lt;=4;i++){p-&gt;next=new Lnode; p=p-&gt;next; p-&gt;data=i*2-1;}<br>1,3,5,7</p></li><li><p>将两个各含n个记录的有序表归并成一个新的有序表是,所需进行关键字比较次数的最小值为( )。<br>n</p></li><li><p>对于一个头指针为head的带头结点的单链表,判定该链表为空表的条件是( )。<br>head→next==NULL</p></li><li><p>链表不具有的特点是( )<br>可随机访问任一元素</p></li><li><p>若长度为n的线性表采用顺序存储结构,在第i个位置插入一个元素的算法的时间复杂度为( )(1&lt;=i&lt;=n+1)。<br>O(n)</p></li><li><p>已知L是带头结点的单链表,则删除首元结点的语句是( )。<br>L-&gt;next=L-&gt;next-&gt;next;</p></li><li><p>下面程序段的时间复杂度是_______。<br>for (i=0;i&lt;n;i++)<br>for(j=0;j&lt;m;j++)<br>A[i][j]=0;<br>O(n*m)</p></li><li><p>下面程序段的时间复杂度是_______。<br>s=0;<br>for (i=0;i&lt;n;i++)<br>for (j=0;j&lt;n;j++)<br>s+=B[i][j];<br>sum=s;<br>O(n2)</p></li><li><p>下面程序段的时间复杂度是________。<br>i=1;<br>while(i&lt;=n)<br>i=i*3;<br><strong>O(log3n)</strong></p></li><li><p>从逻辑结构上可以把数据结构分为( )。<br>线性结构和非线性结构</p></li><li><p>顺序存储表示中数据元素之间的逻辑关系是由( )表示的。<br>存储位置</p></li><li><p>链式存储表示中数据元素之间的逻辑关系是由( )表示的。<br>指针</p></li><li><p>算法的时间复杂度与( )有关。<br>问题规模</p></li><li><p>从逻辑结构上可以把数据结构分为(    )。<br>线性结构和非线性结构</p></li><li><p>下面程序段的时间复杂度是（ ）</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>( I =<span class="hljs-number">0</span>; i&lt;n; i++)<br>   <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>       s +=B[i][j];<br>sum = s ;<br></code></pre></td></tr></table></figure><p>​      O(n2)</p><ol start="51"><li><p>下面程序段的时间复杂度是            。</p><p>for( i =0; i&lt;n; i++)<br>for(j=0;j&lt;m;j++)</p><pre><code>   A[i][j] ＝ 0;</code></pre></li></ol><p>O(n*m)</p><ol start="52"><li><p>下面程序段的时间复杂度是            。</p><p>i ＝ 0；<br>while（i&lt;=n）<br>i = i * 3；</p></li></ol><p>O(log3n)</p><ol start="53"><li><p>以下程序段的时间复杂度为( )。<br>for( i=1; i&lt;=n; i++)<br>for(j=i; j&lt;=n; j++) S;<br>O(n2)</p></li><li><p>以下程序段中,S语句的执行次数是( )<br>for( i=1; i&lt;=n; i++)<br>for(j=i; j&lt;=n; j++）</p></li></ol><p>​      Ｓ；</p><p>​        n(n+1)/2</p><ol start="55"><li><p>设进栈序列是a, b, c, d,若进栈过程中允许出栈,则不可能出现的出栈序列是( )。<br>c, d, a, b</p></li><li><p>设栈S和队列Q的初始状态均为空,假设元素a,b,c,d,e,f依次进行入栈、出栈、入队、出队操作,且入队紧跟在出栈之后,由此得到出队序列b,d,c,,f,e,a,则栈S的容量至少应该是( )。<br>3</p></li><li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队满的条件是( )。<br><strong>(Q.rear+1)% maxSize == Q.front</strong></p></li><li><p>用不带头结点的单链表(长度大于1)存储队列时,其队头指针指向队头结点,其队尾指针指向队尾结点,则在进行删除操作时( )。<br>队头,队尾指针都可能要修改</p></li><li><p>设计一个判别表达式中左,右括号是否配对出现的算法,采用( )结构最佳。<br>栈</p></li><li><p>用单链表表示的链式队列的队头在链表的( )位置。<br>表头</p></li><li><p>栈和队列的共同点是( )。<br>只允许在端点处插入和删除元素</p></li><li><p>一个栈的输入序列为1,2,3…n,若输出序列的第一个元素是n,则输出第i(1&lt;=i&lt;=n)个元素是( )。<br>n-i+1</p></li><li><p>设入栈元素序列是a, b, c, d,e,若进栈过程中允许出栈,则可能出现的出栈序列是( )。<br>bcaed</p></li><li><p>设进栈序列是a, b, c, d,若进栈过程中允许出栈,则不可能出现的出栈序列是( )。<br>c, d, a, b</p></li><li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队空的条件是( )。<br>front==rear</p></li><li><p>设循环队列Q的最大长度为m,rear为尾指针,则入队时的操作为( )。<br>Q.rear=(Q.rear+1) % m</p></li><li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队满的条件是（ ）。<br>(rear+1)% maxSize ==front</p></li><li><p>在具有 maxSize 个单元的循环队列中,队头指针为 front ,队尾指针为 rear ,则队列的长度是（ ）。<br>(Q.rear-Q.front+MAXQSIZE) % MAXQSIZE</p></li><li><p>在具有 1000 个单元的循环队列中,队头指针 front为4 ,队尾指针 rear为996 ,若要达到队满的条件，则需要继续入队（ ）个元素？<br>7</p></li><li><p>一个栈的入栈序列a,b,c,d,e,则栈的不可能的输出序列是____。<br>dceab</p></li><li><p>若已知一个栈的入栈序列是1,2,3,…,n,其输出序列为p1,p2,p3,…,pn,若p1=n,则pi为____。<br>n-i+1</p></li><li><p>栈结构通常采用的两种存储结构是____。<br>顺序存储结构和链式存储结构</p></li><li><p>判定一个顺序栈ST(最多元素为m0)为空的条件是____。<br>top= =0</p></li><li><p>判定一个顺序栈ST(最多元素为m0)为栈满的条件是____。<br>top= =m0-1</p></li><li><p>向一个栈顶指针为HS的链栈中插入一个s所指结点时,则执行__ __。<br>s-&gt;next= HS; HS=s;</p></li><li><p>从一个栈顶指针为HS的链栈中删除一个结点时(出栈),用x保存被删结点的值,则执行__ __。(不带空的头结点)<br>x=HS-&gt;data; HS= HS-&gt;next;</p></li><li><p>一个队列的数据入列序列是1,2,3,4,则队列的出队时输出序列是____ 。<br>1,2,3,4</p></li><li><p>判定一个循环队列QU(最多元素为m0)为空的条件是____。<br>front= = rear</p></li><li><p>判定一个循环队列QU(最多元素为m0, m0= =Maxsize-1)为满队列的条件是____。<br>((rear- front)+ Maxsize)% Maxsize = =m0</p></li><li><p>循环队列用数组A[0,m-1]存放其元素值,已知其头尾指针分别是front和rear,则当前队列中的元素个数是____。（0.5分）0.0 分<br>(rear-front+m)%m</p></li><li><p>栈和队列的共同点是____。<br>只允许在端点处插入和删除元素</p></li><li><p>在一个图中,所有顶点的度数之和等于所有边数的____倍。<br>2</p></li><li><p>任何一个无向连通图的最小生成树      。<br>有一棵或多棵</p></li><li><p>在一个有向图中,所有顶点的入度之和等于所有顶点的出度之和的__ __倍。<br>1</p></li><li><p>一个有n个顶点的无向图最多有___ _条边。<br>n(n-1)/2</p></li><li><p>具有4个顶点的无向完全图有____条边。<br>6</p></li><li><p>具有6个顶点的无向图至少应有___条边才能确保是一个连通图。<br>5</p></li><li><p>在一个具有<strong>n个顶点的无向图</strong>中,要连通全部顶点至少需要____条边。<br>n-1</p></li><li><p>对于一个具有n个顶点的无向图,若采用邻接矩阵表示,则该矩阵的大小是____。<br>n2</p></li><li><p>已知一有向图的邻接表存储结构如图7.2所示。根据有向图的深度优先遍历算法,从顶点v1出发,所得到的顶点序列是____。<br>v1,v3,v4,v5,v2</p></li><li><p>采用邻接表存储的图的深度优先遍历算法类似于二叉树的____。</p><p><strong>先序遍历</strong></p></li><li><p>采用邻接表存储的图的<strong>广度优先遍历</strong>算法类似于二叉树的____。<br><strong>按层遍历</strong></p></li><li><p>判定一个有向图是否存在回路除了可以利用拓扑排序方法外,还可以利用____。<br><strong>深度优先遍历算法</strong></p></li><li><p>关键路径是事件结点网络中(） 。<br>从源点到汇点的最长路径</p></li><li><p>用DFS遍历一个无环有向图,并在DFS算法退栈返回时打印出相应的顶点,则输出的顶点序列是 。</p><p>逆拓扑有序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">DFS是一个递归算法,在遍历的过程中,先访问的点被压入栈底。拓扑有序是指如果点U到点V有一条弧,则在拓扑序列中U一定在V之前.深度优先算法搜索路径恰恰是一条弧,栈的输出是从最后一个被访问点开始输出,最后一个输出的点是第一个被访问的点.所以是逆的拓扑有序序列<br></code></pre></td></tr></table></figure></li><li><p>在图7.3所示的拓朴排列的结果序列为 。<br>516234</p></li><li><p>一个有n个顶点的无向连通图,它所包含的连通分量个数为 。<br>1</p><p><code>由于该图本身就是连通图，所以只可能包含一个连通分量。若不连通才可能有多个连通分量</code></p></li><li><p>对于一个有向图,若一个顶点的入度为k1,、出度为k2,则对应邻接表中该顶点单链表中的结点数为 。<br>k2</p></li><li><p>对于一个有向图,若一个顶点的入度为k1,、出度为k2,则对应逆邻接表中该顶点单链表中的结点数为 。<br>k1</p></li><li><p>一个有向图G的邻接矩阵存储如下图,按深度优先遍历算法遍历,从顶点0出发,所得到的顶点序列是( )<br>0 1 3 2 4 6 5</p></li><li><p>如果从无向图的任一顶点出发进行一次深度优先遍历即可访问所有顶点,则该图一定是( )<br>连通图</p></li><li><p>采用邻接表存储的图的深度优先遍历算法类似于二叉树的___算法。<br>先序遍历</p></li><li><p>采用邻接表存储的图的广度优先遍历算法类似于二叉树的() 算法。<br>层次遍历</p></li><li><p>图的广度优先遍历算法中用到一个队列,每个顶点最多进队( )次<br>1</p><p><code>深度优先遍历：用到了栈 ；广度优先遍历：用到了队列</code></p></li><li><p>以下叙述中错误的是<br>图的深度优先遍历不适合有向图</p></li><li><p>有n个顶点的图进行深度优先遍历,其空间复杂度为</p><p>O(n)</p></li><li><p>一个有向图G的邻接表存储如图，按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）<br>A,B,C,E,D</p></li><li><p>一个有向图G的邻接表存储如图，按广度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）<br>A,B,C,D,E</p></li><li><p>一个有向图G的邻接矩阵存储如下图，按广度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）<br>0 2 1 3 4 5 6</p></li><li><p>一棵深度为4的二叉树的结点数至多为( )。<br>31</p></li><li><p>若一棵二叉树具有10个度为2的结点,5个度为1的结点,则度为0的结点的个数是<br>11</p></li><li><p>设森林F对应的二叉树为B,它有m个结点,B的根为p,p的右子树的结点个数为n,森林F中第一棵树的结点的个数是 。（0.5分）0.0 分<br>m-n</p></li><li><p>假设一个三叉树的结点数为36,则该树的最小高度为( )。<br>4</p></li><li><p>设高度为h的二叉树中只有度为0和度为2的结点,则该树的结点数至少为( )<br>2h-1</p><img src="https://i.loli.net/2020/12/20/fsDCwEPT64l1xHq.png" style="zoom:50%;" /></li><li><p>假定在一棵二叉树中,双分支结点数为15,单分支结点数为30个,则叶子结点数为 个。<br>16</p><p><code>n0=n2+1</code></p></li><li><p>按照二叉树的定义,具有3个结点的不同形状的二叉树有____种。<br>5</p></li><li><p>按照二叉树的定义,具有3个不同数据结点的不同的二叉树有____种。<br>30</p></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.求出三个结点组成的二叉树的所有形状个数。<br>2.计算三个不同数据的排列顺序种类个数，将每种排列按二叉树的先根遍历方式填入结点算一种情况。<br>则第一步的结果是5，第二步的结果是3<span class="hljs-number">*2</span><span class="hljs-number">*1</span> = 6<br></code></pre></td></tr></table></figure><ol start="118"><li><p>深度为5的二叉树至多有个结点。<br>31 <code>2^k-1</code></p></li><li><p>设高度为h的二叉树上只有度为0和度为2的结点,则此类二叉树中所包含的结点数至少为_ ___。<br>2h-1</p></li></ol><p><code>2h-1,最少情况即为除了第h层，每层度为2的节点只有1个（产生2度，即产生2个结点），共有2(h-1)个，再加根节点总共2h-1个。</code></p><ol start="120"><li><p>对一个满二叉树,m个树叶,n个结点,深度为h,则____ 。<br>n=2^h-1</p></li><li><p>任何一棵二叉树的叶结点在先序、中序和后序遍历序列中的相对次序____。<br>不发生改变</p></li><li><p>如果某二叉树的前根次序遍历结果为stuwv,中序遍历为uwtvs,那么该二叉树的后序为____。<br>wuvts</p></li><li><p>某二叉树的前序遍历结点访问顺序是abdgcefh,中序遍历的结点访问顺序是dgbaechf,则其后序遍历的结点访问顺序是____。<br>gdbehfca</p></li><li><p>在一非空二叉树的中序遍历序列中,根结点的右边____。<br><strong>只有右子树上的所有结点</strong></p></li><li><p>如图6.1所示二叉树的中序遍历序列是____。<br>dfebagc</p></li><li><p>一棵二叉树如图6.2所示,其中序遍历的序列为__ __。<br>dgbaechf</p></li><li><p>已知某二叉树的后序遍历序列是dabec,中序遍历序列是debac,它的前序遍历序列是____。<br>cedba</p></li><li><p><strong>实现任意二叉树的后序遍历的非递归算法而不使用栈结构,最佳方案是二叉树采用存储结构。</strong><br><strong>三叉链表</strong></p></li><li><p>在线索化二叉树中,t所指结点没有左子树的充要条件是____。<br><strong>t-&gt;ltag=1</strong></p></li><li><p>树的基本遍历策略可分为先根遍历和后根遍历;二叉树的基本遍历策略可分为先序遍历、中序遍历和后序遍历。这里,我们把由树转化得到的二叉树叫做这棵数对应的二叉树。结论____是正确的。<br>树的<strong>先根</strong>遍历序列与其对应的二叉树的<strong>先序</strong>遍历序列相同</p></li><li><p>树最适合用来表示 ____。<br>元素之间<strong>具有分支层次关系</strong>的数据</p></li><li><p>如图6.3所示的4棵二叉树，____不是完全二叉树。<br>C图</p></li><li><p>设a,b为一棵二叉树上的两个结点，在中序遍历时，a在b前的条件是       。<br>a在b的左方</p></li><li><p>下列排序方法中,不稳定的排序方法是( )（0.5分）0.0 分<br>快速排序</p></li><li><p>对n个不同的元素进行起泡排序,在下列哪种情况下比较的次数最多( )。<br>元素逆序</p></li><li><p>若一组记录的排序码为(46, 79, 56, 38, 40, 84),则利用快速排序的方法,以第一个记录为基准得到的一次划分结果为( )。<br>40, 38,46, 56, 79, 84</p></li><li><p>设有一组初始关键字序列为(24,35,12,27,18,26),则将27插入到有序序列的直接插入排序结束后的结果的是( )。<br>12,24,27,35,18,26</p></li><li><p>将两个各含n个记录的有序表归并成一个新的有序表是,所需进行关键字比较次数的最小值为( )。<br>n</p></li><li><p>设语句x++的时间是单位时间,则以下语句的时间复杂度为( )。<br>for(i=1; i&lt;=n; i++)<br>{ int p=1;<br>for(j=1;j&lt;=i;j++)<br>p*=j;<br>s+=p;<br><strong>O(n2)</strong></p></li><li><p>一个向量(即一批地址连续的存储单元)第一个元素的存储地址是100,每个元素的长度为2,则第5个元素的地址是( )。<br>108 <code>第一个元素的存储地址是100，第二个是102，第三个是104，第五个是108</code></p></li><li><p>设顺序循环队列Q[0:M-1]的头指针和尾指针分别为F和R,头指针F总是指向队头元素的前一位置,尾指针R总是指向队尾元素的当前位置,则该循环队列中的元素个数为( )。<br>(R-F+M)%M</p></li><li><p>在一个单链表中,已知q结点是p结点的前趋结点,若在q和p之间插入s结点,则须执行( )<br>q-&gt;next=s; s-&gt;next=p</p></li><li><p>设输入序列是1、2、3、……、n,经过栈的作用后输出序列的第一个元素是n,则输出序列中第i个输出元素是( )。<br>n+1-i</p></li><li><p>串是一中特殊的线性表,其特殊性体现在( )。<br>数据元素是一个字符</p></li><li><p>在具有n个单元的顺序存储的循环队列中,假定front和rear分别为队头指针和队尾指针,则判断队空的条件为( )。<br>rear== front</p></li><li><p>设有一个10阶的下三角矩阵A(包括对角线),按照从上到下、从左到右的顺序存储到连续的55个存储单元中,每个数组元素占1个字节的存储空间,则A[5][4]地址与A[0][0]的地址之差为( )。<br><strong>19</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]的地址：<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>+<span class="hljs-number">5</span>+<span class="hljs-number">6</span>=<span class="hljs-number">21</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>]地址：<span class="hljs-number">21</span>-<span class="hljs-number">1</span>=<span class="hljs-number">20</span><br><span class="hljs-attribute">A</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>]-A[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">20</span>-<span class="hljs-number">1</span>=<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure></li><li><p>按照二叉树的定义,具有3个结点的不同形状的二叉树有( )种。<br>5</p></li><li><p>任何一棵二叉树的叶结点之间的相对次序在先序、中序和后序遍历序列中 ( )。<br><strong>不发生改变</strong></p></li><li><p>设有序顺序表中有n个数据元素,则利用二分查找法查找数据元素X的最多比较次数不超过( )。（0.5分）0.0 分</p><p>log2n+1</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">因为二分查找每次排除掉一半的不适合值，所以对于<span class="hljs-built_in">n</span>个元素的情况：<br> 一次二分剩下：<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span><br> 两次二分剩下：<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>/<span class="hljs-number">2</span> = <span class="hljs-built_in">n</span>/<span class="hljs-number">4</span><br> 。。。<br> m次二分剩下：<span class="hljs-built_in">n</span>/(<span class="hljs-number">2</span>^m)<br> 在最坏情况下是在排除到只剩下最后一个值之后得到结果，所以为<br>  <span class="hljs-built_in">n</span>/(<span class="hljs-number">2</span>^m)=<span class="hljs-number">1</span>;<br><br>  <span class="hljs-number">2</span>^m=<span class="hljs-built_in">n</span>; <br><br>  此时时间复杂度为log2（<span class="hljs-built_in">n</span>） <br><br>  再与最后一个元素比较复杂度+<span class="hljs-number">1</span> <br><br> 所以时间复杂度为：log2(<span class="hljs-built_in">n</span>)+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>设F是由T1、T2和T3三棵树组成的森林,与F对应的二叉树为B,T1、T2和T3的结点数分别为N1、N2和N3,则二叉树B的根结点的左子树的结点数为( )。（0.5分）0.0 分<br>N1-1</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(<span class="hljs-number">1</span>)<span class="hljs-built_in">T1</span>,<span class="hljs-built_in">T2</span>,<span class="hljs-built_in">T3</span>先分别转化为二叉树，除掉根结点，其它结点都转化为根结点的左孩子<br>(<span class="hljs-number">2</span>)第一棵二叉树不动，后面的二叉树分别是前面二叉树的右孩子。<br>故本题中<span class="hljs-built_in">T1</span>不动，左孩子结点N1<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure></li></ol><ol start="151"><li><p>在一个具有n个顶点和e条边的有向图的邻接矩阵中,表示边存在的元素个数为( )。<br>e</p></li><li><p>若一个图的边集为{(A,B),(A,C),(B,D),(C,F),(D,E),(D,F)},则从顶点A开始对该图进行深度优先搜索,得到的顶点序列可能为( )。<br>A,C,F,D,E,B</p></li><li><p>在一个具有n个顶点的无向图中,若具有e条边,则所有顶点的度数之和为( )。<br>2e</p></li><li><p>对由关键字序列(50,25,63, 18 ,42,32,90)生成的二叉排序树,由上到下、从左到右的顺序进行输出得到的序列是( )。<br>50,25,63,18,42,90,32</p></li><li><p>对下列四个序列进行快速排序,各以第一个元素为基准进行第一次划分,则在该次划分过程中需要移动元素次数最多的序列为( )。<br>5, 7, 9, 1, 3<br><code>逆序对</code></p></li><li><p>下列关键字序列中,( )是堆。<br>16, 23, 53, 31, 94, 72</p></li><li><p>一组记录的排序码为(25,48,16,35,79,82,23,40,36,72),其中含有5个长度为2 的有序表,按归并排序的方法对该序列进行一趟归并后的结果为( )。<br>16,25,35,48,23,40,79,82,36,72</p></li><li><p>下面程序的时间复杂为( )<br>for(i=1,s=0;i&lt;=n;i++)<br>{ t=1;<br>for(j=1;j&lt;=i;j++)<br>t=t*j;<br>s=s+t;<br>}<br>O(n^2)<br><code>第二层循环每次循环i次，而i是从1...n 所以循环要进行1+2+3+4+...+n次</code></p></li><li><p>设顺序循环队列Q[0:M-1]的头指针和尾指针分别为F和R,头指针F总是指向队头元素的前<br>一位置,尾指针R总是指向队尾元素的当前位置,则该循环队列中的元素个数为( )。<br>(R-F+M)%M</p></li><li><p>设某棵二叉树的中序遍历序列为ABCD,前序遍历序列为CABD,则后序遍历序列为( )。（0.5分）0.0 分<br>BADC</p></li><li><p>二叉树的第k层的结点数最多为( ).<br>2k-1</p></li><li><p>设哈夫曼树中的叶子结点总数为m,若用二叉链表作为存储结构,则该哈夫曼树中总共有( )个空指针域。<br>2m</p></li><li><p>用链表作为栈的存储结构则退栈操作( )。<br>必须判别栈是否为空</p></li><li><p>设二叉排序树中有n个结点,则二叉排序树的平均查找长度为( )<br>O(log2n)</p></li><li><p>设连通图G中的边集E={(a,b),(a,e),(a,c),(b,e),(e,d),(d,f),(f,c)},则从顶点a<br>出发不能得到一种深度优先遍历的顶点序列为( )。<br>acfebd</p></li><li><p>设指针变量p指向单链表中的某结点,q指向其后继节点,s指向一个新开辟的结点,能将s所<br>指结点插入到p所指结点后面的操作为( )<br>s-&gt;next=p-&gt;next; p-&gt;next=s;</p></li><li><p>在树中结点u与v是兄弟,将其转换为二叉树后,u和v可能具有的关系是( )<br>u是v的父结点或祖先结点</p></li><li><p>下列哪一种图的邻接矩阵是对称矩阵?( )<br>无向图</p></li><li><p>下图对应的最小生成树中,各边权值之和为:<br>18</p></li><li><p>已知有向图G=(V,E),其中V={1,2,3,4}, E={&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,4&gt;,&lt;4,2&gt;,&lt;4, 3&gt;}, 下<br>列序列中为G的拓扑排序序列的是( )。<br>1, 4, 2, 3</p></li><li><p>设一组初始记录关键字序列(5,2,6,3,8),以第一个记录关键字5为基准进行一趟快速排序<br>的结果为( )。<br>3,2,5,6,8</p></li><li><p>设一组初始记录关键字序列为((25,50),(15,35),(80,85),(20,40),(36,70)),其中含有5个长度为2的有序子表,则用2路归并升序排序的方法对该记录关键字序列进行一趟归并后的结果为__________。<br>15,25,35,50,20,40,80,85,36,70</p></li><li><p>对于线性表(7,33,55,25,64,46,20,10)进行散列存储时,若选用H(K)=K %9作为散列函数,用开放定址法的线性探测法解决冲突,在0~8的哈希地址空间中关键字64对应的散列地址为_________,（0.5分）0.0 分<br>2</p></li><li><p>设有一个二维数组A[m][n],假设A[0][0]存放位置在644(10),A[2][2]存放位置在<br>676(10),每个元素占一个空间,问A[3]<a href="10">3</a>存放在什么位置?脚注(10)表示用10进制<br>表示。<br>692</p></li><li><p>在AOE网中,如果活动aij关联的顶点为Vi和Vj,则判断aij是否为关键活动的<br>方法为( )<br>如果活动aij的最早发生时间等于它的最迟发生时间,则为关键活动</p></li><li><p>设二叉树的先序遍历序列和后序遍历序列正好相反,则该二叉树满足的条件是( )。<br>高度等于其结点数</p></li><li><p>设哈夫曼树中共有99个结点,则该树中有( )个叶子结点。<br>50</p></li><li><p>在图所示的拓朴排列的结果序列为(      )。<br>516234</p></li><li><p>设散列表的长度为8，哈希函数H(k)=k % 7，用链地址法解决冲突，则根据一组初始关键字序列(8，15，16，22，30，32)构造出的哈希表的平均查找长度是<strong>____</strong></p><p>（1+2+2+4+4+3）/6=8/3</p></li><li><p>采用折半查找法查找长度为n的线性表时,每个元素的平均查找长度为 。（0.5分）0.0 分<br>O(log2n)</p></li><li><p>有一个有序表为{1,3,9,12,32,41,45,62,75,77,82,95,100},当折半查找值为82的结点时, 次比较后查找成功。<br>4</p></li><li><p>二叉树为二叉排序树的充分必要条件是其任一结点的值均大于其左孩子的值、小于其右孩子的值。这种说法 。<br>错误</p></li><li><p>下面关于B树和B+树的叙述中,不正确的结论是 。<br>B树和B+树都能有效的支持顺序查找</p></li><li><p>以下说法错误的是 。<br>散列表的结点中只包含数据元素自身的信息,不包含指针。</p></li><li><p>查找效率最高的二叉排序树是 。<br>平衡二叉树。</p></li><li><p>排序方法中,从未排序序列中依次取出元素与<strong>已排序</strong>序列中的元素进行比较,将其放入已排序序列的正确位置上的方法,称为 。<br>插入排序</p></li><li><p>在所有的排序方法中,关键字比较的次数<strong>与记录的初始排列次序无关的是</strong> 。<br><strong>直接选择排序</strong></p></li><li><p>堆是一种有用的数据结构。下列关键码序列 是一个堆。<br>16,31,23,94,53,72</p></li><li><p>堆排序是一种 排序。<br>选择</p></li><li><p>在链表中进行  操作比在顺序表中进行操作效率高。<br>插入</p></li><li><p>直接选择排序的时间复杂度为 。(n 为元素个数)<br>O(n2)</p></li><li><p>对线性表进行折半查找时，要求线性表必须      。<br>以顺序方式存储，且结点按关键字有序排列</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap8数据结构习题集</title>
    <link href="/2021/01/01/chap8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    <url>/2021/01/01/chap8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%A0%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3>习题1 绪论</h3><p>1.1 选择题</p><ol><li>数据结构是一门研究非数值计算的程序设计问题中 ,数据元素的 <strong>存储结构</strong> 、数据信息在计算机中的 <strong>存储结构</strong> 以及一组相关的运算等的课程。</li><li>数据结构 DS(Data Struct) 可以被形式地定义为 DS=（D，R），其中 D 是 <strong>数据元素</strong> 的有限集合， R 是 D上的 <strong>关系</strong> 有限集合。</li><li>在数据结构中，从逻辑上可以把数据结构分成 <strong>线性结构和非线性结构</strong> 。</li><li>算法分析的目的是 <strong>分析算法的效率以求改进</strong>，算法分析的两个主要方面是 <strong>空间复杂性和时间复杂性</strong> 。</li><li>计算机算法指的是 <strong>解决问题的有限运算序列</strong> ，它必具备输入、输出和 <strong>可行性、确定性和有穷性</strong> 等五个特性</li></ol><p>1.2.填空题</p><ol><li>数据结构的三个要点是 <u>数据元素的逻辑结构、数据在计算机中的存储结构 和数据的运算</u>。</li><li>数据逻辑结构包括 <u>线性结构、树形结构、图形结构</u>三种类型，树形结构和图形结构合称为 <u>非线性结构</u>。</li><li>在线性结构中，第一个结点 <u>没有</u> 前驱结点，其余每个结点有且只有 <u>1</u> 个前驱结点；最后一个结点 <u>没有</u> 后续结点，其余每个结点有且只有 1 个后续结点。</li><li>在树形结构中， 树根结点 <u>没有</u> 前驱结点， 其余每个结点有且只有 1 个直接前驱结点， 叶子结点 <u>没有</u> 后续结点，其余每个结点的直接后续结点可以 <u>任意多个</u> 。</li><li>在图形结构中，每个结点的前驱结点数和后续结点数可以 <u>任意多个</u>。</li><li>线性结构中元素之间存在<u>一对一</u>关系， 树形结构中元素之间存在<u>一对多</u> 关系， 图形结构中元素之间存在 <u>多对多</u> 关系。</li><li>算法的五个重要特性是<u>有穷性</u>、<u>确定性</u>、<u>可行性</u>、<u>输入</u>、<u>输出</u>。</li><li>分析下面算法（程序段） ，给出最大语句频度： n^2 ， 时间复杂度：  O (n^2)。<br>for (i=0;i&lt;n;i++)<br>for (j=0;j&lt;n; j++)<br>A[i][j]=0; </li><li>分析下面算法（程序段） ，给出最大语句频度： n (n+1)/2 ， 时间复杂度：  O (n^2)<br>for (i=0;i&lt;n;i++)<br>for (j=0; j&lt;i; j++)<br>A[i][j]=0; </li><li>分析下面算法（程序段） ，最大语句频度： n^3 ， 时间复杂度： O (n^3)<br>s=0;<br>for (i=0;i&lt;n;i++)<br>for (j=0;j&lt;n;j++)<br>for (k=0;k&lt;n;k++)<br>s=s+B[i][j][k];<br>sum=s; </li><li>分析下面算法（程序段）给出最大语句频度： n^1/2， 时间复杂度： O (n^1/2)<br>i=s=0;<br>while (s&lt;n) { i++; s+=i; } </li><li>分析下面算法（程序段）给出最大语句频度： log 2n， 时间复杂度： O (log 2n )<br>i=1;<br>while (i&lt;=n) i=i*2; </li></ol><h3>习题二 线性表</h3><p>2.1 单项选择题</p><ol><li>一个向量（即一批地址连续的存储单元）第一个元素的存储地址是 100，每个元素的长度为 2，则第5 个元素的地址是 <strong>108</strong>。<br>A. 110 B. 108 C. 100 D. 120 </li><li>线性表的顺序存储结构是一种 <strong>随机存取</strong> 的存储结构，而链式存储结构是一种  <strong>顺序存取</strong> 的存储结构。</li><li>线性表的逻辑顺序与存储顺序总是一致的，这种说法 <strong>不正确</strong> 。</li><li>线性表若采用链式存储结构时，要求内存中可用存储单元的地址 <strong>连续或不连续都可以</strong> 。</li><li>在以下的叙述中，正确的是 <strong>线性表的链表存储结构适用于频繁插入/删除数据元素的情况</strong>。</li><li>每种数据结构都具备三个基本运算：插入、删除和查找，这种说法 <strong>正确</strong>。</li><li>不带头结点的单链表 head 为空的判定条件是 <strong>head==NULL</strong>。</li><li>带头结点的单链表 head 为空的判定条件是 <strong>head-&gt;next= =NULL</strong>。</li><li>非空的循环单链表 head 的尾结点（由 p 所指向）满足 <strong>p-&gt;next= =head</strong>。</li><li>在双向循环链表的 p 所指结点之后插入 s所指结点的操作是 **s-&gt;left=p; s-&gt;right=p-&gt;right; p-&gt;right-&gt;left=s; p-&gt;right=s;**。</li><li>在一个单链表中， 已知 q 所指结点是 p 所指结点的前驱结点， 若在 q 和 p 之间插入 s结点， 则执行 <strong>q-&gt;next=s; s-&gt;next=p;</strong></li><li>在一个单链表中，若 p 所指结点不是最后结点，在 p 之后插入 s 所指结点，则执行 <strong>s-&gt;next=p-&gt;next; p-&gt;next=s;</strong></li><li>在一个单链表中，若删除 p 所指结点的后续结点，则执行 <strong>p-&gt;next= p-&gt;next-&gt;next ；</strong></li><li>从一个具有 n 个结点的单链表中查找其值等于 x 结点时，在查找成功的情况下，需平均比较 <strong>(n+1)/2</strong> 个结点</li><li>在一个具有 n 个结点的有序单链表中插入一个新结点并仍然有序的时间复杂度是 <strong>O(n)</strong></li><li>给定有 n 个元素的向量，建立一个有序单链表的时间复杂度是 <strong>O (n^2)</strong></li></ol><p>2.2 填空题（将正确的答案填在相应的空中）</p><ol><li>对于顺序表（采用顺序存储结构的线性表） (a 1，a2，… , an) ，设 L 表示一个元素占用的存储单元个数， LOC(ai ) 表示线性表第 i 个元素的地址，已知第 1 个元素的地址为 LOC(a1) ，则 LOC(ai )= </li><li>向一个长度为 n 的顺序表的第 i 个元素（ 1≤i ≤n+1）之前插入一个元素时，需向后移动  <strong>n-i+1</strong> 个元素</li><li>向一个长度为 n 的顺序表中删除第 i 个元素（ 1≤ i ≤n）时，需向前移动 <strong>n-i</strong> 个元素。</li><li>单链表可以看做 <u>线性表</u> 的链式存储表示</li><li>在双链表中，每个结点有两个指针域，一个指向 <u>前驱结点</u> ，另一个指向 <u>后继结点</u> 。</li><li>带头结点的单链表中，除头结点外，任一结点的存储位置是在<u>其前驱结点的指针域中</u>。</li><li>单链表中引入头结点的作用是<u>在链表的第一个位置上行插入和删除等操作时无须进行特殊处理</u></li><li>一个长为 n 的线性表，其排序时间性能最优为 <u>O(n*Log 2n)</u>。</li><li>在一个单链表中 p 所指结点之前插入一个 s (值为 e)所指结点时，可执行如下操作：<br>q=head;<br>while (q-&gt;next!=p) q=q-&gt;next;<br>s= (struct node *)malloc(sizeof(struct node)); s-&gt;data=e;<br>q-&gt;next= <u>s</u> ; //填空<br>s-&gt;next= <u>p</u> ; //填空</li><li>在一个单链表中删除 p 所指结点的后继结点时，应执行以下操作：<br>q= p-&gt;next;<br>p-&gt;next=  <u>q-&gt;next</u> ; //填空<br>free( <u>q</u> ) ; //填空</li><li>在一个单链表中 p 所指结点之后插入一个 s 所指结点时，应执行 s-&gt;next= <u>p-&gt;next</u> 和 p-&gt;next=<u>s</u> 的 操作。</li><li>对于一个具有 n 个结点的单链表，在<strong>已知 p</strong> 所指结点后插入一个新结点的时间复杂度是 <u>O (1)</u>  ；<br>在给定值为 x 的结点后插入一个新结点的时间复杂度是 <u>O (n)</u> </li></ol><h3>习题三 栈和队列</h3><p>3.1 单项选择题</p><ol><li>一个栈的入栈序列 a，b，c，d，e，则栈的不可能的输出序列是 <strong>dceab</strong>。</li><li>若已知一个栈的入栈序列是 1，2，3，…， n，其输出序列为 p1， p2，p3，…， pn，若 p1=n，则 pi为 <strong>n-i+1</strong></li><li>栈结构通常采用的两种存储结构是 <strong>顺序存储结构和链式存储结构</strong></li><li>判定一个顺序栈 ST（最多元素为 m0）为空的条件是 <strong>top= =0</strong>。</li><li>判定一个顺序栈 ST（最多元素为 m0）为栈满的条件是 <strong>top= =m0-1</strong></li><li>栈的特点是 <strong>先进后出</strong>，队列的特点是 <strong>先进先出</strong>。</li><li>向一个栈顶指针为 HS的链栈中插入一个 s 所指结点时，则执行 **s —＞ next= HS; HS=s; ** 。( <u>不带空的头结点</u> )<br><code>如果带头结点 头插法为: s —＞ next= HS —＞ next; HS —＞ next=s; </code></li><li>从一个栈顶指针为 HS的链栈中删除一个结点时，用 x 保存被删结点的值，则执行 <strong>x=HS —＞ data; HS= HS —＞ next;</strong> 。( 不带空的头结点 ) </li><li>一个队列的数据入列序列是 1，2，3，4，则队列的出队时输出序列是 <strong>1 ，2，3，4</strong> 。</li><li>判定一个循环队列 QU（最多元素为 m）为空的条件是 <strong>front= = rear</strong>。</li><li>判定一个循环队列 QU（最多元素为 m, m= =Maxsize-1 ）为满队列的条件是 <strong>(rear+1)% Maxsize = =front</strong></li><li>循环队列用数组 A[0，m-1] 存放其元素值， 已知其头尾指针分别是 front 和 rear ，则当前队列中的元素个数是 <strong>(rear-front+m)%m</strong>。</li><li>栈和队列的共同点是 <strong>只允许在端点处插入和删除元素</strong></li></ol><p>3.2 填空题（将正确的答案填在相应的空中）</p><ol><li><p>向量、栈和队列都是 <u>线性</u> 结构，可以在向量的 <u>任何</u> 位置插入和删除元素；对于栈只能在 <u>栈顶</u> 插入和删除元素；对于队列只能在 队尾 插入元素和 队首 删除元素。</p></li><li><p>向栈中压入元素的操作是 <u>先移动栈顶指针，后存入元素</u></p></li><li><p>对栈进行退栈时的操作是 <u>先取出元素，后移动栈顶指针</u></p></li><li><p>在一个循环队列中，队首指针指向队首元素的 <u>前一个位置</u></p></li><li><p>从循环队列中删除一个元素时，其操作是 <u>先移动队首元素，后取出元素</u></p></li><li><p>在具有 n 个单元的循环队列中，队满时共有 <u>n-1</u> 个元素。</p></li><li><p>一个栈的输入序列是 12345，则栈的输出序列 43512 是<u>不可能的</u></p></li><li><p>一个栈的输入序列是 12345，则栈的输出序列 12345 <u>是可能的</u></p></li><li><p>想象六辆列车位于图中堆栈的输入一边，列车编号为 123456，按此顺序开进堆栈，且可在任意时刻开走，则能否得到 32564l 出站序列 ?能否得到 154623 出站序列 ?在可能的情况下，说明如何实现。能得到 325641．</p><p>实现过程为； Push，push，push，pop，pop，Push，push，pop，push，pop，pop，pop。不能得到 154623。</p></li><li><p>设循环队列存放在向量 sq.data[o．．m]中，则队头指针 sq.front 在循环意义下的加 1 操作可用模运算表示为 (sq.front+1) MOD m 。若用牺牲一个单元的办法来区分队满和队空条件，则队满条件可表示为 (sq.rear+1) MOD m＝sq.front 。</p></li><li><p>设顺序栈存放在一维数组 s[M] ，栈底位置是 m-1，则栈空条件 <u>top=0</u> ，栈满条件是 <u>top=m</u> </p></li><li><p>循环队列只有下溢，没有上溢。 ( <u>错误</u> ) </p></li><li><p>队列和栈都是运算受限的线性表，只允许在表的两端进行运算。（ <u>正确</u> ）</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell复习</title>
    <link href="/2020/12/27/Shell%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/12/27/Shell%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>命令行上执行</strong> <code>bash shellfile1</code>或<code>sh shellfile1</code></p><p><strong>文件名直接运行</strong> </p><p><code>chmod u+x shellfile1</code>变为可执行文件</p><p><code>PATH=$PATH:./</code>将当前目录加入用户的PATH变量中</p><p><strong>给位置变量赋值</strong> <code>set</code> 后面一组数 依次赋值给位置变量</p><p><strong>常用位置变量</strong>  $0 命令本身 | $1…$9 10个参数 | $# 参数个数 | $* 全部参数</p><h3>分支结构</h3><p>一个if结构 <code>注意空格</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ $abc  = y ] <br><br>  then<br><br>echo “Yes”<br><br>  else<br><br>echo “No”<br><br>fi<br></code></pre></td></tr></table></figure><p>一个if elif结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">if  test $n1 -le  $n2 -a  $n1  -le $n3<br><br>  then <br><br>echo “The smallest number is :$n1.”<br><br>elif test  $n2 -le  $n1 -a  $n2  -le $n3<br><br>  then<br><br>echo “The smallest number is :$n2.”<br><br>  else <br><br>echo “The smallest number is :$n3.”<br><br>fi<br></code></pre></td></tr></table></figure><p>一个for循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">for count in $1 $2 $3<br>  do<br>let sum=sum+count  # sum=`expr $sum + $count`<br>  done<br>echo  $1+$2+$3=$sum<br></code></pre></td></tr></table></figure><p>一个while循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">while  [ $count -gt 0 ]  <br>  do<br> echo $count<br>let count=count-1 <br>  done<br></code></pre></td></tr></table></figure><p>一个until循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">until  [ $count -le 0 ]  <br>  do<br>echo $count<br>let count=count-1<br>  done<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux&amp;ShellReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux复习</title>
    <link href="/2020/12/25/Linux%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/12/25/Linux%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3>文件系统</h3><p>当前目录 <code>pwd</code></p><p><strong>七种文件类型</strong></p><table><thead><tr><th align="center">文件类型标识</th><th align="center">文件类型</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">普通文件</td></tr><tr><td align="center">d</td><td align="center">目录</td></tr><tr><td align="center">l</td><td align="center">符号链接</td></tr><tr><td align="center">s（伪文件）</td><td align="center">套接字</td></tr><tr><td align="center">b（伪文件）</td><td align="center">块设备</td></tr><tr><td align="center">c（伪文件）</td><td align="center">字符设备</td></tr><tr><td align="center">p（伪文件）</td><td align="center">管道</td></tr></tbody></table><p><strong>创建多级目录:</strong></p><p><code>mkdir -p xx/yy/zz</code></p><p><strong>删除多级目录</strong> (rmdir拒绝删除非空目录和文件)</p><p><code>rmdir -p xx/yy/zz</code></p><p><strong>递归删除目录其中的所有文件和子目录</strong></p><p><code>rm -r srcDir</code></p><p><strong>文件复制并重命名</strong></p><p><code>cp 源文件 目标目录/文件名</code></p><p><strong>文件重命名</strong></p><p><code>mv 原文件名 新文件名</code></p><p><strong>递归复制目录</strong></p><p><code>cp -r srcDir newDir //newDir不存在 只有src中的文件被复制</code></p><p><code>cp -r srcDir oldDir //oldDir 已存在 src文件以及目录本身都被复制</code></p><p>查看目录中所有文件的<strong>i节点号(inode)</strong></p><p><code>ls -i</code></p><p><strong>显示文件内容<u>带行号</u></strong></p><p><code>cat -n filename</code></p><p><strong>硬链接</strong></p><p><code>ln srcFile hardLink(硬链接文件名)</code></p><p><strong>软链接</strong></p><p><code>ln -s srcFile softLink(软链接文件名)</code></p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">[<span class="hljs-comment">^tips:</span>不论硬链接文件还是软链接文件，内容都和源文件一样。<br>修改硬连接文件或者符号链接文件，另两个文件同样变化。]<br></code></pre></td></tr></table></figure><p><strong>查找文件并删除</strong></p><p><code>find 目标目录 -name filename -type filetype -exec em &#123;&#125; \;</code></p><p><strong>查找文件正则表达式举例:</strong></p><p>行以“Test”or”test”开头  <code>^[tT]est</code></p><p>行以“end.”结尾  <code>endl.$</code></p><p>整行是:This is a test.  <code>^This is a test\.$</code></p><p>以下任意名称:file5,file6,file7,file8  <code>file[5678]</code></p><p>以下任意名称:file2,file4,file6,file8  <code>file[2468]</code></p><p>名字中包含“D”      <code>“*D*”</code></p><p><strong>grep命令</strong>查找 /etc/passwd 文件:</p><p>​    打印mail用户的信息  <code>grep mail /etc/passwd</code></p><p>​    打印 shells 为 /bin/bash的所有账户   <code>grep “bin/bash” /etc/passwd</code></p><p>​    打印 UID or GID (第三或第四列) 为 5 的所有账户  <code>grep :5: /etc/passwd</code></p><p>​    打印 UID 在 60-69 之间， GID在50-59 之间的所有账户  <code>grep :6[0-9]:5[0-9]: /etc/passwd</code></p><p>查看主目录内容并将结果<strong>追加</strong>到f1  <code>ls&gt;&gt; f1</code></p><p>显示lslarge的第<strong>6-10行</strong></p><p><code>head lslarge|tail -5  </code>或 <code>tail lslarge -n +6|head -n 5</code></p><h3>压缩</h3><p><strong>tar命令</strong>常用参数:</p><p>-c 建立新的压缩文件 create</p><p>-t 显示压缩文件的内容 list</p><p>-z 支持gzip解压文件 gzip</p><p>-v 显示操作过程 verbose</p><p>-f 指定压缩文件 file</p><p>-C 切换到指定目录 directory</p><p>-x 解压缩 extract</p><p>当前目录下的所有文件<strong>打包成</strong>主目录下的存档文件tarfile</p><p><code>tar  -cvf  ~/tarfile .</code></p><p><strong>查看</strong>tarfile文件中的内容</p><p><code>tar  -tvf ~/tarfile</code></p><p>主目录下的文件<strong>打包并压缩为</strong>home.<strong>gz</strong>文件</p><p><code>tar -czvf home.gz ~</code></p><p>将home.<strong>gz</strong>文件<strong>解压缩到</strong>/tmp目录</p><p><code>tar -xzvf  home.gz -C  /tmp</code></p><h3>vi编辑器</h3><p><strong>搜索</strong> /（向前搜索）?（向后搜索）n（寻找下一个)</p><p>光标<strong>定位到文件首</strong> <code>gg</code></p><p><strong>删除命令:</strong> </p><p>删除10个字符 <code>10x</code></p><p>删除3行 <code>3dd</code>      删除一行内容 <code>dd</code>   从光标开始，删除到行尾 <code>d$</code></p><p>从光标开始删除到行首 <code>d0</code>   光标位置到当前字尾 <code>de/dw</code>  光标位置到当前字首 <code>db</code></p><p><strong>复制命令:</strong></p><p>当前行复制到临时缓冲区 <code>yy</code>  从光标开始，复制至行尾放到临时缓冲区中<code>y$</code></p><p>从光标开始复制至行首放到临时缓冲区 <code>y0</code></p><p>从光标开始复制至字尾放到临时缓冲区 <code>ye/yw</code></p><p>从光标开始复制至字首放到临时缓冲区 <code>yb</code></p><p><strong>撤销</strong>操作 <code>u</code></p><p><strong>替换</strong> r替换字符 R替换单词(esc退出)</p><p><strong>命令模式下移动:</strong></p><p>h、j、k、l (对应上、下、左、右)</p><p>$(行尾)  0(行首)  G键(末尾行) 回车(下一行行首) 空格(右移一格) 退格键(左移一格)</p><p><strong>只读方式打开</strong> <code>-R</code> 强制保存退出 <code>:wq!</code>  不保存退出 <code>:q！</code></p><p>将<u>myfile</u>文件内容<strong>追加到truth</strong>，<code>另存为mytruth文件</code>，而truth文件的内容不变。</p><p><strong>vi  truth</strong>之后，在命令模式下<u>:r myfile</u>,然后<code>：w mytruth,然后:q!</code></p><p><strong>前5行写到一个新文件</strong>中，文件名为mysecond  :1,5 w mysecond`</p><p>将2号缓冲区的内容<strong>粘贴</strong>到文件头  <code>&quot;2P</code></p><p>yy命令<strong>复制3行</strong>放到c缓冲区 <code>&quot;c3yy</code></p><p>然后将c缓冲区的内容粘贴在文件的<strong>尾部</strong> <code>&quot;cp</code></p><p>将文件加上<strong>行号</strong> <code>:set number</code></p><p>设置搜索<strong>忽略大小写</strong> <code>:set ignorecase</code></p><p><strong>创建缩写</strong> :ab dyq duanyuqing</p><p><strong>定义宏</strong> 将q键定义成5x  <code>:map q 5x</code></p><p><strong>增加</strong>当前日期（date）<code>：r !date</code></p><p>所有文本<strong>连成一行</strong> <code>J命令</code></p><h3>用户和组管理</h3><p>没有设置密码的用户  /etc/shadow文件中密码为!!，所以不能登录</p><p><strong>清除</strong>stu2的<strong>密码</strong> <code>passwd -d  stu2 </code></p><p><strong>锁定</strong>stu1<strong>用户</strong> <code>passwd -l stu1</code> </p><p><strong>查看</strong>stu1用户的<strong>状态</strong> <code>passwd -S stu1</code> </p><p><strong>解锁</strong>stu1 <code>passwd  -u stu1</code></p><p>查看student用户的<strong>用户id以及组id信息</strong> <code>id  student</code></p><p> stu1和stu2<strong>添加到组</strong>market <code>gpasswd -M stu1,stu2 market</code> <u>-M指定组成员</u></p><p>将stu1加入student组 <code>gpasswd -a stu1 student</code> <u>-a添加用户</u></p><p>创建用户nasha <strong>附属组为manager 不允许login</strong></p><p><code> useradd -G manager -s /sbin/nologin nasha</code></p><p>查看myfile<strong>文件的访问权限</strong>以及查看<strong>文件属主属组</strong> <code>ls –l myfile</code></p><p>查看memos<strong>目录的访问权限</strong> <code>ls –ld memos</code></p><p><strong>权限全部删除</strong> <code> chmod a=  myfile</code></p><p>只有rw权限的目录 <code>不能将工作目录切换为memos，能显示列表，不允许创建文件</code></p><p>有rwx权限的目录 <code> 能将工作目录切换为memos，能显示列表，能创建文件</code></p><p>指定afile的<strong>属主</strong>为stu1，<strong>属组</strong>为root <code>chown stu1:root afile</code> <u>一般格式为属主:属组</u></p><p><strong>setfacl</strong>指定stu1对bfile的执行权限为读写 <code>setfacl –m u:stu1:rw bfile</code></p><h3>系统资源管理</h3><p><strong>磁盘分区</strong> <code>fdisk /dev/sda -&gt;交互</code></p><p><strong>创建VG</strong>  <code>pvcreate /dev/vda -&gt; vgcreate -s 8M vgname /dev/vda</code> 指定PE大小为8M VG名为vgname</p><p><strong>创建LV</strong> <code>lvcreate -l 100 -n lvname /dev/vgname</code> 指定PE个数100 LV名lvname</p><p><strong>格式化为vfat</strong> <code>mkfs -t vfat /dev/vgname/lvname</code></p><p><strong>挂载</strong> <code>mount /dev/vgname/lvname /mnt/wshare</code></p><p><strong>挂载重启时自动生效</strong> <code>/etc/fstab 添加：/dev/vgname/lvname  /mnt/wshare vfat defaults 0 0</code></p><p><strong>树形结构显示</strong>系统进程(带进程号)  <code>pstree -p</code></p><p><strong>静态显示</strong>当前进程 <code>ps aux</code> 或 <code>ps elf</code></p><p><strong>动态显示</strong>当前进程 <code>top</code> 按q退出</p><p><strong>查找</strong>包含“log”字符串的<strong>进程号以及进程名</strong> <code>pgrep –l &quot;log&quot; </code>  l选项显示名字</p><p><strong>查看bash进程号</strong> <code>ps</code> 或 <code>pgrep bash</code></p><p>用<strong>kill终止</strong>进程 <code>kill -9 进程号</code>      <code>kill通过pid杀死进程 pkill通过命令名成批杀死进程</code></p><p>用<strong>pkill终止</strong>pts/1 <code>pkill -9 -t pts/1</code>      <code>-t 指定开启进程的终端</code></p><p><strong>延时</strong>1分钟显示 <code>sleep 60; echo &quot;hello world&quot;</code></p><p><strong>一次性计划</strong> 5分钟后执行date命令 <code>at now+5minutes 回车 -&gt; at&gt;date -&gt; at&gt;ctrl+d</code> </p><p>at命令用<u>相对计时法</u></p><p>周期性计划 natasha在每天14:23执行echo“file­_world” <code>crontab -e -u natasha -&gt;  vi编辑器输入: 23 14 * * * /bin/echo &quot;file_world&quot;</code>     </p><p><code>-e : 执行文字编辑器</code> 被执行的命令通常要求用<u>绝对路径名</u></p><h3>服务管理和网络管理</h3><p><strong>邮件</strong> <code>mail</code></p><p><strong>消息</strong> <code>write 写入权限用mesg控制</code> </p><p><strong>广播</strong> <code>wall</code></p><p>查询httpd在<strong>各种运行级别的启动状态</strong> <code>chkconfig --list httpd</code></p><p>设置httpd服务<strong>随系统启动而启动</strong> <code>chkconfig httpd on</code></p><p>查看<strong>路由表和网关</strong> <code>route</code></p><p>查看<strong>网络接口配置</strong> <code>ifconfig</code></p><p><strong>查看主机名</strong> <code>hostname</code> </p><p><strong>修改主机名</strong> <code>hostname newname(重启失效) 或修改配置文件vi /etc/sysconfig/network</code></p><p><strong>解析域名</strong> <code>nslookup</code></p><p><strong>Apache服务</strong> httpd</p><p><strong>vsftpd服务</strong> vsftpd</p><p><strong>NFS服务</strong> nfs</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux&amp;ShellReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap7排序复习题</title>
    <link href="/2020/12/24/chap7%E6%8E%92%E5%BA%8F%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/24/chap7%E6%8E%92%E5%BA%8F%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>下列排序方法中，稳定的排序方法是（  <strong>冒泡排序</strong> ） </p></li><li><p>在下列排序算法中,哪一个算法的时间复杂度与初始排序无关（ <strong>简单选择排序 </strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">最好、最坏、平均三项复杂度全是一样的就是与初始排序无关的排序方法，也就是：<br>选择排序、堆排、归并、基数<br></code></pre></td></tr></table></figure></li><li><p>排序方法中，从未排序序列中依次取出元素与已排序序列（初始时为空）中的元素进行比较，将其放入已排序序列的正确位置上的方法，称为（ <strong>插入排序</strong>  ）</p></li><li><p>从未排序序列中挑选元素，并将其依次插入已排序序列（初始时为空）的一端的方法，称为（ <strong>选择排序</strong> ）</p></li><li><p>对ｎ个不同的元素进行冒泡排序，在下列哪种情况下比较的次数最多（ <strong>元素逆序</strong> ）</p></li><li><p>对ｎ个不同的排序码进行冒泡排序，在元素无序的情况下比较的次数为（ <strong>n(n-1)/2</strong> ）</p></li><li><p>快速排序在下列哪种情况下最易发挥其长处（ <strong>被排序的数据完全无序</strong> ）</p><p><code>随机快排的性质就是不希望数据有序，当数据无序时，可以实现nlogn</code></p></li><li><p>对n个记录的进行快速排序，在最坏情况下，算法的时间复杂度是（ <strong>O(n^2)</strong> ）。</p></li><li><p>若一组记录的排序码为（46, 79, 56, 38, 40, 84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（ 40, 38，46, 56, 79, 84 ）<code>参考笔记中快排方法</code></p></li><li><p>下列关键字序列中，（ 16, 23, 53, 31, 94, 72 ）是堆 <code>层序写出二叉树</code></p></li><li><p>堆是一种（ <strong>选择</strong> ）排序</p></li><li><p>堆的形状是一棵（ <strong>完全二叉树</strong> ）</p></li><li><p>若一组记录为（46, 79, 56, 38, 40, 84），则利用堆排序建立的初始堆为（ 84, 79, 56, 38, 40, 46  ）。</p></li></ol><img src="https://uploadfiles.nowcoder.com/images/20170726/7683489_1501073799292_985A5D07575F610DE3B38EFAF9EDEB9D" style="zoom: 33%;" /><ol start="14"><li>下述几种排序方法中，要求内存最大的是（ <strong>归并排序</strong> ）</li></ol><p><code>冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1)</code></p><p><code>因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)  </code></p><p><code>快速排序空间复杂度为logn(因为递归调用了) </code></p><p><code>归并排序空间复杂是O(n),需要一个大小为n的临时数组 基数排序的空间复杂是O(n)</code></p><h4>二、填空题</h4><ol><li><p>大多数排序算法都有两个基本的操作：<strong><u>比较</u></strong> 和 <strong><u>移动</u></strong></p></li><li><p>在对一组记录（54，38，96，23，15，72，60，45，83）进行直接插入排序时，当把第7个记录60插入到有序表时，为寻找插入位置至少需比较  6  次</p></li><li><p>在插入和选择排序中，若初始数据基本正序，则选用   <strong><u>插入排序</u></strong>  ；若初始数据基本反序，则选用   <strong><u>选择排序</u></strong>  </p><p><code>基本正序时用插入排序，因为这时的关键字比较次数和记录移动次数都很少</code><br><code>基本反序用选择排序，此时两者的关键字比较次数差不多，选择排序的记录移动次数很少</code></p></li><li><p>在堆排序和快速排序中，若初始记录接近正序或反序，则选用  堆排序 ；若初始记录基本无序，则最好选用  快速排序  。</p></li><li><p>对于n个记录的集合进行冒泡排序，在最坏的情况下所需要的时间是  O(n^2)   若对其进行快速排序，在最坏的情况下所需要的时间是   O(n^2)  </p></li><li><p>对于n个记录的集合进行归并排序，所需要的平均时间是  O(nlog2n)  ，所需要的附加空间是    O(n)</p></li><li><p>对于n个记录的表进行2路归并排序，整个归并排序需进行     趟（遍）。</p></li><li><p>设要将序列（Q, H, C, Y, P, A, M, S, R, D, F, X）中的关键码按字母升序重新排列，则：</p><p>冒泡排序第一趟的排序结果是 H C Q P A M S R D F X Y</p><p>初始步长为4的希尔（shell）排序第一趟的排序结果是 P A C S Q H F X R D M Y</p><p><code>希尔排序 步长为4，因此，1,5,9号元素比较，在这三个位置上进行排序 然后2,6,10号元素 类推</code></p><p>二路归并排序第一趟的排序结果是 H Q C Y A P M S D R F X </p><p><code>第一趟：相邻两个排序。第二趟：2与2 排序。第三趟：4与4排序。</code></p><p>快速排序第一趟的排序结果是 F H C D P A M Q R S Y X </p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">排序开始：i=<span class="hljs-number">0</span>，j=N-<span class="hljs-number">1</span>  key=<span class="hljs-keyword">A</span>[<span class="hljs-number">0</span>]<br>从j开始向前搜索，找到第一个小于key的值<span class="hljs-keyword">A</span>[j]，将<span class="hljs-keyword">A</span>[j]和<span class="hljs-keyword">A</span>[i]互换；<br>从i开始向后搜索，找到第一个大于key的<span class="hljs-keyword">A</span>[i]，将<span class="hljs-keyword">A</span>[i]和<span class="hljs-keyword">A</span>[j]互换； <br>重复上<span class="hljs-number">2</span>步，直到i=j；<br></code></pre></td></tr></table></figure><p>堆排序初始建堆的结果是 A D C R F Q M S Y P H X</p><p><code>建堆的过程，放进完全二叉树之后，从最后一个非叶子节点开始调整，从右往左 </code></p></li><li><p>在堆排序、快速排序和归并排序这3种排序方法中，若只从存储空间考虑，则应首先选取 <strong><u>堆排序</u></strong> ，其次选取 <strong><u>快速排序</u></strong> ，最后选取 <strong><u>归并排序</u></strong> ；若只从排序结果的稳定性考虑，则应选取  <strong><u>归并排序</u></strong> ；若只从最坏情况下最快并且要节省内存考虑，则应选取  <strong><u>堆排序</u></strong></p><p><code>冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1)</code></p><p><code>因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)  </code></p><p><code>快速排序空间复杂度为logn(因为递归调用了) </code></p><p><code>归并排序空间复杂是O(n),需要一个大小为n的临时数组 基数排序的空间复杂是O(n)</code></p></li></ol><h4>三、判断题</h4><ol><li><p>内部排序不是<del>要求待排序数据一定要以顺序方式存储</del>   <code>内部排序 是指待 排序 列完全存放在内存中所进行的 排序 过程，与存储方式无关</code></p></li><li><p>排序算法中的比较次数与初始元素序列的排列不是<del>无关</del> </p><p><code>比较次数与初始元素顺序无关的排序算法（即最好、最坏情况的时间复杂度一样）</code></p><p><code>选择排序O(n^2)  堆排序O(nlogn) 归并排序O(nlogn) 基数排序O(tn)</code></p></li><li><p>快速排序的速度在所有排序方法中不一定~~为最快,而且所需附加空间也最少~~~`平均时间复杂度O(nlog n)空间复杂度 O(log n)`</p></li><li><p>堆排序不<del>是稳定的排序方法</del></p></li><li><p>归并排序的辅助存储不是<del>为O(1)</del><code>归并排序要用一个同等大小的数组作为存储空间，是空间我复杂度最高的排序 辅助存储O(n)</code></p></li></ol><h4>四、计算题</h4><ol><li><p>对关键字序列 (12, 23, 56, 30, 78, 28, 37, 10, 42, 65 ) 从小到大排序，请写出希尔排序的第一趟和第二趟排序结果（d=5，3，1），要求必须写出过程。</p><p><img src="https://i.loli.net/2020/12/24/KpJhTSV5sjIm314.png"></p></li><li><p>已知待排序序列为{43, 71, 86, 13, 38, 60, 27}，写出直接插入排序的前3趟排序结果。</p><p>初始：  <strong>[43]</strong>, 71, 86, 13, 38, 60, 27</p><p>第1趟：**[43, 71]**, 86, 13, 38, 60, 27</p><p>第2趟：**[43, 71, 86]**, 13, 38, 60, 27</p><p>第3趟：**[13, 43, 71, 86],** 38, 60, 27</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap6查找复习题</title>
    <link href="/2020/12/22/chap6%E6%9F%A5%E6%89%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap6%E6%9F%A5%E6%89%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>在表长为ｎ的链表中进行顺序查找，等概率情况下查找成功的ASL为（ <strong>(n+1)/2</strong> ）</p></li><li><p>折半查找有序表（4，6，10，12，20，30，50，70，88，100），若查找元素58，则它将依次与表中（ <strong>20，70，30，50</strong>  ）比较大小，查找结果是失败</p></li><li><p>对22个记录的有序表作折半查找，查找失败时，至少需要比较（ 4 ）次关键字</p><p><code>其折半查找的判定树深度为 log2(22) + 1=5，且该判定树不是满二叉树，即查找失败时至多比较 5 次，至少比较 4 次</code></p></li><li><p>链表适用于（ <strong>顺序</strong> ）查找</p></li><li><p>设哈希表长为14，哈希函数是H(key)=key%11，表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的结点加到表中，用二次探测再散列法解决冲突，则放入的位置是(  9 ) </p><p><code>49%11=5被占用了（5+1^2）%11=6还是被占用了</code></p><p><code>（5-1^2）%11=4被占用了（5+2^2）%11=9未被占用，所以在9的位置放入49</code></p></li><li><p>适用于折半查找的表的存储方式及元素排列要求为( <strong>顺序方式存储，元素有序</strong> )</p></li><li><p>对长度为3的顺序表做顺序查找，若查找第1个元素的概率为1/2.，查找第2个元素的概率为1/3，查找第3个元素的概率为1/6，则成功查找表中任一元素的平均查找长度为（ 5/3 ）</p><p><code>求期望</code></p></li><li><p>一个哈希表中有n个元素，用哈希法进行查找的平均查找长度为（ <strong>O(1)</strong> ）</p></li><li><p>设哈希表的长度为m，采用除留余数法：H(key)=key % p，一般选择p为（ <strong>小于或等于m的最大质数</strong>  ）</p></li><li><p>哈希表的平均查找长度（ <strong>与处理冲突的方法有关而与表的长度无关</strong> ）</p></li></ol><h4>二、填空题</h4><ol><li><p>在数据的存放<strong>无规律的线性表</strong>中进行检索的最佳方法是 <strong><u>顺序查找</u></strong> </p></li><li><p>折半查找有序表（4，6，12，20，28，38，50，70，88，100），若查找表中元素20，它将依次与表中元素  <u>28，6，12，20</u> 比较大小。</p></li><li><p>线性有序表（a1，a2，a3，…，a256)是从小到大排列的，对一个给定的值k，用二分法检索表中与k相等的元素，在查找不成功的情况下，最多需要检索 <u>8</u> 次。设有100个结点，用二分法查找时，最大比较次数是  <u>7</u></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">100</span>/<span class="hljs-number">2</span>  取<span class="hljs-number">50</span> 一次 <br><span class="hljs-attribute">50</span>/<span class="hljs-number">2</span>  取<span class="hljs-number">25</span> 二次<br><span class="hljs-attribute">25</span>/<span class="hljs-number">2</span>  取<span class="hljs-number">13</span> 三次<br><span class="hljs-attribute">13</span>/<span class="hljs-number">2</span> 取<span class="hljs-number">7</span> 四次<br><span class="hljs-attribute">7</span>/<span class="hljs-number">2</span> 取 <span class="hljs-number">4</span> 五次<br><span class="hljs-attribute">4</span>/<span class="hljs-number">2</span> 取<span class="hljs-number">2</span> 六次<br><span class="hljs-attribute">2</span>再来个二分必出结果  七次<br></code></pre></td></tr></table></figure></li><li><p>在各种查找方法中，平均查找长度与记录个数n无关的查找方法是 <strong><u>哈希查找</u></strong></p></li><li><p>哈希法存储的基本思想是由   <strong><u>关键字的值</u></strong> 决定数据的存储地址</p></li><li><p>有一个表长为m的散列表，初始状态为空，现将n（n&lt;m）个不同的关键码插入到散列表中，解决冲突的方法是用线性探测法。如果这n个关键码的散列地址都相同，则探测的总次数是        <u>n(n-1)/2</u> (而任一元素查找次数 ≤n-1)</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">插入第一个关键码时，检查<span class="hljs-symbol">x</span>位置，结果为空，直接插入，探测次数为<span class="hljs-number">0</span>；<br>插入第二个关键码时，检查<span class="hljs-symbol">x</span>位置，结果不为空，采用线性探测法，继续探测<span class="hljs-symbol">x</span>+<span class="hljs-number">1</span>位置，结果为空，插入，探测次数为<span class="hljs-number">1</span>；<br>……<br>插入第n个关键码时，<span class="hljs-symbol">x</span>位置不为空，从<span class="hljs-symbol">x</span>+<span class="hljs-number">1</span>位置开始探测，直至探测到<span class="hljs-symbol">x</span>+(n<span class="hljs-number">-1</span>)位置时才为空（这里假设<span class="hljs-symbol">x</span>+(n<span class="hljs-number">-1</span>)&lt;m），执行插入操作，探测次数为n<span class="hljs-number">-1</span>次。<br>所以，总的探测次数是一个等差数列<br></code></pre></td></tr></table></figure></li></ol><h4>三、判断题</h4><ol><li><p>有n个数存放在一维数组中，在进行顺序查找时，这n个数的排列有序或无序其平均查找长度不是<del>不同</del>。</p><p><code>平均查找长度是指：等概率下依次查找所有元素的比较次数。</code></p><p><code>所以无论有序无序，平均长度=(1+2+3+4+...+n )/ n，只与元素个数有关</code></p></li><li><p>折半查找的效率不是<del>肯定高于</del>顺序查找</p></li><li><p>在二叉排序树中插入一个新结点，该新结点<strong>肯定是叶子结点</strong>。</p></li><li><p>一棵二叉排序树的先序遍历序列正好是待排序数据的非递减序列</p><p><code>任一结点的键值大于其左孩子(及其子孙)的键值且小于其右孩子(及其子孙)的键值。</code></p><p><code>因此，中序LNR遍历一棵二叉排序树所得的结点访问序列是键值的递增序列。</code></p></li><li><p>n个结点的二叉排序树有多种，其中<strong>树的高度最小的二叉排序树是最佳的</strong>。</p></li><li><p>哈希函数的选择<strong>原则之一是函数比较简单且能在较短时间内计算出结果</strong>。</p></li><li><p>在哈希检索中，“比较”操作一般不<del>是不可避免的</del>。（  ）</p></li><li><p>哈希函数不是<del>越复杂越好，因为这样随机性好，冲突概率小。</del>哈希函数越复杂，则时间就会越多</p></li></ol><h4>四、计算题</h4><ol><li>画出对长度为10的有序表进行折半查找的判定树，并求其等概率时查找成功的平均查找长度。</li></ol><p>​     <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521091807507_243FFB1D3538098C4D8461885A5761FE"></p><ol start="2"><li>在一 棵空的二叉排序树中依次插入关键字序列为12，7，17，11，16，2，13，9，21，4，请画出所得到的二叉排序树。</li></ol><p>​     <img src="https://uploadfiles.nowcoder.com/images/20170304/5437584_1488613304796_072774B6B658B3603E1AA7198722775C"></p><ol start="3"><li><p>已知长度为12的表：（Jan, Feb, Mar, Apr, May, June, July, Aug, Sep, Oct, Nov, Dec）</p><p>(1)  试按表中元素的顺序依次插入一棵初始为空的二叉排序树，画出插入完成之后的二叉排序树，并求其在等概率的情况下查找成功的平均查找长度。</p><p>(2)  若对表中元素先进行排序构成有序表，求在等概率的情况下对此有序表进行折半查找时查找成功的平均查找长度。</p><p>(3)  按表中元素顺序构造一棵平衡二叉排序树，并求其在等概率的情况下查找成功的平均查找长度。</p></li></ol><p>​      <img src="https://i.loli.net/2020/12/22/omfLEDeZBFpQSXt.png"></p><ol start="4"><li><p>假定对有序表：（3，4，5，7，24，30，42，54,  63，72，87，95）进行折半查找，回答下列问题：</p><p>（1）画出描述折半查找过程的判定树；</p><p>（2）若查找元素54，需依次与哪些元素比较？</p><p>（3）若查找元素90，需依次与哪些元素比较？</p><p>（4）假定每个元素的查找概率相等，求查找成功时的平均查找长度。<img src="https://i.loli.net/2020/12/22/WdItqr4x1oe3ZmC.png"></p></li><li><p>选取散列函数H（key）=（3*key）%11，用线性探测法处理冲突，对下列关键码序列{22，41，53，8，46，30，1，31，66}构造一个哈希地址空间为0～10，表长为11的哈希表，。</p></li></ol><p><img src="https://i.loli.net/2020/12/22/N3PCxDWUGbhAwH4.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap5图复习题</title>
    <link href="/2020/12/22/chap5%E5%9B%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap5%E5%9B%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>在一个图中，所有顶点的度数之和等于图的边数的（ <strong>2</strong> ）倍 <code>握手定理</code></p></li><li><p>在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（ <strong>1</strong> ）倍  <code>握手定理</code></p></li><li><p>有8个结点的无向图最多有（  28 ）条边 <code>无向完全图, 边数最多为 n(n-1) / 2</code></p></li><li><p>有8个结点的无向连通图最少有（  7 ）条边 <code>生成树</code></p></li><li><p>有8个结点的有向完全图有（  56 ）条边<code>有向完全图, 边数最多为 n(n-1)</code></p></li><li><p>用邻接表表示图进行广度优先遍历时，通常是采用（ <strong>队列</strong> ）来实现算法的。</p></li><li><p>用邻接表表示图进行深度优先遍历时，通常是采用（ <strong>栈</strong> ）来实现算法的。           </p></li><li><p>矩阵如下，根据深度优先搜索算法，从顶点0出发的遍历序列是（ 0423165 或0134256 ）</p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492275499282_09A1B17F411ECE39BF54DF820D121458"></p><img src="https://uploadfiles.nowcoder.com/images/20190327/466357877_1553651974781_ACED241801E307EE7A39612F85A94EBF" style="zoom:33%;" /><ol start="9"><li><p>图的邻接矩阵同题8，根据广度优先搜索算法，从顶点0出发的遍历序列是（ 0 1 2 3 4 6 5  ）</p></li><li><p>如果从无向图的任一顶点出发进行一次深度优先遍历就能访问图中所有顶点，则该图一定是（  <strong>连通图</strong>  ）。</p></li><li><p>在一个带权连通图G中，权值最小的边一定包含在G的（ <strong>最小</strong> ）生成树中 <code>最小生成树性质</code></p></li><li><p>用邻接表存储图所用空间的大小（  <strong>与图的顶点数和边数都有关</strong> ）。</p></li><li><p>具有n个顶点的连通无向图，其边的个数至少为（ n-1 ）<code>生成树</code></p></li><li><p>已知图的邻接表如下，根据深度优先搜索算法，从顶点0出发的遍历序列是（  0 1 2 3  ）</p><p><code>深度优先遍历 相当于树的先序遍历, 通常借助栈实现. 先进后出</code></p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492275927189_558B658E00BC3736CC3E5F6683BA1EF4"></p><ol start="15"><li><p>已知图的邻接表如下，根据广度优先搜索算法，从顶点0出发的遍历序列是（ 0 3 2 1 ）   </p><p><code>广度优先遍历，相当于树的层序遍历，通常借助队列(先进先出)实现算法。题中从0出发，即0入队，邻接表访问顺序为3，2，1，则入队顺序也为3，2，1</code></p></li></ol><img src="https://iknow-pic.cdn.bcebos.com/5882b2b7d0a20cf46b8bdc1576094b36adaf99e4" style="zoom: 50%;" /><ol start="16"><li><p><strong>深度</strong>优先遍历类似于二叉树的（  <strong>先序遍历</strong> ）</p></li><li><p><strong>广度</strong>优先遍历类似于二叉树的（  <strong>层次遍历</strong> ）</p></li></ol><h4>二、填空题</h4><ol><li><p>图的存储结构最常用的有 <strong><u>邻接矩阵</u></strong> 、<strong><u>邻接表</u></strong> </p><p>遍历图的方法有： <strong><u>深度优先遍历</u></strong> 、 <strong><u>广度优先遍历</u></strong> 等</p></li><li><p>有向图G用邻接表矩阵存储，其第i行的所有元素之和等于顶点i的  <strong><u>出度</u></strong>  </p></li><li><p>如果n个顶点的图是一个环，则它有  <strong><u>n</u></strong>  棵生成树  </p><p><code>n个顶点形成的环有n条边，若得到生成树只需要删除这n条边中的任意一条即可，所以得到n棵生成树</code></p></li><li><p>n个顶点e条边的图，若采用邻接矩阵存储，则空间复杂度为  <strong><u>O(n^2)</u></strong>  </p><p><code>采用邻接矩阵存储，则不论&lt;Vi，Vj&gt;是否有路径，每条边都会遍历到。矩阵大小n*n，即时间复杂度O(n^2)</code></p></li><li><p>n个顶点e条边的图，若采用邻接表存储，则空间复杂度为  <strong><u>O(n+e)</u></strong> </p><p><code>采用邻接表存储，每个结点访问一次，每条有路径的边访问一次，则时间复杂度O(n+e)</code></p></li><li><p>设有一稀疏图G，则G采用 <strong><u>邻接表</u></strong>  存储较省空间</p></li><li><p>设有一稠密图G，则G采用 <strong><u>邻接矩阵</u></strong>  存储较省空间</p></li><li><p>图的逆邻接表存储结构只适用于 <strong><u>有向图</u></strong></p></li><li><p>图的深度优先遍历序列 <strong><u>不是</u></strong> 唯一的</p></li><li><p>n个顶点e条边的图采用邻接矩阵存储，<strong>深度</strong>优先遍历算法的时间复杂度为 <strong><u>O(n^2)</u></strong> ；</p><p>若采用邻接表存储时，该算法的时间复杂度为  <strong><u>O(n+e)</u></strong> </p></li><li><p>n个顶点e条边的图采用邻接矩阵存储，<strong>广度</strong>优先遍历算法的时间复杂度为  <strong><u>O(n^2)</u></strong>；</p><p>若采用邻接表存储，该算法的时间复杂度为  <strong><u>O(n+e)</u></strong> </p></li><li><p>Prim算法求具有n个顶点e条边的图的最小生成树的时间复杂度为 <strong><u>O(n^2)</u></strong> ；用克鲁斯卡尔(Kruskal)算法的时间复杂度是 <strong><u>O(elog2e)</u></strong> 。</p></li><li><p>若要求一个稀疏图G的最小生成树，最好用 <strong><u>克鲁斯卡尔(Kruskal)</u></strong> 算法来求解。</p></li><li><p>若要求一个稠密图G的最小生成树，最好用 <strong><u>普里姆(Prim)</u></strong>  算法来求解。</p></li><li><p>用Dijkstra算法求某一顶点到其余各顶点间的最短路径是按路径长度  <strong><u>递增</u></strong>  的次序来得到最短路径的</p></li><li><p>求最短路径的Dijkstra算法的时间复杂度是  <strong><u>O(n^2)</u></strong>  </p></li><li><p>拓扑排序算法是通过重复选择具有  <strong><u>0</u></strong>  个前驱顶点的过程来完成的</p></li></ol><h4>三、判断题</h4><ol><li><p>一个图的邻接矩阵表示是唯一的，邻接表表示不<del>是唯一的</del>。 </p><p><code>邻接表每个节点后面连接的节点顺序随意</code></p></li><li><p>有向图用邻接矩阵存储，顶点i的<del>入度</del>等于矩阵中第i行非零元素个数之和。<code>行对应出度</code></p></li><li><p>若一个图的邻接矩阵不是对称矩阵，则该图一定是有向图。</p></li><li><p>一个无向图的邻接矩阵一定是对称矩阵。</p></li><li><p>图的简单路径是指顶点和<del>边</del>都不重复的路径。<code>只有顶点不重复!!</code></p></li><li><p>连通图的生成树是一个极小连通子图。</p></li><li><p>一个连通图的生成树是一个极小连通子图，它含有图中的全部定点，但只有足以构成树的n-1条边，且生成树不唯一。</p></li><li><p>对于非连通的无向图进行深度优先搜索可以得到一个生成森林。</p></li><li><p>BFS生成树的高度不<del>一定小于</del>DFS生成树的高度。</p><p><code>树高的话，可以理解为顶点到结点的距离</code></p><p><code>对于 BFS生成树  每个结点到根结点都是最短距离, 而DFS没有这个限制</code></p><p><code>因此，DFS生成树的树高&gt;= BFS生成树的树高 (一个顶点的图相等)</code></p></li><li><p>拓扑排序可以判断一个有向图是否存在回路。</p><p><code>DFS搜索可以通过测试生成树是否有背边来判断是否有环</code></p><p><code>拓扑排序的，如果有环的话，则没有处理完所有的节点，栈或者队列就已经空了</code></p></li></ol><h4>四、简答题</h4><ol><li><p>表示有50个顶点、15条边的有向图的邻接矩阵有多少个矩阵元素？该矩阵是否是稀疏矩阵？</p><p>50*50=2500 有2500个矩阵元素，15/2500=0.006&lt;0.05 该矩阵是稀疏矩阵</p></li><li><p>有n个顶点的<strong>无向图</strong>最多有几条边，最少有几条边；如果该图是连通图，则该图最多有几条边，最少有几条边？</p><p>无向图最多有n(n-1)/2边，最少有0条边。</p><p>无向连通图最多有n(n-1)/2边，最少有n-1条边。</p></li><li><p>有n个顶点的<strong>有向图</strong>最多有几条边，最少有几条边；如果该图是强连通图，则该图最多有几条边，最少有几条边？</p><p>有向图最多有n(n-1)边，最少有0条边。</p><p>强连通图最多有n(n-1)边，最少有n条边。</p></li><li><p>对下面所示的有向图，请回答：该图是强连通图吗？若不是，请画出其强连通分量。</p><p><img src="https://i.loli.net/2020/12/21/T3sWQukIhPZcdSg.png"></p><p>该图不是强连通图。有6个强连通分量，即各个顶点。</p></li></ol><h4>五、应用题</h4><ol><li>已知如图所示的有向图，请给出该图的:                                                                                                                                               </li></ol><p><img src="https://i.loli.net/2020/12/21/1ojnQyYFRDVuWEi.png"></p><p>（1） 每个顶点的入/出度；</p><p>  ID(1)=3    OD(1)=0 </p><p>  ID(2)=2    OD(2)=2 </p><p>  ID(3)=1    OD(3)=2 </p><p>  ID(4)=1    OD(4)=3 </p><p>  ID(5)=2    OD(5)=1 </p><p>  ID(6)=2    OD(6)=3</p><p>（2）邻接矩阵</p><p>  0  0  0  0  0  0 </p><p>  1  0  0  1  0  0 </p><p>  0  1  0  0  0  1 </p><p>  0  0  1  0  1  1 </p><p>  1  0  0  0  0  0 </p><p>  1  1  0  0  1  0</p><p>（3）  邻接表  <code>出度</code></p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521086932795_A452989AA861993B1F6D4CE6396C8CE2"></p><p>（4）  逆邻接表 <code>入度</code></p><p>​                                           <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521086943162_417CEE45EB97602D1D4FC1429A18A0FD"></p><ol start="2"><li>请对下图的无向带权图：</li></ol><p>（1）  写出它的邻接矩阵，按普里姆算法求其最小生成树；</p><p>（2）  写出它的邻接表，按克鲁斯卡尔算法求其最小生成树。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087479012_6CE28496EAA7968C3C38F82FBC2CD075"></p><p><strong>按普里姆算法求最小生成树：设起点为a，当多条边权值相同时，选择编号最小的顶点 </strong></p><p><strong>按克鲁斯卡尔算法求最小生成树，当多条边权值相同时，选择编号最小的顶点</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087483662_AF8DF9DA070E8B3E1AC54D28C9C14BC9"></p><p>3.已知二维数组表示的图的邻接矩阵如下图所示。试分别画出自顶点1出发进行遍历所得的深度优先生成树和广度优先生成树。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087313183_BED18D4C133F07F79E60B9CD2FF5DBB0"></p><p>​                              <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087320400_CB22EA229F451D9F806696F0C6A7598F"></p><p>4.试利用Dijkstra算法求图中从顶点a到其他各顶点间的最短路径，写出执行算法过程中各步的状态。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521088547962_BDE791E8999B948575588967608A9215"></p><p> <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521088528706_3D342AF356857AE11EDDBD81CBB6EEC5"></p><ol start="5"><li>给定下列网G: </li></ol><p>(1) 试着找出网G的最小生成树，画出其逻辑结构图；</p><p>(2) 用两种不同的表示法画出网G的存储结构图；</p><p>(3) 用C语言（或其他算法语言）定义其中一种表示法（存储结构）的数据类型。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342672256_424F704615EDB69A73B0429C42ACF599"></p><p>1）<br><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342763225_A466F9E5793528FDD92ABCE4DC6DA8DC"><br>（2）邻接矩阵：<br><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342824956_581E2A3C4CEED6F16D58A0F18B7CCEDC"><br>邻接表：<br><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342836488_E39B6FABFA0A76274B20BD223FA85EE8"></p><p>(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFINITY INT_MAX<span class="hljs-comment">//最大值∞</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20<span class="hljs-comment">//假设的最大顶点数(可取为 7)</span></span><br>Typedef <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DG, DN, AG,AN <br>&#125;GraphKind; <span class="hljs-comment">//有向/无向图,有向/无向网 </span><br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">ArcCell</span>&#123;</span>          <span class="hljs-comment">//弧(边)结点的定义</span><br>VRType adj;   <span class="hljs-comment">//顶点间关系,无权图取 1 或 0;  有权图取权值类型</span><br>InfoType *info;  <span class="hljs-comment">//该弧相关信息的指针</span><br>&#125;ArcCell, AdjMatrix [ MAX_VERTEX_NUM ] [MAX_VERTEX_NUM ];<br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>       <span class="hljs-comment">//圈的定义</span><br>VertexType vexs[MAX_VERTEX_NUM];   <span class="hljs-comment">//顶点表，用一维向量即可</span><br>AdiMatrix arcs;    <span class="hljs-comment">//邻接矩阵</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap4树和二叉树复习题</title>
    <link href="/2020/12/22/chap4%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap4%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>不含任何结点的空树（ <strong>是一棵树也是一棵二叉树</strong> ）</p></li><li><p>一棵有n个结点的树的所有结点的度数之和为（  <strong>n-1</strong> ）<code>特值法 取n=1</code></p></li><li><p>在二叉树中某一个结点的深度为3，高度为4，则该树的高度是（ 6 ）</p><p><code>深度和高度是相对于两个相反方向的 高度是从下往上</code></p></li><li><p>设高度为h的二叉树中只有度为0和度为2的结点，则该树的结点数<strong>至多</strong>为（ <strong>2^h-1</strong> ）</p></li><li><p>设高度为h的二叉树中只有度为0和度为2的结点，则该树的结点数<strong>至少</strong>为（ <strong>2h-1</strong> ）</p><img src="https://i.loli.net/2020/12/20/fsDCwEPT64l1xHq.png" style="zoom:33%;" /></li><li><p>高度为h的满二叉树中有n个结点，其中有m个叶结点，则正确的等式是（  <strong>n=2h-1</strong> ）</p><p><code>这种题不要只代一组数 容易出错!!</code></p></li><li><p>二叉树是非线性数据结构，所以（ <strong>顺序存储结构和链式存储结构都能存储</strong>  ）</p></li><li><p>一棵完全二叉树有25个叶结点，则该树最少有（ 49 ）个结点  (前5行满(1,2,4,8,16) 第6行有18个叶子)</p></li><li><p>假设一个三叉树的结点数为36，则该树的最小高度为（ 4 ）<code>满树的情况下</code></p></li><li><p>设二叉树有n个结点，则二叉链表中<strong>非空指针</strong>数为（ <strong>n-1</strong> ）</p><p><code>在有N个结点的二叉链表中必定有2N个链域--左右指针</code></p><p><code>除根结点外，其余N-1个结点都有一个父结点</code></p><p><code>所以，一共有N-1个非空链域，其余2N-（N-1）=N+1个为空链域</code></p></li><li><p>先序序列和中序序列正好相反的二叉树是（ <strong>左单枝树</strong> ）</p></li><li><p>后序序列和中序序列正好相反的二叉树是（ <strong>右单枝树</strong> ）</p></li><li><p>把一棵树转换为二叉树后，这棵二叉树的形态是（ <strong>唯一的</strong> ）</p></li><li><p>将一棵树T转换为孩子—兄弟链表表示的二叉树H，则T的后根序遍历是H 的（ <strong>中序遍历</strong> ）</p><img src="https://i.loli.net/2020/12/22/uAFwzMGoRD1kQ5W.png" style="zoom:67%;" /><p><code>树转化为二叉树 先序遍历对应二叉树的先序遍历 后序遍历对应二叉树的中序遍历</code></p></li></ol><h4>二、填空题</h4><ol><li><p>在一棵有n个结点的二叉树中，若度为2的结点数为n2，度为1的结点数为n1，度为0的结点数为n0，则该树可能出现的最大高度是 <strong><u>n</u></strong> ，其叶结点数为 <strong><u>1</u></strong>  ，而该树可能出现的最小高度是 <img src="https://i.loli.net/2020/12/20/l5t317YzxavjkAw.png"> ，其叶结点数为 <strong><u>n2+1</u></strong>  。</p><p><code>最大高度 单枝树    最小高度 满二叉树</code></p></li><li><p>一棵完全二叉树有12个叶结点，则该树最多有  <u>24</u>  个结点。</p><p><code>计算：n0=1 叶子结点是双分支节点数加1 n2=n0-1=11 单分支节点数为1或者0，最多则选择1 n=n0+n2+1=12+11+1=24</code></p></li><li><p>已知二叉树的先序序列为ABDCEF，中序序列为DBAECF，则该树的后序序列为<u>DBEFCA</u></p></li></ol><img src="https://i.loli.net/2020/12/20/UoHlrTGZ4stphwd.jpg" style="zoom: 12%;" /><ol start="4"><li><p>二叉树的层次遍历需要使用  <strong><u>队列</u></strong>  辅助才能实现。 </p></li><li><p>设二叉树有n个结点，则二叉链表中<strong>空指针</strong>数为 <strong><u>n+1</u></strong></p></li><li><p>由3个结点所构成的二叉树有  <u>5</u>种形态</p><p><code>h(n)=C(2n,n)/(n+1) (n=1,2,3,...)</code></p></li><li><p>一棵深度为6的满二叉树有 <u> 31</u>  个分支结点和 <u>32</u> 个叶子。</p><p><code>满二叉树没有度为1的结点，分支结点数就是度为2的结点数 即1+2+4+8+16</code> </p></li><li><p>一棵具有257个结点的完全二叉树，它的深度为  <u>9</u>  </p><p><code>含有n个结点的完全二叉树的深度为 log2(n +1) </code></p></li><li><p>设一棵完全二叉树有700个结点，则共有  <u>350</u> 个叶子结点。</p><p><code>完全二叉树n=n0+n2+1 n2=n0-1</code></p></li><li><p>设一棵完全二叉树具有1000个结点，则此完全二叉树有 <u>500</u> 个叶子结点，有 <u>499</u>  个度为2的结点，有  <u>1</u>  个结点只有非空左子树，有 <u>0</u> 个结点只有非空右子树。</p></li><li><p>一棵有n(n&gt;1)个结点的k叉树，可能的最大深度为 <strong><u>n</u></strong> ，可能的最小深度为  <strong><u>2</u></strong>  。</p></li></ol><h4>三、判断题</h4><ol><li><p>满二叉树是完全二叉树</p></li><li><p>二叉树的先序序列和中序序列可以唯一确定此二叉树</p></li><li><p>Huffman树中包括度为0、度为1和<del>度为2</del>的结点 (只有01结点)</p></li><li><p>若二叉树用二叉链表存储，则n个结点的二叉链表中有n-1个非空指针域</p></li><li><p>二叉树中每个结点的两棵子树的高度差不一定<del>等于1</del></p></li><li><p>二叉树中每个结点的两棵子树是有序的 </p></li><li><p>二叉树中每个结点不一定<del>有两棵非空子树或有两棵空子树</del></p></li><li><p>二叉树中所有结点个数是<del>2^(k-1)-1</del>，其中k是树的深度<img src="https://i.loli.net/2020/12/20/ltiqNUTsKXZDkHg.png"></p></li><li><p>二叉树中所有结点，如果不存在非空左子树，<del>则不存在非空右子树</del><img src="https://i.loli.net/2020/12/20/jmMHcivwAZJxCE3.png"></p></li><li><p>对于一棵非空二叉树，根结点为第1层，则第i层上最多能有<del>2^i -1个结点</del>  应该是2^(i-1)个</p></li><li><p>用二叉链表法（link-rlink）存储包含n个结点的二叉树，结点的2n个指针区域中有n+1个为空指针</p></li><li><p>具有12个结点的完全二叉树有5个度为2的结点</p></li></ol><h4>四、应用题</h4><ol><li><p>在一棵度为4的树中，有20个度为4的结点， 10个度为3的结点， 1个度为2的结点，10个度为1的结点，请计算树中度为0的结点个数。</p><p><strong>任何一棵树中，结点个数比分支个数多一</strong> </p><p>分支个数等于20*4+10 *3+1 *2+10 *1=122 </p><p>所以这棵树一共有123个结点 </p><p>度不为零的结点数目为20+10+1+10=41 </p><p>所以叶子结点也就是度为零的结点个数为123-41=82</p></li><li><p>一棵二叉树有1024个结点，其中有叶子结点465个，计算树中度为2和度为1的结点各有多少个</p><p>因n0=n2+1，所以n2=465-1=464，n1=1024-465-464=95</p></li><li><p>请画出一棵先序序列和中序序列相同的二叉树（注：空树和只有根结点的树除外）</p><p><u>右单枝树</u>的先序序列与中序序列相同</p></li><li><p>已知二叉树的层次遍历序列为ABCDEFG，中序序列为DBFEGAC，请画出该树。</p><p><img src="https://i.loli.net/2020/12/21/1TEGVRBZctfWuIX.gif"></p></li><li><p>给定如图所示二叉树T，请画出与其对应的中序线索二叉树。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170415/5437584_1492271590744_CCC6F71D85A05E24BA5EA3BDC35B34BF"></p><p>要遵循中序遍历的轨迹来画出每个前驱和后继。</p><p>中序遍历序列：55 40 25 60 28 08 33 54</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">线索二叉树就是对这个序列中每个数判断其有没有左右子树<br>没有左子树就加前驱<span class="hljs-punctuation">,</span> 没有右子树就加后继 <br>序列中首元素左子树指空 序列中尾元素右子树指空<br>感谢<span class="hljs-keyword">c</span>佬的指导qaq<br></code></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/images/20170415/5437584_1492271737042_CFC9E40405E371BC3173FCF74DB8B357"></p></li><li><p>试写出如图所示的二叉树分别按先序、中序、后序遍历时得到的结点序列。</p><img src="https://i.loli.net/2020/12/21/D2ELYVFybfKS4wk.png" style="zoom:67%;" /><p>​    DLR：A B D F J G K C E H I L M</p><p>​    LDR:  B F J D G K A C H E L I M</p><p>​    LRD：J F K G D B H L M I E C A</p></li><li><p>把如图所示的树转化成二叉树。</p></li></ol><p><img src="https://i.loli.net/2020/12/21/WwD49Aid6gjaYLv.png"></p><p>​                                             <img src="https://i.loli.net/2020/12/21/4SsVBxGmIFnzC3H.png"></p><p>​        </p>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap3栈和队列复习题</title>
    <link href="/2020/12/22/chap3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>栈中元素的进出原则是(  <strong>后进先出</strong> )</p></li><li><p>已知一个栈的进栈序列为1, 2, …, n，其输出序列是p1, p2, … , pn ，若p1=n，则pi=（ <strong>n-i+1</strong> ）</p></li><li><p>一个栈的输入序列为：a b c d e，则下列不可能是栈的输出序列的是（ <strong>e d a c b</strong> ）</p><p><strong>规律：某数a右侧比a小的数构成的子列必须严格降序</strong></p></li><li><p>判定一个栈ST（ 最多元素为m0 ）为空的条件是( <strong>ST-&gt;top=0 </strong>)</p></li><li><p>判定一个队列QU（最多元素为m0）为满队列的条件是( <strong>QU-&gt;rear-QU-&gt;front == m0</strong> )</p></li><li><p>数组Q[n]用来表示一个循环队列，f为当前队列头元素的前一位置，r为队尾元素的位置，假定队列中元素的个数小于n，计算队列中元素的公式为( <strong>（n＋r－f）% n </strong>)</p></li><li><p>栈和队列的共同点是（ <strong>只允许在端点处插入和删除元素</strong> ）。</p></li><li><p>用单链表表示的链式队列的队头在链表的（  <strong>表头</strong>  ）位置。</p></li><li><p>设计一个判别表达式中左，右括号是否配对出现的算法，采用（ <strong>栈</strong> ）结构最佳。</p></li><li><p>用不带头结点的单链表存储队列时,其队头指针指向队头结点,其队尾指针指向队尾结点，则在进行删除操作时( <strong>队头,队尾指针都可能要修改</strong> )。 </p></li><li><p>设循环队列Q的最大长度为m，rear为尾指针，则入队时的操作为（ <strong>Q.rear=(Q.rear+1) % m</strong> ）。</p></li></ol><h4>二、填空题</h4><ol><li><p>栈和队列都是 <strong><u>线性</u></strong>  结构，对于栈只能在 <strong><u>栈顶</u></strong> 插入和删除元素；对于队列只能在 <strong><u>队尾</u></strong> 插入和 <strong><u>队首</u></strong> 删除元素。</p></li><li><p>栈是一种特殊的线性表，允许插入和删除运算的一端称为 <strong><u>栈顶</u></strong>。不允许插入和删除运算的一端称为 <strong><u>栈底</u></strong> 。</p></li><li><p>在具有n个单元的循环队列中，队满时共有<strong><u>n-1</u></strong>个元素。</p></li><li><p>向栈中插入元素的操作是先<strong><u>存入元素</u></strong>，后<strong><u>移动栈顶指针</u></strong>。</p></li><li><p>带表头结点的空循环链表的长度等于 <strong><u>0</u></strong>。</p></li><li><p>设循环队列Q[maxsize]的队头指针为front，队尾指针为rear，则该队列的队满条件是  <strong><u>Q.front==(Q.rear+1)%maxsize</u></strong>  。</p></li></ol><h4>三、判断题</h4><ol><li><p>栈和队列是操作受限的线性表。</p></li><li><p>线性表的每个结点不是<del>只能是简单类型</del>，而链表的每个结点可以是复杂类型。因为线性表是逻辑结构概念，可以顺序存储或链式储，与元素数据类型无关。</p></li><li><p>在表结构中最常用的是线性表，栈和队列不是<del>不太常用</del>。</p></li><li><p>栈对所有插入、删除操作仅限于在表的一端进行，是一种后进先出型结构。</p></li><li><p>对于不同的使用者，一个表结构既可以是栈，也可以是队列，也可以是线性表。</p></li><li><p>栈和链表不一定<del>是两种不同的数据结构</del>。</p></li><li><p>栈和队列不<del>是一种非线性数据结构</del>。</p><p>常见的线性表：栈，队列，一维数组，串，双队列</p><p>非线性：图，树，二维数组，**数组，广义表</p></li><li><p>栈和队列的存储方式既可是顺序方式，也可是链接方式。             </p></li><li><p>队列的插入与删除操作分别在表的两端进行，不是一种<del>先进后出</del>型结构，是先进先出。</p></li><li><p>一个栈的输入序列是12345，则栈的输出序列不是<del>不可能是12345</del>。</p></li><li><p>两个栈共享一片连续内存空间时，为提高内存利用率，减少溢出机会，<strong>应把两个栈的栈底分别设在这片内存空间的两端。</strong></p></li></ol><h4>五、算法阅读题</h4><ol><li><p>写出下列程序段的输出结果（栈的元素类型SElem Type为char）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123; <br><br>    Stack S;  Char x,y;<br><br>    InitStack(S);<br><br>    X=’c’; y=’k’;<br><br>    Push(S,x);  Push(S,’a’);  Push(S,y);  Pop(S,x);   <br><br>    Push(S,’t’);  Push(S,x);  Pop(S,x);   Push(S,’s’);<br><br>    <span class="hljs-keyword">while</span>(!StackEmpty(S))<br><br>    &#123;  Pop(S,y);  <span class="hljs-built_in">printf</span>(y);  &#125;<br><br>    <span class="hljs-built_in">printf</span>(x);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>解: </p><p>Push(S,x)后栈内为 c，Push(S, ‘a’)；Push(S,y)后栈内为cak; Pop(S,x)后出栈k, 此时x=k，栈内为 ca; </p><p>Push(S, ‘t’)后栈内为 cat; Push(S,x)后栈内为catk; Pop(S,x)后出栈k,此时x=k,栈内为cat; Push(S, ‘s’)后，栈内为cats; Pop(S,y) printf(y)循环打印栈内元素stac , printf(x)打印出k ，故结果为stack</p></li><li><p>写出下列程序段的输出结果（队列中的元素类型QElem Type为char）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123; <br>    Queue Q; <br><br>    <span class="hljs-function">Init <span class="hljs-title">Queue</span> <span class="hljs-params">(Q)</span></span>;<br><br>    Char  x=’e’;  y=’c’;<br><br>    EnQueue (Q,’h’);  EnQueue (Q,’r’);  <br><br>    EnQueue (Q, y);  DeQueue (Q,x);   <br><br>    EnQueue (Q,x);   DeQueue (Q,x);   <br><br>    EnQueue (Q,’a’); <br><br>    <span class="hljs-keyword">while</span>(!QueueEmpty(Q))<br><br>    &#123;  DeQueue (Q,y);  <span class="hljs-built_in">printf</span>(y);  &#125;<br><br>    <span class="hljs-built_in">printf</span>(x);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>答：输出为“char”。</p></li><li><p>简述以下算法的功能（栈和队列的元素类型均为int）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">alg</span><span class="hljs-params">(Queue &amp;Q)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123; <br>    Stack S;  <span class="hljs-keyword">int</span> d;<br><br>    InitStack(S);<br><br>    <span class="hljs-keyword">while</span>(!QueueEmpty(Q))<br><br>    &#123;  DeQueue (Q,d); Push(S,d);  &#125;;<br><br>    <span class="hljs-keyword">while</span>(!StackEmpty(S))<br><br>    &#123;  Pop(S,d);   EnQueue (Q,d);  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>答：该算法的功能是：利用堆栈做辅助，将队列中的数据元素进行逆置。</p></li></ol><h4>五、简答题</h4><ol><li><p>说明线性表、栈与队的异同点。</p><p>相同点：</p><p>都是线性结构，都是逻辑结构的概念。</p><p>都可以用顺序存储或链表存储；</p><p>栈和队列是两种特殊的线性表，即受限的线性表，只是对插入、删除运算加以限制。</p><p>不同点：</p><p>①运算规则不同，线性表为随机存取，而栈是只允许在一端进行插入、删除运算，因而是后进先出表LIFO；队列是只允许在一端进行插入、另一端进行删除运算，因而是先进先出表FIFO。</p><p>② 用途不同，堆栈用于子程调用和保护现场，队列用于多道作业处理、指令寄存及其他运算等等。</p></li><li><p>设有编号为1，2，3，4的四辆列车，顺序进入一个栈式结构的车站，具体写出这四辆列车开出车站的所有可能的顺序。</p><p>答：至少有14种。</p><p>① 全进之后再出情况，只有1种：4，3，2，1</p><p>② 进3个之后再出的情况，有3种，3,4,2,1 3,2,4,1 3,2,1,4</p><p>③ 进2个之后再出的情况，有5种，2,4,3,1  2,3,4,1  2,1, 3,4 2,1,4,3 2,1,3,4</p><p>④ 进1个之后再出的情况，有5种，1,4,3,2 1,3,2,4 1,3,4,2 1, 2,3,4 1,2,4,3</p></li><li><p>假设正读和反读都相同的字符序列为“回文”，例如，‘abba’和‘abcba’是回文，‘abcde’ 和‘ababab’则不是回文。假设一字符序列已存入计算机，请分析用线性表、堆栈和队列等方式正确输出其回文的可能性？</p><p>线性表是随机存储，可以实现，靠循环变量从表尾开始打印输出；</p><p>堆栈是后进先出，也可以实现，靠正序入栈、逆序出栈即可；</p><p>队列是先进先出，不易实现。</p><p>哪种方式最好，要具体情况具体分析。</p><p>若正文在机内已是顺序存储，则直接用线性表从后往前读取即可，或将堆栈栈顶设置到数组末尾，然后直接用POP动作实现。</p><p>若正文是单链表形式存储，则等同于队列，需开辅助空间，可以从链首开始入栈，全部入栈后再依次输出。</p></li><li><p>顺序队列的“假溢出”是怎样产生的？如何知道循环队列是空还是满？</p><p>一般的一维数组队列的<u>尾指针已经到了数组的上界</u>，不能再有入队操作，但<u>其实数组中还有空位置</u>，这就叫<u>“假溢出”</u>。</p><p>采用<u>循环队列</u>是解决假溢出的途径。</p><p>另外，解决队满、队空的办法有三：</p><p>①  设置一个布尔变量以区别队满还是队空；</p><p>②  浪费一个元素的空间，用于区别队满还是队空。</p><p>③  使用一个计数器记录队列中元素个数（即队列长度）。</p><p>我们常采用法②，即队头指针、队尾指针中有一个指向实元素，而另一个指向空闲元素。</p><p>判断循环队列队空标志是： f=rear   队满标志是：f=(r+1)%N</p></li><li><p>设循环队列的容量为40（序号从0到39），现经过一系列的入队和出队运算后，有  ① front=11，rear=19;  ② front=19，rear=11；问在这两种情况下，循环队列中各有元素多少个？</p><p>答：用队列长度计算公式： (N＋r－f)% N</p><p>① L=（40＋19－11）% 40=8        </p><p>② L=（40＋11－19）% 40=32</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap2线性结构复习题</title>
    <link href="/2020/12/22/chap2%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap2%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>顺序存储结构的优点是（<strong>存储密度大</strong>）</p></li><li><p>下面关于线性表的叙述中，<u>错误</u>的是（线性表采用顺序存储，便于进行插入和删除操作）</p></li><li><p>线性表是具有n个（<strong>数据元素</strong>）的有限序列（n&gt;0）。</p></li><li><p>若某线性表最常用的操作是存取任一<u>指定序号</u>的元素和在线性表的最后进行插入和删除元素，则利用（<strong>顺序表</strong>）存储方式最节省时间。</p></li><li><p>某线性表中最常用的操作是在<u>最后一个元素之后插入</u>一个元素和<u>删除第一个元素</u>，则采用（<strong>仅有尾指针的单循环链表</strong>）存储方式最节省运算时间。</p></li><li><p>对于一个头指针为head的带头结点的单链表，判定该链表为空表的条件是（<strong>head→next==NULL</strong>）。</p></li><li><p>链表<u>不具有</u>的特点是（可随机访问任一元素） </p></li><li><p>下面的叙述正确的是（<strong>线性表在链式存储时，查找第i个元素的时间同i的值成正比</strong>）</p></li><li><p>对于顺序存储的线性表，访问结点和增加、删除结点的时间复杂度分别为（<strong>O(1)，O(n)</strong>）。</p></li><li><p>非空的循环单链表head的指向尾结点的指针变量p满足（<strong>p-&gt;link=head</strong>）。</p></li><li><p>若长度为n的线性表采用顺序存储结构，在第i个位置插入一个元素的算法的时间复杂度为（<strong>O(n)</strong>）(1&lt;=i&lt;=n+1)。</p></li><li><p>在单链表指针为p的结点之后插入指针为s的结点，正确的操作是（<strong>s-&gt;next=p-&gt;next;  p-&gt;next=s;</strong>）。</p></li><li><p>利用双向链表作线性表的存储结构的优点是（<strong>提高按关系查找数据元素的速度</strong>）。</p></li><li><p>若长度为n的非空顺序表，在表的第i个位置插入一个新元素，i的合法值是（<strong>1≤i≤n+1</strong>）。</p></li><li><p>已知L是带头结点的单链表，则删除首元结点的语句是（<strong>L-&gt;next=L-&gt;next-&gt;next;</strong>）。</p></li><li><p>已知单链表A的长度为m，单链表B的长度为n，若将B链接在A的末尾，在没有尾指针的情况下，算法的时间复杂度为（<strong>O(m)</strong>）。</p></li><li><p>设一个链表最常用的操作是在<u>末尾插入结点和删除尾结点</u>，则选用(<strong>带头结点的双循环链表</strong>)最节省时间。</p></li></ol><h4>二、填空题</h4><ol><li><p>在一个长度为n的顺序表中第i个元素（1≤i≤n）之前插入一个元素时，需向后移动 <strong><u>n-i+1</u></strong>个元素。</p></li><li><p>当线性表的元素<code>总数基本稳定</code>，且<code>很少进行插入和删除操作</code>，但要求以最快的速度存取线性表中的元素时，应采用 <strong><u>顺序</u></strong> 存储结构。</p></li><li><p>对于一个有n个结点的单链表，在给定值为x的结点后插入一个新结点的时间复杂度为 <strong><u>O(n)</u></strong>。</p></li><li><p>根据链式存储结构中每一个结点包含的指针个数，可以将线性链表分成<strong><u>单链表</u></strong>和多重链表。</p></li><li><p>链接存储的特点是利用<strong><u>指针</u></strong>来表示数据元素之间的逻辑关系。</p></li><li><p>顺序存储结构是通过<strong><u>物理位置相邻</u></strong>表示元素之间的关系的;链式存储结构是通过<strong><u>指针</u></strong>表示元素之间的关系的。</p></li><li><p>循环单链表的最大优点是：<strong><u>从任一结点出发都可访问到链表中每一个元素</u></strong>。</p></li><li><p>带头结点的单循环链表L，L为空表的条件是：<strong><u>L-&gt;next==L</u></strong>。</p></li></ol><h4>三、判断题</h4><ol><li><p>对任何数据结构链式存储结构不是<del>一定优于顺序存储结构</del>。(   )</p></li><li><p>线性表采用链表存储时，结点和结点内部的存储空间不是<del>可以是不连续的</del>。(   )</p></li><li><p>顺序存储方式插入和删除时效率太低，因此它不是<del>不如链式存储方式好</del>。(   )</p></li><li><p>所谓静态链表不是<del>一直不发生变化的链表</del>。类似于数组方法实现的，是顺序的存储结构(   )</p></li><li><p>线性表的特点是不是<del>每个元素都有一个前驱和一个后继</del>。(   )</p></li><li><p>取线性表的第i个元素的时间不一定<del>同i的大小有关</del>。这要分是顺序存储结构还是链式存储结构 (   )</p></li><li><p>线性表不是<del>只能用顺序存储结构实现</del>。(   )</p></li><li><p>顺序存储结构的主要缺点是不利于插入或删除操作。</p></li></ol><h4>四、简答题</h4><ol><li><p>对于线性表中的插入操作，分别写出在顺序存储结构下和链式存储结构下的时间复杂度。</p><p>顺序O(n)  链式O(1)</p></li><li><p>线性结构的特点是什么？</p><p>1．集合中必存在唯一的一个”第一个元素”；</p><p>2．集合中必存在唯一的一个”最后的元素”；</p><p>3．除最后元素之外，其它数据元素均有唯一的”后继”；</p><p>4．除第一元素之外，其它数据元素均有唯一的”前驱”。</p><p>数据元素之间存在着“一对一”的线性关系</p></li><li><p>说明在线性表的链式存储结构中，头指针与头结点之间的根本区别；头结点与首元结点的关系。</p><p><strong>头指针</strong>是指向链表第一个节点的指针。若链表设有头结点，则头指针指向头结点；若链表没有设头结点，则头指针指向首元结点。</p><p><strong>头结点</strong>是在首元结点之前附设的一个节点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可以储存与数据类型相同的其他附加信息。</p><p><strong>首元结点</strong>是指链表中存储第一个数据元素的节点。</p><p><img src="https://i.loli.net/2020/12/22/hFU6fEterVsAIPd.png"></p></li><li><p>在单链表和双向链表中，能否从当前结点出发访问到任何一个结点?</p><p>在单链表中不能从当前结点（若当前结点不是第一结点）出发访问到任何一个结点，<u>链表只能从头指针开始，访问到链表中每个结点</u>。在<u>双链表中</u>求前驱和后继都容易，从<u>当前结点</u>向前到第一结点，向后到最后结点，<u>可以访问到任何一个结点</u>。</p></li><li><p>顺序表在插入或删除元素时一般需要移动元素，如果想不移动多个元素就实现插入和删除，应该如何处理？</p><p>设顺序表长度为n </p><p>插入元素时，直接将新元素插在第n+1个位置</p><p>删除第i个元素时，将第n个元素补到第i个位置</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap1绪论复习题</title>
    <link href="/2020/12/22/chap1%E7%BB%AA%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap1%E7%BB%AA%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>从逻辑结构上可以把数据结构分为 (<strong>线性结构和非线性结构</strong>)。</p></li><li><p>顺序存储表示中数据元素之间的逻辑关系是由（<strong>存储位置</strong>）表示的。</p></li><li><p>链式存储表示中数据元素之间的逻辑关系是由（<strong>指针</strong>）表示的。</p></li><li><p>若某算法的时间复杂度是O(n2 ) ，表明该算法（<strong>执行时间与n2成正比</strong>）。</p></li><li><p>算法的时间复杂度与（<strong>问题规模</strong>）有关。</p></li><li><p>算法必须具备（<strong>可行性，确定性，有穷性</strong>）这3个特性</p></li><li><p>下面程序段的时间复杂度为（<strong>O(m×n)</strong>）。</p><p>for( i=0; i&lt;m; i++)</p><p>  for(j=0; j&lt;n; j++)</p><p>​    a[i][j]=i*j;</p></li><li><p>以下程序段中，S语句的执行次数是（<strong>n(n+1)/2</strong>）  </p><p>for( i=1; i&lt;=n; i++)</p><p> for(j=i; j&lt;=n; j++) </p><p>   S；</p></li></ol><h4>二、填空题</h4><ol><li><p>数据元素之间的4种基本结构是：<strong><u>集合</u>、<u>线性结构</u> 、 <u>树形结构</u> 、<u>图状结构</u></strong>。</p></li><li><p>线性结构中元素的关系是<strong> <u>一对一</u></strong>，树形结构中元素的关系是<strong> <u>一对多</u></strong>，图形结构中元素的关系是<strong> <u>多对多</u></strong>。</p></li><li><p>顺序存储结构中数据元素的存储位置与其<strong><u>逻辑顺序</u></strong>是对应的。</p></li><li><p>算法效率的度量方法有：<strong><u>事后统计方法</u></strong>和<strong><u>事前分析估算方法</u></strong>。</p></li><li><p>一个好算法应达到的目标有：<strong><u>正确性</u></strong> 、 <strong><u>可读性</u></strong>、 <strong><u>健壮性</u></strong> 、 <strong><u>执行时间短</u></strong> 、 <strong><u>存储量低</u></strong> 。</p></li><li><p>抽象数据类型可细分为3种：<strong><u>原子类型</u> </strong>、 <strong><u>固定聚合类型</u></strong> 和 <strong><u>可变聚合类型</u></strong> 。</p></li><li><p>抽象数据类型的定义一般包括3方面：<strong><u>数据对象的定义</u></strong> 、 <strong><u>数据关系的定义</u></strong> 、<strong><u>基本操作的定义</u></strong>。</p></li></ol><h4>三、判断题</h4><ol><li><p>数据结构主要研究非数值型数据。</p></li><li><p>数据的逻辑结构相同则对应的存储结构<u>不一定</u>也相同。</p></li><li><p>数据的逻辑结构独立于其存储结构。</p></li><li><p><u>数据项</u>是数据的<u>最小单位</u>    <u>数据元素</u>是<u>基本单位</u></p></li><li><p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称。</p></li><li><p>数据的逻辑结构与数据元素本身的内容和形式无关。</p></li><li><p>数据的逻辑结构不是<del>指数据的各数据项之间的逻辑关系</del>, 逻辑结构是元素间关系，而不是元素内容间关系 </p></li><li><p>抽象数据类型不<del>只是一个数学模型</del>, 它是指一个数学模型以及定义在此数学模型上的一组操作。</p></li><li><p>算法和程序不是<del>原则上没有区别</del>，程序不等于算法。但是，通过程序设计可以在计算机上实现算法。</p></li><li><p>数据结构是数据元素的集合和该集合中各数据元素之间关系的集合。</p></li><li><p>顺序存储方式不是<del>只能用于线性结构</del>，比如存储树状结构。还有图的邻接矩阵也是顺序存储</p></li></ol><h4>四、简答题</h4><ol><li><p>什么是数据结构，写出数据结构的形式定义。</p><p>数据结构是指同一数据元素类中各数据元素之间存在的关系。</p></li><li><p>什么是算法，算法的5个特性是什么？</p><p>算法是解决特定问题求解步骤的描述  </p><p>五个基本特性：输入、输出、有穷性、确定性和可行性。</p></li><li><p>数据的逻辑结构分为线性结构和非线性结构,这两类结构各自的特点是什么?</p><p>数据元素之间存在着“一对一”的线性关系</p><p>一个结点元素可能对应多个直接前驱和多个后继。</p></li></ol><h4>五、应用题</h4><p><img src="https://i.loli.net/2020/12/15/hqumrIwPZGdkJTs.png"></p><ol start="2"><li>写出以下各函数的功能，并求出其时间复杂度。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;   <br>    <span class="hljs-keyword">int</span>  i, x;<br>i=<span class="hljs-number">2</span>;<br>x=(<span class="hljs-keyword">int</span> )<span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-keyword">while</span>(i&lt;=x)&#123;  <br>        <span class="hljs-keyword">if</span> (n%i==<span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<br>   i++;<br>&#125;<br><span class="hljs-keyword">if</span> ( i&gt;x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//功能是判断n是否为素数 ，时间复杂度为O(√n ) </span><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;  <br>     <span class="hljs-keyword">int</span> i, p=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;   <br>          p=p*i;<br>           sum=sum+p;<br>       &#125;<br>      <span class="hljs-keyword">return</span>(sum);<br>   &#125;<br><span class="hljs-comment">//功能是计算1!+2!+…+n! ，时间复杂度为O(n ) </span><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;  <br>     <span class="hljs-keyword">int</span> i, j, p, sum=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>          p=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=i; j++) <br>            p=p*j;<br>         sum=sum+p;<br>      &#125;<br><span class="hljs-keyword">return</span>(sum);<br>   &#125;<br><span class="hljs-comment">//功能是计算1!+2!+…+n! ，时间复杂度为O(n2 ) </span><br></code></pre></td></tr></table></figure><h4>六 、算法题</h4><ol><li><p>编写算法计算1!+2!+…+n!，并使算法的时间复杂度为O(n)。</p><p>算法思想：用循环实现阶乘的累加求和，注意在求n!时，使用前一次循环中已经求出的(n-1)!的结果。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; <br>    <span class="hljs-keyword">int</span> i; <br><span class="hljs-keyword">double</span> p=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123; <br>        p=p*i;  <br>sum=sum+p;  <br>&#125;<br>  <span class="hljs-keyword">return</span>(sum);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>编写算法计算2i (i=0,1,2,…,n)，并将计算结果存入数组a中，设计算机中允许的最大整数值为MAXINT，则当2k &gt;MAXINT（0≤k≤n）时，应进行出错处理。</p><p>算法思想：先判断n的取值是否合法，若非法则直接退出程序，若n合法则继续计算2i，在计算2i时，需要判断2i的值是否大于MAXINT/2，这个条件其实就是判断2i+1的值是否大于MAXINT</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arrsize 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXINT  65535</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[ ], <span class="hljs-keyword">int</span> n)</span></span>&#123;   <br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span> || n&gt;arrsize) &#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n  error!\n&quot;</span>);  <br>   <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <br>&#125;<br>   a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0]=%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);<br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;  <br>       a[i]=a[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d]=%d\n&quot;</span>, i, a[i]);<br>       <span class="hljs-keyword">if</span>( a[i]&gt;MAXINT/<span class="hljs-number">2</span> )&#123; <br>           <span class="hljs-built_in">printf</span>(“i=%d, ERROR!\n”, i+<span class="hljs-number">1</span>)；  <br>   <span class="hljs-keyword">break</span>;  <br>&#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_排序</title>
    <link href="/2020/12/22/10-%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/12/22/10-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/22/ilKYdFc6OtjhHvI.png"></p><p><img src="https://pic1.zhimg.com/v2-f50f588e8c546bb649b78f8ccc20689c_r.jpg?source=1940ef5c"></p><p><img src="https://i.loli.net/2020/12/23/7EdGfMhowDbyNqv.jpg"></p><h4>插入排序</h4><ul><li><p>直接插入排序 <code>就是选择第一个元素之后，在从后面选择小的，往前插</code></p><p><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp"></p></li><li><p>折半插入排序</p></li><li><p>表插入排序</p></li><li><p>希尔排序</p><p><img src="https://pic4.zhimg.com/50/v2-26d982ad88862f930b1b7e67ad87b37f_hd.webp?source=1940ef5c"></p><p><code>将初始序列分成几个序列，然后将差分的序列排好</code></p></li></ul><h4>冒泡排序</h4><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp"></p><p><code>每两个挨着比，每趟最大的沉底</code></p><h4>快速排序</h4><p><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp"></p><p>用第一个数字，依次和后面的每个比较，然后拆分成2部分，一部分小于等于，一部分大于，依次类推即可</p><p><code>通过一趟排序把待排序序列分成两部分，一部分比关键字（枢轴）大，一部分比关键字小，重复以上过程，直到排序完成</code></p><p>一趟快速排序的算法是：  </p><p>   1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；  </p><p>   2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；  </p><p>   3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；  </p><p>   4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；  </p><p>   5）重复第3、4步，直到i=j；     (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i，     j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p><h4>选择排序</h4><p><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp"></p><p>每次选择最小的和未排序的第一个元素交换</p><h4>堆排序</h4><p>最小堆：任一结点的值都不大于它的两个孩子的值 </p><p>最大堆：任一结点的值都不小于它的两个孩子的值</p><p>画出二叉树，然后调整为堆即可</p><h4>归并排序</h4><p><img src="https://pic3.zhimg.com/80/v2-145011b5968388bd76e3b91853b136f6_720w.jpg"></p><p>二二合并排序</p><h4>基数排序</h4>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9_查找</title>
    <link href="/2020/12/22/9-%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/12/22/9-%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3>    查找</h3><h4>基本概念</h4><p>查找表: 是由同一类型的<u>数据元素</u>构成的集合</p><p>查找(Searching）就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素</p><p>静态查找表(StaticS Search Table): 只做查找操作的查找表</p><p>动态查找表(Dynamic Search Table): 在查找过程中，向表中插入不存在的数据元素，或者从表中删除某个数据元素</p><p>通常用“数据元素的键值与给定值的比较次数”作为衡量查找算法好坏的依据，称上述比较次数为<code>查找长度</code></p><p><strong>查找成功时的平均查找长度(ASL): </strong>需和指定key进行比较的关键字的个数的期望值</p><table><thead><tr><th>查找</th><th>平均时间复杂度</th><th>查找条件</th><th>算法描述</th></tr></thead><tbody><tr><td>顺序查找</td><td>O(n)</td><td>无序或有序队列</td><td>按顺序比较每个元素，直到找到关键字为止</td></tr><tr><td>二分查找（折半查找）</td><td>O(logn)</td><td>有序数组</td><td>查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。</td></tr><tr><td>二叉排序树查找</td><td>O(logn)</td><td>二叉排序树</td><td>在二叉查找树b中查找x的过程为： 1. 若b是空树，则搜索失败 2. 若x等于b的根节点的数据域之值，则查找成功； 3. 若x小于b的根节点的数据域之值，则搜索左子树 4. 查找右子树。</td></tr><tr><td>哈希表法（散列表）</td><td>O(1)</td><td>先创建哈希表（散列表）</td><td>根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。</td></tr><tr><td>分块查找</td><td>O(logn)</td><td>无序或有序队列</td><td>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。</td></tr></tbody></table><h4>顺序表查找</h4><p>适合于存储结构为<u>顺序存储</u>或<u>链接存储</u>的线性表。</p><p>查找成功 ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</p><p>等概率情况下 </p><p><img src="https://i.loli.net/2020/12/31/MlIxQuPSGT2V9bz.png"></p><p>时间复杂度 O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//每次循环都要对i是否越界超过n做判断</span><br>           <span class="hljs-keyword">if</span>(a[i]==key)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,i);<br>               <span class="hljs-keyword">return</span> i;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回0表示查找失败</span><br>   &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">//改进法 设置哨兵</span><br>       <span class="hljs-keyword">int</span> i<br>       a[<span class="hljs-number">0</span>]=key;<span class="hljs-comment">//a[0]为关键字值--哨兵</span><br>       i=n;<span class="hljs-comment">//循环从尾部开始</span><br>       <span class="hljs-keyword">while</span>(a[i]!=key)&#123;<br>           i--;<br>       &#125;<br>       <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回0则说明查找失败</span><br>   &#125;<br></code></pre></td></tr></table></figure><h4>有序表查找</h4><ul><li><p><strong>二分查找</strong></p><p>前提条件是需要<u>有序表顺序存储</u>，如果无序则要先进行排序操作 </p><p>时间复杂度 O(logn) 比顺序查找有了质的飞跃</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,mid,high;<br>       low=<span class="hljs-number">0</span>;<span class="hljs-comment">//最低下标为记录首位</span><br>       high=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标为记录末位</span><br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=(low+high)/<span class="hljs-number">2</span>;<span class="hljs-comment">//折半 </span><br>           <span class="hljs-keyword">if</span>(a[mid]==value)&#123;<span class="hljs-comment">//中值与查找值相等 查找成功</span><br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<span class="hljs-comment">//中值比查找值大</span><br>               high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标调至中值前一位</span><br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<span class="hljs-comment">//中值比查找值小</span><br>               low=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//最低下标调至中值后一位</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回0查找失败</span><br>   &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-comment">//递归版本</span><br>       <span class="hljs-keyword">int</span> mid=low+(high-low)/<span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">if</span>(low&gt;high)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>       &#125;<br>       <span class="hljs-keyword">if</span>(a[mid]==key)&#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);            <br>           <span class="hljs-keyword">return</span> mid;<br>       &#125;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<br>            <span class="hljs-keyword">return</span> binarySearch(a,key,low,mid<span class="hljs-number">-1</span>);<br>        &#125;<br>       <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<br>           <span class="hljs-keyword">return</span> binarySearch(a,key,mid+<span class="hljs-number">1</span>,high);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>插值查找</strong></p><p>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率</p><p>时间复杂度 O(logn)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,mid,high;<br>       low=<span class="hljs-number">0</span>;<br>       high=n<span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=low+(key-a[low])/(a[high]-a[low])*(high-low);<br>           <span class="hljs-comment">//折半查找中mid=(low+high)/2</span><br>           <span class="hljs-keyword">if</span>(a[mid]==key)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<br>               high=mid<span class="hljs-number">-1</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<br>               low=mid+<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>斐波那契查找</strong></p><p>基于二分查找算法，通过运用黄金比例的概念在数列中选择查找点进行查找</p><p>时间复杂度 O(logn)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibonacciSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,high,mid,i,k;<br>       low=<span class="hljs-number">0</span>;<span class="hljs-comment">//最低下标为记录首位</span><br>       high=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标为记录末位</span><br>       k=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(n&gt;F[k]<span class="hljs-number">-1</span>)<span class="hljs-comment">//计算n位于斐波那契数列的位置</span><br>           k++;<br>       <span class="hljs-keyword">for</span>(i=n;i&lt;F[k]<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//将不满的数值补全</span><br>           a[i]=a[n];<br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=low+F[k<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<span class="hljs-comment">//计算当前分隔的下标</span><br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<span class="hljs-comment">//当前分隔大于查找值</span><br>               high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标调至mid-1</span><br>               k=k<span class="hljs-number">-1</span>;<span class="hljs-comment">//斐波那契数列下标-1</span><br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<span class="hljs-comment">//当前分隔小于查找值</span><br>               low=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//最低下标调至mid+1</span><br>               k=k<span class="hljs-number">-2</span>;<span class="hljs-comment">//斐波那契数列下标-2</span><br>           &#125;<br>           <span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">if</span>(mid&lt;=n)<span class="hljs-comment">//不是补全数值</span><br>                   <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">//返回下标</span><br>               <span class="hljs-keyword">else</span><br>                   <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//是补全数值返回n</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>   &#125;<br><br></code></pre></td></tr></table></figure><p>斐波那契查找算法的核心在于:</p><p>1)当a[mid]=key时，查找就成功<br>2)当a[mid]&gt;key时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个<br>3)当a[mid]&lt;key时，新范围是第mid+1个到第high 个，此时范围个数为F[k-2]-1个</p><h4>二叉排序树</h4><p>一棵二叉排序树（又称二叉查找树）<u>有可能是一棵空树</u> 否则满足如下性质</p><ol><li><p>若它的左子树不空，则左子树上所有结点的键值均小于它的根结点键值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的键值均小于它的根结点键值；</p></li><li><p>根的左、右子树也分别为二叉排序树。</p></li></ol><p><strong>对二叉查找树进行中序遍历，即可得到有序递增的数列。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTNode</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTR</span>=</span>Node *lchild,*rchild;<br>    &#125;biTNode,*biTree;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-a0b152e7dd56541e095f17fa3f3e06bc_r.jpg" alt="bst的平均查找长度示例"></p><h4>散列表(哈希表)</h4><p><code>存储位置=f(关键字)</code></p><p><strong>构造散列函数的方法</strong></p><ol><li><p><strong>直接定值法</strong> 取关键字的某个线性函数值作为散列地址 <code>f(key)=a*key+b</code></p></li><li><p><strong>数字分析法</strong> 事先知道关键字的分布且关键字若干位分布较均匀</p></li><li><p><strong>平方取中法</strong> 关键字平方取中间位 </p></li><li><p><strong>除留余数法</strong> <code>f(key) = key mod p (p&lt;=m) 表长为m</code></p><p>若散列表表长为m，通常p为小于或等于表长(最好接近m)的最小质数或不包含小于20质因子的合数</p></li><li><p><strong>随机数法</strong> 选一个随机数 取关键字的随机函数值作为其散列地址 f(key) = random(key)</p></li></ol><p><strong>处理散列冲突方法</strong></p><ol><li><p><strong>开放定址法</strong></p><p>只要在散列表未填满时，总是能找到不发生冲突的地址</p><ul><li><p><u>线性探测法</u></p><p><img src="https://i.loli.net/2020/12/20/bGBJrcZfmSh5IwP.png"></p><p>求余数，然后放到对应的位置上，如果位置上有数据元素了，那么就向后移动，移动到没有数据元素的位置上，然后占坑</p><p>平均查找长度 ASL = 元素查找次数总和 / 散列表长度 (下例中为16/11)</p><p><img src="https://pic4.zhimg.com/v2-ebc7c60b4f6c02ea79d760ef6202b8af_b.webp"></p></li><li><p><u>二次探测法</u></p><p><img src="https://i.loli.net/2020/12/20/gnmTr4zFQxLvPp6.png"></p><p>平方运算不让关键字都聚集在某一块区域</p></li><li><p><u>随机探测法</u></p><p><img src="https://i.loli.net/2020/12/20/YeRK9zWSZv4dyNo.png"></p><p>冲突时 对于位移量di采用随机函数计算得到</p></li></ul></li><li><p><strong>再散列函数法</strong></p><p><img src="https://i.loli.net/2020/12/20/Us1ZgamIbORAP8X.png"></p></li><li><p><strong>链地址法</strong></p><p><img src="https://pic3.zhimg.com/v2-1294c9705e969924685cdaa85b27f8f6_r.jpg"></p><p>平均查找长度ASL = (查找次数 * 个数) / 关键字个数 </p></li><li><p><strong>公共溢出区法</strong></p><p>为所有冲突的关键字建立了一个公共的溢出区存放</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> *elem;<span class="hljs-comment">//数据元素存储基址 动态分配数组</span><br>        <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//当前数据元素个数</span><br>    &#125;hashTable;<br><span class="hljs-keyword">int</span> length=<span class="hljs-number">0</span>;<span class="hljs-comment">//全局定义表长</span><br><span class="hljs-comment">//初始化散列表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initHash</span><span class="hljs-params">(hashTable *H)</span></span>&#123;<br>        length=HASHSIZE;<br>        H-&gt;count=length;<span class="hljs-comment">//初始化散列表长度为数组长度</span><br>        H-&gt;elem=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(m*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            H-&gt;elem[i]=NULLKEY;<span class="hljs-comment">//赋值为空值</span><br>        &#125;<br>    &#125;<br><span class="hljs-comment">//散列函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> key%m;<span class="hljs-comment">//除留余数法</span><br>    &#125;<br><span class="hljs-comment">//插入关键字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertHash</span><span class="hljs-params">(hashTable *H,<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> addr=hashFunc(key);<span class="hljs-comment">//求散列地址</span><br>        <span class="hljs-keyword">while</span>(H-&gt;elem[addr]!=NULLKEY)&#123;<span class="hljs-comment">//如果不为空 则冲突</span><br>            addr=(addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//开放定址法线性探测</span><br>        &#125;<br>        H-&gt;elem[addr]=key;<span class="hljs-comment">//直到有空位后插入关键字</span><br>    &#125;<br><span class="hljs-comment">//查找关键字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchHash</span><span class="hljs-params">(hashTable H,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> *addr)</span></span>&#123;<br>        *addr=hashFunc(key);<span class="hljs-comment">//求散列地址</span><br>        <span class="hljs-keyword">while</span>(H.elem[*addr]!=key)&#123;<span class="hljs-comment">//如果不为空 则冲突</span><br>            *addr=(*addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//开放定址法的线性探测</span><br>            <span class="hljs-keyword">if</span>(H.elem[*addr]==NULLKEY || *addr==hashFunc(key))&#123;<span class="hljs-comment">//循环回原点</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;关键字不存在!&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8_图</title>
    <link href="/2020/12/22/8-%E5%9B%BE/"/>
    <url>/2020/12/22/8-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3>    图</h3><h4>基本概念:</h4><p><strong>图的分类: </strong>有向图和无向图</p><p><strong>弧、弧头、弧尾: </strong>有向图的边称为弧。无向图叫做边。</p><p><strong>无向完全图: </strong>任何两点之间都有边的无向图。 </p><p><strong>有向完全图: </strong>任何两点之间都有弧的有向图。</p><p><strong>权：</strong>图的边附带数值，这个数值叫权。</p><p><strong>带权图: </strong>每条边都带权的图称为带权图。</p><p><strong>顶点的度、入度、出度: </strong>1. 无向图中顶点v的度是与该顶点相关联的边的数目，记为D(v)。 2. 有向图中，把以顶点v为终点的弧的数目称为v的入度，记为ID(v)；把以顶点v为始点的弧的数目称为v的出度，记为OD(v)。有向图顶点v的度为入度和出度之和，即D（v） = ID（v）+ OD（v）。</p><p><strong>简单路径: </strong>序列中<u>顶点</u>不重复出现的路径。</p><p><strong>回路: </strong>第一个顶点和最后一个顶点相同的路径。</p><p><strong>简单回路(简单环): </strong>除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。</p><p><strong>生成树(不唯一):</strong> n个顶点有n-1条边的无向图。权值最小的生成树是<strong>最小生成树(唯一)</strong>。</p><p><strong>强连通图:</strong> 有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路</p><p><strong>连通图:</strong> 无向图中，如果任意两个顶点之间都能够连通</p><h4>基本性质</h4><ul><li><p><strong>无向完全图</strong>, 边数最多为 n(n-1) / 2</p></li><li><p><strong>有向完全图</strong>, 边数最多为 n(n-1)</p></li><li><p><strong>有向强连通图</strong>, 边数最多为 n(n-1), 最少有n条边</p></li><li><p><strong>无向连通图</strong>, 边数最多为 n(n-1) / 2, 边数最少为 n-1条边   即生成树</p></li><li><p><strong>无向非连通图</strong>, 边数最多为 (n-1)(n-2)/2条边</p></li><li><p>树是图的特例 是无环无向图</p></li><li><p>握手定理</p><p>在无向图G=&lt;V,E&gt;中, 所有的节点的<strong>度数总和等于边数的2倍</strong></p><p>在有向图G=&lt;V,E&gt;中, 所有节点的度数的总和等于边数的2倍，所有节点的入度之和等于所有节点的出度之和</p></li></ul><h4>图的存储结构</h4><ul><li><p>点表示–所有顶点保存到数组</p></li><li><p>边表示</p><p><strong>邻接矩阵</strong></p><p>(矩阵中标记1，有边，标记0，没有边)</p><p><img src="https://i.loli.net/2020/12/15/K4AzwrFHQJmnvOT.png"></p><p><u>无向图</u>的邻接矩阵是一个<u>对称矩阵</u> <u>第i行或第i列</u>非零元素个数表示顶点v的度</p><p><u>有向图</u>的邻接矩阵<u>不一定</u>对称 (双向的有向图对称) <u>第i行</u>非零元素个数表示顶点v的<u>出度</u> <u>第i列</u>非零元素个数表示顶点v的<u>入度</u></p><p><strong>邻接表</strong></p><p>(顺序存储与链式存储相结合的存储方法)<img src="https://i.loli.net/2020/12/15/jzFGaKRWXQIsP7h.png"><code>∧符号，表示结束，没有连接的顶点了</code></p><p><u>无向图</u>的邻接表 第i个顶点的<u>度</u>为第i个链表的结点数</p><p><u>有向图</u>的邻接表 第i个顶点的<u>出度</u>为第i个链表的结点数 <u>入度</u>要遍历整个邻接表 找下标为i的结点</p></li></ul><h4>图的遍历</h4><p><strong>从图的某个顶点出发，系统地访问图的每个顶点，并且每个顶点只被访问一次。</strong></p><p><strong>1.深度优先搜索</strong></p><p>(往下走，走不动了，返回上一级再走)</p><img src="https://i.loli.net/2020/12/15/DTrNKIFMmH2PgkO.png" style="zoom:67%;" /><p><strong>2.广度优先搜索</strong></p><p>(顺着一个顶点，然后都遍历完)</p><img src="https://i.loli.net/2020/12/15/uvpTe58bEQmgSqZ.png" style="zoom:67%;" /><h4>最小生成树</h4><p><strong>(所有生成树中权总和最小的生成树)</strong></p><p>构造方法:</p><ul><li><strong>Prim算法</strong></li></ul><img src="https://i.loli.net/2020/12/15/mnlBOgecfLJ98Nk.png" alt="Prim" style="zoom: 50%;" /><ul><li><p><strong>Kruskal算法</strong></p><p>先对边按权值从小到大排序, 每次从剩余的边中选取一个最小的边。</p><img src="https://i.loli.net/2020/12/31/3kJDpBLMHutFagv.png" style="zoom:50%;" /></li></ul><h4>最短路径</h4><ul><li>Dijkstra算法</li></ul><img src="https://i.loli.net/2020/12/31/syWFuNBgvDwr6E1.png" alt="image.png" style="zoom:67%;" /><ul><li>Floyd算法</li></ul><h4>拓扑排序</h4><p>AOV网: 用顶点表示活动的有向图</p><p>工程或者某种流程可以分为若干个小的工程或阶段，这些小的工程或阶段就称为活动。</p><p> 如果以图中的顶点来表示活动，有向边表示活动之间的优先关系。</p><p><img src="https://i.loli.net/2020/12/15/LxbmKU6QSI8Cc4g.png"></p><p>拓扑排序: 一个有向无环图（DAG）的所有顶点的线性序列。</p><p>该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li></ol><p>基本步骤如下：</p><ol><li>图中选择一个入度为0的顶点，输出该顶点</li><li>从图中删除该顶点及相关联的弧，调整被删弧的弧头结点的入度（入度减1）</li><li>重复执行上述两个步骤，<u>直到所有的入度为0</u></li></ol><p><img src="https://i.loli.net/2020/12/15/jEUabHSgTWGJFys.png" alt="example"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7_Huffman树及算法</title>
    <link href="/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>哈夫曼树与哈夫曼算法</h3><p><strong>哈夫曼树不唯一、时刻考虑权值最小</strong></p><p><strong>路径: </strong>从一个结点到另一个结点的分支序列</p><p><strong>路径长度:  </strong>根结点到L层结点路径长度L-1 (完全二叉树是总路径长度最短的二叉树)</p><h4>Huffman树: </h4><p>由n个带权值的叶结点构成的二叉树中,树的最大带权长度(WPL)最小的二叉树称为最优二叉树</p><p><img src="https://i.loli.net/2020/12/15/hWX4R9MKypGocqS.png" alt="example"></p><p><img src="https://i.loli.net/2020/12/15/jVy6DCFdxcSOANl.gif"></p><h4>huffman编码</h4><p>例题: 设某通讯系统中一个待传输的文本有6个不同字符，它们的出现频率分别是0.5,0.8,1.4,2.2,2.3,2.8，试设计哈夫曼编码</p><p><img src="https://i.loli.net/2020/12/15/A6p9vIMjdKyXUm8.png"></p><p>出现频率为0.5的字符编码为1000 出现频率为0.8的字符编码为1001 出现频率为1.4的字符编码为101 出现频率为2.2的字符编码为00 出现频率为2.3的字符编码为01 出现频率为2.8的字符编码为11</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6_树和森林</title>
    <link href="/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <url>/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<h3>树</h3><p><strong>核心概念: </strong>线性结构中一个结点至多只有一个直接后继，树形结构一个结点可以有一个或多个直接后继</p><h4>相关术语:</h4><ul><li>结点的度: 结点拥有的子树数</li><li>叶子节点: 度为0的结点</li><li>分支节点: 度不为0的结点</li><li>树的度: 树内各结点的度的最大值, 就是把所有结点的度求和</li><li>结点的层次: 根为第一层, 其余结点的层次为其双亲的层次加1</li><li>结点间关系: Parent Child</li><li>树的深度/高度: 树中结点最大层次</li><li>森林: m棵不相交的树的集合</li></ul><h4>树的存储结构:</h4><p><strong>1.双亲表示法</strong></p><p><strong>2.孩子表示法</strong></p><p><strong>3.孩子兄弟表示法</strong></p><h4>树、森林与二叉树的关系: </h4><p><strong>树到二叉树手工模拟: </strong></p><p><img src="https://i.loli.net/2020/12/15/jMkBR4lWhDS3JUt.gif" alt="树到二叉树"></p><p>​     1).连线(兄弟节点加线) 2).删线(只保留左孩子) 3).旋转(顺时针45)</p><p>​     <strong>将结点的孩子放在左子树 结点的兄弟放在右子树 形态唯一!!!</strong></p><p><strong>森林转换成二叉树</strong></p><p><img src="https://i.loli.net/2020/12/15/GfUBmqkdy94aJ83.png" alt="森林到二叉树"></p><p>​    1).每棵树转换成相应的二叉树 2).各棵二叉树的根结点看做是兄弟连接起来</p><p><strong>二叉树到树手工模拟</strong></p><p><img src="https://img-blog.csdnimg.cn/20190629154649448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDY4ODIxNw==,size_16,color_FFFFFF,t_70" alt="二叉树到树"></p><p>​    1).连线(结点与其子树的右孩子) 2).删线(双亲与右孩子) 3).旋转(逆时针45)</p><h4>树和森林的遍历:</h4><p><strong>树的遍历</strong>:</p><ul><li>先序遍历: 访问根结点 依次先序遍历根的各棵子树</li><li>后序遍历: 依次后序遍历根的各棵子树 访问根结点</li><li>层次遍历: 访问根结点 依次从左到右访问结点</li></ul><p><strong>森林的遍历</strong></p><ul><li>先序遍历森林</li></ul><p>访问森林中第一棵树的根结点<br>先序遍历森林中第一棵树的根结点子树组成的森林<br>先序遍历除去第一棵树之外其余的树组成的森林</p><ul><li>中序遍历森林</li></ul><p>中序遍历森林中第一棵树的根结点的子树组成的森林<br>访问第一棵树的根结点<br>中序遍历除去第一棵树之外其余的树组成的森林</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5_二叉树算法</title>
    <link href="/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>二叉树存储结构:</h3><h4>1.顺序存储结构</h4><p>一般只用于完全二叉树</p><h4>2.链式存储结构--二叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左右孩子指针</span><br>    &#125;biTree;<br></code></pre></td></tr></table></figure><p><strong>遍历二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        preOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//先先序遍历左子树</span><br>        preOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//再先序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//2.中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//中序遍历左子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        inOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//中序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//3.后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        postOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//后序遍历左子树</span><br>        postOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//后序遍历右子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(*t)-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>    &#125;<br><span class="hljs-comment">//4.层序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        biTree *tmp=t;<br>        circleQueue *q;<br>        q=initQueue();<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;根结点为空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            enQueue(q,*tmp);<span class="hljs-comment">//根结点入队</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(q.rear!=q.front)&#123;<span class="hljs-comment">//队不为空</span><br>            p=q.getEle();<span class="hljs-comment">//取队首元素</span><br>            deQueue();<span class="hljs-comment">//出队一个元素</span><br>            <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树不为空</span><br>                enQueue(q,p-&gt;lchild);<span class="hljs-comment">//左子树入队</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//右子树不为空</span><br>                enQueue(q,p-&gt;rchild);<span class="hljs-comment">//右子树入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//已知前序中序可确定一棵二叉树</span><br><span class="hljs-comment">//已知后序中序可确定一棵二叉树</span><br></code></pre></td></tr></table></figure><p><strong>创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createBiTree</span><span class="hljs-params">(biTree *t)</span></span>&#123;<span class="hljs-comment">//前序建立</span><br>       <span class="hljs-keyword">int</span> newValue;<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;newValue);<br>       <span class="hljs-keyword">if</span>(newValue==<span class="hljs-string">&quot;#&quot;</span>)&#123;<br>           *t=<span class="hljs-literal">NULL</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           *t=(biTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(biTree));<br>           <span class="hljs-keyword">if</span>(!*t)<br>               <span class="hljs-built_in">exit</span>(OVERFLOW);<br>           (*t)-&gt;data=newValue;<span class="hljs-comment">//生成根结点</span><br>           createBiTree(&amp;(*t)-&gt;lChild);<span class="hljs-comment">//构造左子树</span><br>           createBiTree(&amp;(*t)-&gt;rChild);<span class="hljs-comment">//构造右子树</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>求结点总数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNum</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> total)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           total=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>       total=<span class="hljs-number">1</span>+getNum(t-&gt;lchild)+getNum(t-&gt;child);<span class="hljs-comment">//左结点数+右结点数+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> height)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           height=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">int</span> lh=getHeight(t-&gt;left);<br>           <span class="hljs-keyword">int</span> rh=getHeight(t-&gt;right);<br>           height=((lh&gt;rh)?lh:rh)+<span class="hljs-number">1</span>;<span class="hljs-comment">//树的高度为左右子树高度大者+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求叶子数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getLeaves</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> leaves)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           leaves=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((t-&gt;lchild==<span class="hljs-literal">NULL</span>)&amp;&amp;(t-&gt;rchild==<span class="hljs-literal">NULL</span>))&#123;<span class="hljs-comment">//只有一个根结点</span><br>           leaves=<span class="hljs-number">1</span>;<br>&#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           leaves=getLeaves(t-&gt;lchild)+getLeaves(t-&gt;rchild);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4_二叉树理论</title>
    <link href="/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/"/>
    <url>/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3>二叉树</h3><h4>概念：</h4><p>二叉树是n(n≥0)个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相交的左子树和右子树组成，其中左子树和右子树也均为二叉树。二叉树的任一结点都有两棵子树（<code>它们中的任何一个都可以是空子树</code>），并且这两棵子树之间有次序关系，交换位置就成为一棵不同的二叉树。</p><h4>性质:</h4><ul><li><strong>性质1：</strong>二叉树第i (i≥1) 层上至多有2^(i-1)个结点。</li><li><strong>性质2：</strong>深度为k (k≥1) 的二叉树至多有2^(k)-1个结点</li><li><strong>性质3：</strong>对任何一棵二叉树, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。</li><li><strong>性质4：</strong>含有n个结点的完全二叉树的深度为 log2(n +1) 或 log2n +1</li><li><strong>性质5：</strong>如果对一棵有n个结点的完全二叉树的结点按<code>层序编号</code>（从第一层到最后一层，每层从左到右），对任一结点i（1≤i≤n）有：<ol><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲编号为 ⌊ i/2 ⌋ 。</li><li>如果2i&gt;n，则结点i无左右孩子（结点i为叶子结点）；否则其左孩子编号为 2i 。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则右孩子编号为 2i+1 。</li></ol></li></ul><h4>特殊二叉树:</h4><p><strong>1.斜树: </strong>左斜树 右斜树 结点个数与深度相同</p><p><strong>2.满二叉树: </strong>所有分支结点都存在左子树右子树 非叶子结点度数一定为2 深度为k(k≥1) 有2^(k)-1个结点</p><p><strong>3.完全二叉树: </strong>编号为i的结点与同样深度的满二叉树中编号为i的结点位置完全相同</p><p><img src="https://i.loli.net/2020/12/14/zlpoHNaALK6YGOw.png"></p><p><strong>完全二叉树就是除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点.</strong></p><p><strong>满二叉树一定是完全二叉树 完全二叉树不一定满</strong></p><h4>二叉树的遍历:</h4><ul><li><p>先序NLR</p><p><img src="https://i.loli.net/2020/12/15/ESZFVAXh7GsyHB6.gif" alt="先序"></p></li><li><p>中序LNR</p><p><img src="https://i.loli.net/2020/12/15/87S3i1rXVcsvxK4.gif" alt="中序"></p></li><li><p>后序LRN</p><p><img src="https://i.loli.net/2020/12/15/6X8MJ1DjoF5TKAv.gif" alt="后序"></p></li></ul><p><img src="https://i.loli.net/2020/12/14/rHIfCwJyQzclnmp.png" alt="example"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3_队列</title>
    <link href="/2020/12/14/3-%E9%98%9F%E5%88%97/"/>
    <url>/2020/12/14/3-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3>队列(Queue)---先进先出的线性表(First In First Out)</h3><img src="https://i.loli.net/2020/12/14/AlndLPCGHyRxYoa.png" alt="image.png" style="zoom:100%;" /><h4>0.特点:</h4><p>一端插入另一端删除</p><h4>1.顺序队列</h4><p>由于顺序队列容易假溢出 于是通常采用循环队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//顺序队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><br></code></pre></td></tr></table></figure><p><strong>1.1循环队列</strong></p><img src="https://i.loli.net/2020/12/14/MCPjGc8pWY13zKR.png" alt="image.png" style="zoom:100%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">引入循环队列:<br>区别队空队满方法:<br><span class="hljs-number">1.</span>牺牲一个存储空间<br>    <span class="hljs-number">2.</span>引入一个标志变量区别空余与不空<br>    <span class="hljs-number">3.</span>使用计数器<br> 牺牲一个存储空间<br>    (Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front;<span class="hljs-comment">//满队列条件</span><br>Q.rear=Q.front;<span class="hljs-comment">//空队列条件</span><br><span class="hljs-keyword">int</span> total=(Q.rear-Q.front+MAXSIZE)%MAXSIZE<span class="hljs-comment">//队列元素个数</span><br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//入队</span><br>Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//出队</span><br><span class="hljs-comment">//循环队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><span class="hljs-comment">//队列初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(sqQueue *Q)</span></span>&#123;<br>        Q.front=<span class="hljs-number">0</span>;<br>        Q.rear=<span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-comment">//入队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满!&quot;</span>);<br>        &#125;<br>        Q-&gt;data[Q-&gt;rear]=newValue;<span class="hljs-comment">//将值赋值给队尾</span><br>        Q-&gt;rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//尾指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//出队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *oldValue= Q-&gt;data[Q-&gt;front]; <span class="hljs-comment">//将队头元素赋值为oldValue</span><br>        Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//头指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//取队首元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getEle</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *myValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *myValue= Q-&gt;data[(Q-&gt;front+<span class="hljs-number">1</span>)%MAXSIZE];<br>        <br>    &#125;<br><br></code></pre></td></tr></table></figure><h4>2.链式队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链式队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span> <span class="hljs-comment">//结点结构</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>    &#125;QNode,*QueuePtr;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//队列链表结构</span><br>        QueuePtr front,rear;<span class="hljs-comment">//队头队尾指针</span><br>    &#125;LQueue;<br><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/SqC8izdylpIKvbf.png" alt="链式队列"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        QueuePtr temp = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow&quot;</span>);<span class="hljs-comment">//存储分配失败</span><br>        &#125;<br>        temp-&gt;data = e;<br>        temp-next = <span class="hljs-literal">NULL</span>;<br>        (Q-&gt;rear)-&gt;next = temp;<span class="hljs-comment">//新结点赋值给原队尾结点的后继</span><br>        Q-&gt;rear = temp;<span class="hljs-comment">//temp设置为尾结点 rear指向temp</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/Ly2lxoZ1SVNCrB4.png" alt="链式队列入队"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<br>        QueuePtr temp;<br>        <span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        temp=Q-&gt;front-&gt;next;<span class="hljs-comment">//队头结点赋值给temp</span><br>        *e=temp-&gt;data;<br>        Q-&gt;front-&gt;next=temp-&gt;next;<span class="hljs-comment">//原头结点后继temp-&gt;next赋值给头结点后继</span><br>        <span class="hljs-keyword">if</span>(Q-&gt;rear==temp)&#123;<span class="hljs-comment">//若队头是队尾 则删除后将rear指向头结点</span><br>            Q-&gt;rear=Q-&gt;front;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(temp);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2_栈</title>
    <link href="/2020/12/12/2-%E6%A0%88/"/>
    <url>/2020/12/12/2-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3>栈(Stack)---后进先出的线性表(Last In First Out)</h3><h4>1.顺序栈</h4><p>  栈空时 栈顶指针top==-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<br>        <span class="hljs-keyword">int</span> top; <span class="hljs-comment">//栈顶指针</span><br>    &#125;sqStack;<br><span class="hljs-comment">//栈的初始化 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(sqStack *s)</span></span>&#123;<br>        s-&gt;top=<span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//进栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s-&gt;top==MAXSIZE<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈满!&quot;</span>);<br>        &#125;<br>        s-&gt;top++; <span class="hljs-comment">//栈顶指针加一</span><br>        s-&gt;data[s-&gt;top]=newValue;<br>&#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br>*oldValue=s-&gt;data[s-&gt;top]; <span class="hljs-comment">//暂存被删除元素的值</span><br>s-&gt;top--; <span class="hljs-comment">//栈顶指针减一</span><br>&#125;<br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(sqStack s)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> topE=s-&gt;data [s-&gt;top];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素:%d&quot;</span>,topE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双栈情况:</strong></p><p>  双栈的两个栈底分别设置在数组的两端，栈顶分为是top1,top2</p><p>  两个栈顶在中间相遇，条件为 （top1+1=top2）发生上溢</p><p>  判断栈空条件: 一个是 top=0 另一个是top = maxsize -1 </p><h4>2.链栈</h4><p>(一个只能采用头插法插入或删除的链表)</p><p><img src="https://i.loli.net/2020/12/14/wd4CXlIvhELuSYt.png" alt="头插法"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span> *<span class="hljs-title">next</span>;</span><br>    &#125;linkStack;<br><span class="hljs-comment">//入栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(linkStack *top,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        linkStack *newNode=(linkStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linkStack));<br>        newNode-&gt;data=newValue;<br>        newNode-&gt;next=top;<br>        top=newNode;<span class="hljs-comment">//类比无头结点插入</span><br>    &#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断栈不为空</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            linkStack *oldNode=top;<span class="hljs-comment">//暂存栈顶元素</span><br>            top=top-&gt;next;<span class="hljs-comment">//弹出栈顶元素</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;弹出元素: %d&quot;</span>,oldNode-&gt;data);<br>            <span class="hljs-built_in">free</span>(oldNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//始终从同一个位置入栈出栈</span><br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(top==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素: %d&quot;</span>,top-&gt;data);<br>        &#125;<br>&#125;<br><span class="hljs-comment">//清空栈 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        linkStack *myNode;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            myNode=top;<br>            top=top-&gt;next;<br>            <span class="hljs-built_in">free</span>(myNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//求栈中元素个数 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            count++;<br>            top=top-&gt;next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>3.栈的应用</h4><p><strong>中缀表达式转后缀表达式</strong></p><p>​    首先将各种运算符（包括括号）的优先级排列如下（数字越大，优先级越高）：</p><p>​    1：（</p><p>​    2：+ -</p><p>​    3：* /</p><p>​    4：）</p><p>​    对输入的中缀表达式从左到右遍历：</p><p>​        1）如果遇到数字，直接添加到后缀表达式末尾；</p><p>​        2）如果遇到运算符+、-、*、/：</p><p>​            若栈空，则直接将此运算符压入栈。</p><p>​            若栈非空，则查看栈顶元素, 如果栈顶元素优先级&gt;=此操作符级别，则弹出栈顶元素，将元素添加到后缀表达式中，并继续进行上述判断。如果不满足上述判断或者栈为空，将这个运算符入栈。要注意的是，经过上述步骤，这个运算符最终一定会入栈。</p><p>​        3）如果遇到括号：</p><p>​            左括号直接入栈。</p><p>​            右括号，弹出栈中第一个左括号前所有的操作符，并将左括号弹出。（右括号不入栈）</p><p>​        4）字符串遍历结束后，如果栈不为空，则弹出栈中所有元素，将它们添加到后缀表达式的末尾，直到栈为空。</p><p><strong>后缀表达式求值:</strong></p><p>​    准备一个数字栈。从左到右扫描后缀表达式，如果是数字，放入数字栈。</p><p>​    如果是符号，从数字栈中弹出两个数字，第一个取出的数字为右运算数，第二个为左运算数，进行运算。然后将结果放进数字栈中。</p><p>​    如此反复，直到读完整个表达式后，留在数字栈中的那个数字就是最终结果。</p><p><strong>中缀表达式求值:</strong></p><p>  将前面的两步结合起来</p><p>  准备一个数字栈和一个符号栈。从左到右遍历中缀表达式。如果遇到数字，入数字栈。</p><p>  如果遇到符号（四个运算符以及括号），跟前面的“中缀表达式转后缀表达式”过程一样，对符号栈进行处理。处理过程中，对每一个出栈的运算符：+ - * /，根据“计算后缀表达式”的方法，计算结果（跟数字栈配合）。</p><p>  如果遍历完中缀表达式后符号栈还非空，就继续出符号栈的运算符，计算，直到符号栈为空。最后数字栈剩下的数字就是结果。</p><p>【参考资料】</p><p>[1] <a href="https://blog.csdn.net/sinat_27908213/article/details/80273557">https://blog.csdn.net/sinat_27908213/article/details/80273557</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_线性表</title>
    <link href="/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4>线性表的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data[MAXSIZE];<br>    <span class="hljs-keyword">int</span> length;<br>&#125;sqList;<br><span class="hljs-comment">//取元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getElem</span><span class="hljs-params">(sqList L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//取第i个元素</span><br>        <span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>||i&lt;<span class="hljs-number">1</span>||i&gt;L.length)&#123;<span class="hljs-comment">//表空或者i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L.data[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//用指针存储</span><br>    &#125;<br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> e)</span></span>&#123; <span class="hljs-comment">//第i位插入e</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==MAXSIZE)&#123;<span class="hljs-comment">//顺序表满</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满无法插入&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;=L-&gt;length)&#123;<span class="hljs-comment">//可插入</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=L-&gt;length<span class="hljs-number">-1</span>;x&gt;=i<span class="hljs-number">-1</span>;x--)&#123;<span class="hljs-comment">//从第i到最后的元素都后移一位</span><br>                L-&gt;data[x+<span class="hljs-number">1</span>]=L-&gt;data[x]; <br>            &#125;<br>        &#125;<br>        L-&gt;data[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">//对第i位进行赋值</span><br>        L-&gt;length++;<span class="hljs-comment">//表长加一</span><br>    &#125;<br><span class="hljs-comment">//删除操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//删除第i位</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L-&gt;data[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(i&lt;L-&gt;length)&#123;<span class="hljs-comment">//如果删除的不是最后一个位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=i;x&lt;L-&gt;length;x++)&#123;<span class="hljs-comment">//被删除元素后的元素全部前移</span><br>                L-&gt;data[x<span class="hljs-number">-1</span>]=L-&gt;data[x];<br>            &#125;<br>        &#125;<br>         L-&gt;length--;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>线性表的链式存储</h4><p><strong>0.链表的特点</strong></p><p>(1)不要求用地址连续的存储空间在储，每个结点在运行时动态生成。结点的存储空间在物理位置上可以相邻，也可以不相邻;<br>(2)插入和删除操作不需要移动元素，只需修改指针，满足经常插入和删除结点的需求;<br>(3)链表不具备顺序表随机存取的优点﹔<br>(4)空间开销比较大，因链表结点增加了指示元素间关系的指针域<br>(5)链表是存储动态变化数据的理想选择。</p><p><strong>1.单链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//无头结点插入 新插入的x作为首元结点</span><br>    s-&gt;next=head;<br>head=s;<br><br> <span class="hljs-comment">//有头结点插入</span><br>s-&gt;next=head-&gt;next;<br>head-&gt;next=s;<br><span class="hljs-comment">//遍历traverse 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>        p=p-&gt;next;<br>        count++;<span class="hljs-comment">//用count求表长</span><br>    &#125;<br><span class="hljs-comment">//查找 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=theValue)&#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">else</span>&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position: %d&quot;</span>,count);<br>&#125;<br><span class="hljs-comment">//插入 </span><br>pre=head;<span class="hljs-comment">//在结点p之前插入</span><br><span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;pre-&gt;next!=p)&#123;<br>        pre=pre-&gt;next;<br>    &#125;<br><span class="hljs-keyword">if</span>(!pre)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p结点不存在!&quot;</span>);<br>    &#125;<br>Node *s=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>s-&gt;data=value;<br>s-&gt;next=pre-&gt;next;<br>pre-&gt;next=s;<span class="hljs-comment">//插入新结点</span><br><span class="hljs-comment">//删除</span><br>pre=head;<span class="hljs-comment">//删除第i个结点</span><br>count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(pre-&gt;next&amp;&amp;count&lt;i)&#123;<span class="hljs-comment">//找到第i-1个</span><br>        pre=pre-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;给出序号超出链表长度!&quot;</span>);<br>    &#125;<br>q=pre-&gt;next;<br>pre-&gt;next=q-&gt;next;<span class="hljs-comment">//删除</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放</span><br><span class="hljs-comment">//创建(头插法)</span><br><span class="hljs-comment">//创建(尾插法)</span><br><span class="hljs-comment">//逆置</span><br>Node *tmp,*p;<br>p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br>head-&gt;next=<span class="hljs-literal">NULL</span><span class="hljs-comment">//头结点指针置空 形成空链表</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        tmp=p-&gt;next;<span class="hljs-comment">//暂存p的后继</span><br>        p-&gt;next=head-&gt;next;<span class="hljs-comment">//p插入头结点后面</span><br>        head-&gt;next=p;<br>        p=tmp;<span class="hljs-comment">//继续处理下一个结点</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.双链表</strong></p><p><img src="https://i.loli.net/2020/12/12/b3M71k2lcBr5LN6.jpg" alt="插入"></p><p><img src="https://i.loli.net/2020/12/12/lpADuRx4MjfSGYi.jpg" alt="删除"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在p前插入s</span><br>s-&gt;prior=p-&gt;prior; <span class="hljs-comment">//1.p原先的前驱成为s的前驱</span><br>   p-&gt;prior-&gt;next=s; <span class="hljs-comment">//2.s成为p原先的前驱的后继</span><br>s-&gt;next=p;  <span class="hljs-comment">//3.s的后继是p</span><br>p-&gt;prior=s; <span class="hljs-comment">//4.修改p的前驱为s</span><br><span class="hljs-comment">//其中 4可以提前到3前 但不能到1,2前 否则会丢失结点</span><br><span class="hljs-comment">//删除p</span><br>p-&gt;prior-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=p-&gt;prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p><strong>3.单循环链表</strong> 往往不带头结点 往往只设尾指针</p><p><strong>4.双循环链表</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0_绪论</title>
    <link href="/2020/12/12/0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/12/12/0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>​     <strong>数据(data)</strong>是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p>​     <strong>数据元素(data element)</strong>是数据的<u>基本单位</u>，在计算机程序中通常作为一个整体进行考虑和处理。</p><p>​     <strong>数据项(Data Item)</strong>数据项是数据的不可分割的<u>最小单位</u>。</p><p>​     <strong>数据对象(data object)</strong>是性质相同的数据元素的<u>集合</u>，是数据的一个子集。</p><p><img src="https://i.loli.net/2020/12/11/XLBtmuz6pUNMwK5.jpg"></p><p>​     <strong>如图: 数据对象由若干数据元素组成，数据元素由若干数据项组成</strong></p><p>​     <strong>数据结构(data structure)</strong>又称逻辑结构，是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下四类基本结构：<u>集合</u>、<u>线性结构</u>、<u>树形结构</u>、<u>图状结构</u>。</p><p>​     <strong>存储结构（物理结构）</strong>是数据结构在计算机中的表示（又称映像）。表示数据元素之间的关联方式有:  <u>顺序存储方式</u>、<u>链式存储方式</u>、索引存储方式、散列存储方式</p><p>​     <strong>数据类型(data type)</strong>是一个值的集合和定义在这个值集上的一组操作的总称。</p><p>​     <strong>抽象数据类型(AbstractData Type)</strong>是指一个数学模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。</p><p>​     算法的<strong>五个基本特征</strong>: 输入、输出、有穷性、确定性和可行性。</p><p>​     评价<strong>算法的好坏</strong>有四个方面的因素: <u>1.正确性</u> <u>2.易读性</u> <u>3.健壮性</u> <u>4.时空性</u></p><p>​     <strong>时间复杂度</strong>的计算: 找出基本操作, 估算算法的计算量</p>]]></content>
    
    
    
    <tags>
      
      <tag>DSNotes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/10/Hello-World/"/>
    <url>/2020/12/10/Hello-World/</url>
    
    <content type="html"><![CDATA[<p>Hiii! This is my first blog, can’t wait to share my tech ideas with u guys!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
