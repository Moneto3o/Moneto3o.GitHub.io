<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>7_Huffman树及算法</title>
    <link href="/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>哈夫曼树与哈夫曼算法</h3><p><strong>哈夫曼树不唯一、时刻考虑权值最小</strong></p><p><strong>路径: </strong>从一个结点到另一个结点的分支序列</p><p><strong>路径长度:  </strong>根结点到L层结点路径长度L-1 (完全二叉树是总路径长度最短的二叉树)</p><h4>Huffman树: </h4><p>由n个带权值的叶结点构成的二叉树中,树的最大带权长度(WPL)最小的二叉树称为最优二叉树</p><p><img src="https://i.loli.net/2020/12/15/hWX4R9MKypGocqS.png" alt="example"></p><p><img src="https://i.loli.net/2020/12/15/jVy6DCFdxcSOANl.gif"></p><h4>huffman编码</h4><p>例题: 设某通讯系统中一个待传输的文本有6个不同字符，它们的出现频率分别是0.5,0.8,1.4,2.2,2.3,2.8，试设计哈夫曼编码</p><p><img src="https://i.loli.net/2020/12/15/A6p9vIMjdKyXUm8.png"></p><p>出现频率为0.5的字符编码为1000 出现频率为0.8的字符编码为1001 出现频率为1.4的字符编码为101 出现频率为2.2的字符编码为00 出现频率为2.3的字符编码为01 出现频率为2.8的字符编码为11</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6_树和森林</title>
    <link href="/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <url>/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<h3>树</h3><p><strong>核心概念: </strong>线性结构中一个结点至多只有一个直接后继，树形结构一个结点可以有一个或多个直接后继</p><h4>相关术语:</h4><ul><li>结点的度: 结点拥有的子树数</li><li>叶子节点: 度为0的结点</li><li>分支节点: 度不为0的结点</li><li>树的度: 树内各结点的度的最大值, 就是把所有结点的度求和</li><li>结点的层次: 根为第一层, 其余结点的层次为其双亲的层次加1</li><li>结点间关系: Parent Child</li><li>树的深度/高度: 树中结点最大层次</li><li>森林: m棵不相交的树的集合</li></ul><h4>树的存储结构:</h4><p><strong>1.双亲表示法</strong></p><p><strong>2.孩子表示法</strong></p><p><strong>3.孩子兄弟表示法</strong></p><h4>树、森林与二叉树的关系: </h4><p><strong>树到二叉树手工模拟: </strong></p><p><img src="https://i.loli.net/2020/12/15/jMkBR4lWhDS3JUt.gif" alt="树到二叉树"></p><p>​     1).连线(兄弟节点加线) 2).删线(只保留左孩子) 3).旋转(顺时针45)</p><p><strong>森林转换成二叉树</strong></p><p><img src="https://i.loli.net/2020/12/15/GfUBmqkdy94aJ83.png" alt="森林到二叉树"></p><p>​    1).每棵树转换成相应的二叉树 2).各棵二叉树的根结点看做是兄弟连接起来</p><p><strong>二叉树到树手工模拟</strong></p><p><img src="https://img-blog.csdnimg.cn/20190629154649448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDY4ODIxNw==,size_16,color_FFFFFF,t_70" alt="二叉树到树"></p><p>​    1).连线(结点与其子树的右孩子) 2).删线(双亲与右孩子) 3).旋转(逆时针45)</p><h4>树和森林的遍历:</h4><p><strong>树的遍历</strong>:</p><ul><li>先序遍历: 访问根结点 依次先序遍历根的各棵子树</li><li>后序遍历: 依次后序遍历根的各棵子树 访问根结点</li><li>层次遍历: 访问根结点 依次从左到右访问结点</li></ul><p><strong>森林的遍历</strong></p><ul><li>先序遍历森林</li></ul><p>访问森林中第一棵树的根结点<br>先序遍历森林中第一棵树的根结点子树组成的森林<br>先序遍历除去第一棵树之外其余的树组成的森林</p><ul><li>中序遍历森林</li></ul><p>中序遍历森林中第一棵树的根结点的子树组成的森林<br>访问第一棵树的根结点<br>中序遍历除去第一棵树之外其余的树组成的森林</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5_二叉树算法</title>
    <link href="/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>二叉树存储结构:</h3><h4>1.顺序存储结构</h4><p>一般只用于完全二叉树</p><h4>2.链式存储结构--二叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左右孩子指针</span><br>    &#125;biTree;<br></code></pre></td></tr></table></figure><p><strong>遍历二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        preOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//先先序遍历左子树</span><br>        preOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//再先序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//2.中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//中序遍历左子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        inOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//中序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//3.后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        postOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//后序遍历左子树</span><br>        postOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//后序遍历右子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(*t)-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>    &#125;<br><span class="hljs-comment">//4.层序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        biTree *tmp=t;<br>        circleQueue *q;<br>        q=initQueue();<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;根结点为空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            enQueue(q,*tmp);<span class="hljs-comment">//根结点入队</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(q.rear!=q.front)&#123;<span class="hljs-comment">//队不为空</span><br>            p=q.getEle();<span class="hljs-comment">//取队首元素</span><br>            deQueue();<span class="hljs-comment">//出队一个元素</span><br>            <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树不为空</span><br>                enQueue(q,p-&gt;lchild);<span class="hljs-comment">//左子树入队</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//右子树不为空</span><br>                enQueue(q,p-&gt;rchild);<span class="hljs-comment">//右子树入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//已知前序中序可确定一棵二叉树</span><br><span class="hljs-comment">//已知后序中序可确定一棵二叉树</span><br></code></pre></td></tr></table></figure><p><strong>创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createBiTree</span><span class="hljs-params">(biTree *t)</span></span>&#123;<span class="hljs-comment">//前序建立</span><br>       <span class="hljs-keyword">int</span> newValue;<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;newValue);<br>       <span class="hljs-keyword">if</span>(newValue==<span class="hljs-string">&quot;#&quot;</span>)&#123;<br>           *t=<span class="hljs-literal">NULL</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           *t=(biTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(biTree));<br>           <span class="hljs-keyword">if</span>(!*t)<br>               <span class="hljs-built_in">exit</span>(OVERFLOW);<br>           (*t)-&gt;data=newValue;<span class="hljs-comment">//生成根结点</span><br>           createBiTree(&amp;(*t)-&gt;lChild);<span class="hljs-comment">//构造左子树</span><br>           createBiTree(&amp;(*t)-&gt;rChild);<span class="hljs-comment">//构造右子树</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>求结点总数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNum</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> total)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           total=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>       total=<span class="hljs-number">1</span>+getNum(t-&gt;lchild)+getNum(t-&gt;child);<span class="hljs-comment">//左结点数+右结点数+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> height)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           height=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">int</span> lh=getHeight(t-&gt;left);<br>           <span class="hljs-keyword">int</span> rh=getHeight(t-&gt;right);<br>           height=((lh&gt;rh)?lh:rh)+<span class="hljs-number">1</span>;<span class="hljs-comment">//树的高度为左右子树高度大者+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求叶子数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getLeaves</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> leaves)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           leaves=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((t-&gt;lchild==<span class="hljs-literal">NULL</span>)&amp;&amp;(t-&gt;rchild==<span class="hljs-literal">NULL</span>))&#123;<span class="hljs-comment">//只有一个根结点</span><br>           leaves=<span class="hljs-number">1</span>;<br>&#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           leaves=getLeaves(t-&gt;lchild)+getLeaves(t-&gt;rchild);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4_二叉树理论</title>
    <link href="/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/"/>
    <url>/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3>二叉树</h3><h4>概念：</h4><p>二叉树是n(n≥0)个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相交的左子树和右子树组成，其中左子树和右子树也均为二叉树。二叉树的任一结点都有两棵子树（<code>它们中的任何一个都可以是空子树</code>），并且这两棵子树之间有次序关系，交换位置就成为一棵不同的二叉树。</p><h4>性质:</h4><ul><li><strong>性质1：</strong>二叉树第i (i≥1) 层上至多有2^(i-1)个结点。</li><li><strong>性质2：</strong>深度为k (k≥1) 的二叉树至多有2^(k)-1个结点</li><li><strong>性质3：</strong>对任何一棵二叉树, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。</li><li><strong>性质4：</strong>含有n个结点的完全二叉树的深度为 log2(n +1) 或 log2n +1</li><li><strong>性质5：</strong>如果对一棵有n个结点的完全二叉树的结点按<code>层序编号</code>（从第一层到最后一层，每层从左到右），对任一结点i（1≤i≤n）有：<ol><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲编号为 ⌊ i/2 ⌋ 。</li><li>如果2i&gt;n，则结点i无左右孩子（结点i为叶子结点）；否则其左孩子编号为 2i 。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则右孩子编号为 2i+1 。</li></ol></li></ul><h4>特殊二叉树:</h4><p><strong>1.斜树: </strong>左斜树 右斜树 结点个数与深度相同</p><p><strong>2.满二叉树: </strong>所有分支结点都存在左子树右子树 非叶子结点度数一定为2 深度为k(k≥1) 有2^(k)-1个结点</p><p><strong>3.完全二叉树: </strong>编号为i的结点与同样深度的满二叉树中编号为i的结点位置完全相同</p><p><img src="https://i.loli.net/2020/12/14/zlpoHNaALK6YGOw.png"></p><p><strong>完全二叉树就是除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点.</strong></p><p><strong>满二叉树一定是完全二叉树 完全二叉树不一定满</strong></p><h4>二叉树的遍历:</h4><ul><li><p>先序NLR</p><p><img src="https://i.loli.net/2020/12/15/ESZFVAXh7GsyHB6.gif" alt="先序"></p></li><li><p>中序LNR</p><p><img src="https://i.loli.net/2020/12/15/87S3i1rXVcsvxK4.gif" alt="中序"></p></li><li><p>后序LRN</p><p><img src="https://i.loli.net/2020/12/15/6X8MJ1DjoF5TKAv.gif" alt="后序"></p></li></ul><p><img src="https://i.loli.net/2020/12/14/rHIfCwJyQzclnmp.png" alt="example"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3_队列</title>
    <link href="/2020/12/14/3-%E9%98%9F%E5%88%97/"/>
    <url>/2020/12/14/3-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3>队列(Queue)---先进先出的线性表(First In First Out)</h3><img src="https://i.loli.net/2020/12/14/AlndLPCGHyRxYoa.png" alt="image.png" style="zoom:100%;" /><h4>0.特点:</h4><p>一端插入另一端删除</p><h4>1.顺序队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//顺序队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><br></code></pre></td></tr></table></figure><p><strong>1.1循环队列</strong></p><img src="https://i.loli.net/2020/12/14/MCPjGc8pWY13zKR.png" alt="image.png" style="zoom:100%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">引入循环队列:<br>区别队空队满方法:<br><span class="hljs-number">1.</span>牺牲一个存储空间<br>    <span class="hljs-number">2.</span>引入一个标志变量区别空余与不空<br>    <span class="hljs-number">3.</span>使用计数器<br> 牺牲一个存储空间<br>    (Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front;<span class="hljs-comment">//满队列条件</span><br>Q.rear=Q.front;<span class="hljs-comment">//空队列条件</span><br><span class="hljs-keyword">int</span> total=(Q.rear-Q.front+MAXSIZE)%MAXSIZE<span class="hljs-comment">//队列元素个数</span><br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//入队</span><br>Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//出队</span><br><span class="hljs-comment">//循环队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><span class="hljs-comment">//队列初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(sqQueue *Q)</span></span>&#123;<br>        Q.front=<span class="hljs-number">0</span>;<br>        Q.rear=<span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-comment">//入队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满!&quot;</span>);<br>        &#125;<br>        Q-&gt;data[Q-&gt;rear]=newValue;<span class="hljs-comment">//将值赋值给队尾</span><br>        Q-&gt;rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//尾指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//出队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *oldValue= Q-&gt;data[Q-&gt;front]; <span class="hljs-comment">//将队头元素赋值为oldValue</span><br>        Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//头指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//取队首元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getEle</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *myValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *myValue= Q-&gt;data[(Q-&gt;front+<span class="hljs-number">1</span>)%MAXSIZE];<br>        <br>    &#125;<br><br></code></pre></td></tr></table></figure><h4>2.链式队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链式队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span> <span class="hljs-comment">//结点结构</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>    &#125;QNode,*QueuePtr;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//队列链表结构</span><br>        QueuePtr front,rear;<span class="hljs-comment">//队头队尾指针</span><br>    &#125;LQueue;<br><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/SqC8izdylpIKvbf.png" alt="链式队列"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        QueuePtr temp = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow&quot;</span>);<span class="hljs-comment">//存储分配失败</span><br>        &#125;<br>        temp-&gt;data = e;<br>        temp-next = <span class="hljs-literal">NULL</span>;<br>        (Q-&gt;rear)-&gt;next = temp;<span class="hljs-comment">//新结点赋值给原队尾结点的后继</span><br>        Q-&gt;rear = temp;<span class="hljs-comment">//temp设置为尾结点 rear指向temp</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/Ly2lxoZ1SVNCrB4.png" alt="链式队列入队"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<br>        QueuePtr temp;<br>        <span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        temp=Q-&gt;front-&gt;next;<span class="hljs-comment">//队头结点赋值给temp</span><br>        *e=temp-&gt;data;<br>        Q-&gt;front-&gt;next=temp-&gt;next;<span class="hljs-comment">//原头结点后继temp-&gt;next赋值给头结点后继</span><br>        <span class="hljs-keyword">if</span>(Q-&gt;rear==temp)&#123;<span class="hljs-comment">//若队头是队尾 则删除后将rear指向头结点</span><br>            Q-&gt;rear=Q-&gt;front;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(temp);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2_栈</title>
    <link href="/2020/12/12/2-%E6%A0%88/"/>
    <url>/2020/12/12/2-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3>栈(Stack)---后进先出的线性表(Last In First Out)</h3><h4>1.顺序栈</h4><p>  栈空时 栈顶指针top==-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<br>        <span class="hljs-keyword">int</span> top; <span class="hljs-comment">//栈顶指针</span><br>    &#125;sqStack;<br><span class="hljs-comment">//栈的初始化 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(sqStack *s)</span></span>&#123;<br>        s-&gt;top=<span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//进栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s-&gt;top==MAXSIZE<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈满!&quot;</span>);<br>        &#125;<br>        s-&gt;top++; <span class="hljs-comment">//栈顶指针加一</span><br>        s-&gt;data[s-&gt;top]=newValue;<br>&#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br>*oldValue=s-&gt;data[s-&gt;top]; <span class="hljs-comment">//暂存被删除元素的值</span><br>s-&gt;top--; <span class="hljs-comment">//栈顶指针减一</span><br>&#125;<br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(sqStack s)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> topE=s-&gt;data [s-&gt;top];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素:%d&quot;</span>,topE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双栈情况:</strong></p><p>  双栈的两个栈底分别设置在数组的两端，栈顶分为是top1,top2</p><p>  两个栈顶在中间相遇，条件为 （top1+1=top2）发生上溢</p><p>  判断栈空条件: 一个是 top=0 另一个是top = maxsize -1 </p><h4>2.链栈</h4><p>(一个只能采用头插法插入或删除的链表)</p><p><img src="https://i.loli.net/2020/12/14/wd4CXlIvhELuSYt.png" alt="头插法"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span> *<span class="hljs-title">next</span>;</span><br>    &#125;linkStack;<br><span class="hljs-comment">//入栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(linkStack *top,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        linkStack *newNode=(linkStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linkStack));<br>        newNode-&gt;data=newValue;<br>        newNode-&gt;next=top;<br>        top=newNode;<span class="hljs-comment">//类比无头结点插入</span><br>    &#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断栈不为空</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            linkStack *oldNode=top;<span class="hljs-comment">//暂存栈顶元素</span><br>            top=top-&gt;next;<span class="hljs-comment">//弹出栈顶元素</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;弹出元素: %d&quot;</span>,oldNode-&gt;data);<br>            <span class="hljs-built_in">free</span>(oldNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//始终从同一个位置入栈出栈</span><br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(top==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素: %d&quot;</span>,top-&gt;data);<br>        &#125;<br>&#125;<br><span class="hljs-comment">//清空栈 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        linkStack *myNode;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            myNode=top;<br>            top=top-&gt;next;<br>            <span class="hljs-built_in">free</span>(myNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//求栈中元素个数 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            count++;<br>            top=top-&gt;next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>3.栈的应用</h4><p><strong>中缀表达式转后缀表达式</strong></p><p>​    首先将各种运算符（包括括号）的优先级排列如下（数字越大，优先级越高）：</p><p>​    1：（</p><p>​    2：+ -</p><p>​    3：* /</p><p>​    4：）</p><p>​    对输入的中缀表达式从左到右遍历：</p><p>​        1）如果遇到数字，直接添加到后缀表达式末尾；</p><p>​        2）如果遇到运算符+、-、*、/：</p><p>​            若栈空，则直接将此运算符压入栈。</p><p>​            若栈非空，则查看栈顶元素, 如果栈顶元素优先级&gt;=此操作符级别，则弹出栈顶元素，将元素添加到后缀表达式中，并继续进行上述判断。如果不满足上述判断或者栈为空，将这个运算符入栈。要注意的是，经过上述步骤，这个运算符最终一定会入栈。</p><p>​        3）如果遇到括号：</p><p>​            左括号直接入栈。</p><p>​            右括号，弹出栈中第一个左括号前所有的操作符，并将左括号弹出。（右括号不入栈）</p><p>​        4）字符串遍历结束后，如果栈不为空，则弹出栈中所有元素，将它们添加到后缀表达式的末尾，直到栈为空。</p><p><strong>后缀表达式求值:</strong></p><p>​    准备一个数字栈。从左到右扫描后缀表达式，如果是数字，放入数字栈。</p><p>​    如果是符号，从数字栈中弹出两个数字，第一个取出的数字为右运算数，第二个为左运算数，进行运算。然后将结果放进数字栈中。</p><p>​    如此反复，直到读完整个表达式后，留在数字栈中的那个数字就是最终结果。</p><p><strong>中缀表达式求值:</strong></p><p>  将前面的两步结合起来</p><p>  准备一个数字栈和一个符号栈。从左到右遍历中缀表达式。如果遇到数字，入数字栈。</p><p>  如果遇到符号（四个运算符以及括号），跟前面的“中缀表达式转后缀表达式”过程一样，对符号栈进行处理。处理过程中，对每一个出栈的运算符：+ - * /，根据“计算后缀表达式”的方法，计算结果（跟数字栈配合）。</p><p>  如果遍历完中缀表达式后符号栈还非空，就继续出符号栈的运算符，计算，直到符号栈为空。最后数字栈剩下的数字就是结果。</p><p>【参考资料】</p><p>[1] <a href="https://blog.csdn.net/sinat_27908213/article/details/80273557">https://blog.csdn.net/sinat_27908213/article/details/80273557</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1_线性表</title>
    <link href="/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4>线性表的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data[MAXSIZE];<br>    <span class="hljs-keyword">int</span> length;<br>&#125;sqList;<br><span class="hljs-comment">//取元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getElem</span><span class="hljs-params">(sqList L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//取第i个元素</span><br>        <span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>||i&lt;<span class="hljs-number">1</span>||i&gt;L.length)&#123;<span class="hljs-comment">//表空或者i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L.data[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//用指针存储</span><br>    &#125;<br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> e)</span></span>&#123; <span class="hljs-comment">//第i位插入e</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==MAXSIZE)&#123;<span class="hljs-comment">//顺序表满</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满无法插入&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;=L-&gt;length)&#123;<span class="hljs-comment">//可插入</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=L-&gt;length<span class="hljs-number">-1</span>;x&gt;=i<span class="hljs-number">-1</span>;x--)&#123;<span class="hljs-comment">//从第i到最后的元素都后移一位</span><br>                L-&gt;data[x+<span class="hljs-number">1</span>]=L-&gt;data[x]; <br>            &#125;<br>        &#125;<br>        L-&gt;data[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">//对第i位进行赋值</span><br>        L-&gt;length++;<span class="hljs-comment">//表长加一</span><br>    &#125;<br><span class="hljs-comment">//删除操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//删除第i位</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L-&gt;data[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(i&lt;L-&gt;length)&#123;<span class="hljs-comment">//如果删除的不是最后一个位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=i;x&lt;L-&gt;length;x++)&#123;<span class="hljs-comment">//被删除元素后的元素全部前移</span><br>                L-&gt;data[x<span class="hljs-number">-1</span>]=L-&gt;data[x];<br>            &#125;<br>        &#125;<br>         L-&gt;length--;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>线性表的链式存储</h4><p><strong>0.链表的特点</strong></p><p>(1)不要求用地址连续的存储空间在储，每个结点在运行时动态生成。结点的存储空间在物理位置上可以相邻，也可以不相邻;<br>(2)插入和删除操作不需要移动元素，只需修改指针，满足经常插入和删除结点的需求;<br>(3)链表不具备顺序表随机存取的优点﹔<br>(4)空间开销比较大，因链表结点增加了指示元素间关系的指针域<br>(5)链表是存储动态变化数据的理想选择。</p><p><strong>1.单链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//无头结点插入 新插入的x作为首元结点</span><br>    s-&gt;next=head;<br>head=s;<br><br> <span class="hljs-comment">//有头结点插入</span><br>s-&gt;next=head-&gt;next;<br>head-&gt;next=s;<br><span class="hljs-comment">//遍历traverse 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>        p=p-&gt;next;<br>        count++;<span class="hljs-comment">//用count求表长</span><br>    &#125;<br><span class="hljs-comment">//查找 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=theValue)&#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">else</span>&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position: %d&quot;</span>,count);<br>&#125;<br><span class="hljs-comment">//插入 </span><br>pre=head;<span class="hljs-comment">//在结点p之前插入</span><br><span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;pre-&gt;next!=p)&#123;<br>        pre=pre-&gt;next;<br>    &#125;<br><span class="hljs-keyword">if</span>(!pre)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p结点不存在!&quot;</span>);<br>    &#125;<br>Node *s=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>s-&gt;data=value;<br>s-&gt;next=pre-&gt;next;<br>pre-&gt;next=s;<span class="hljs-comment">//插入新结点</span><br><span class="hljs-comment">//删除</span><br>pre=head;<span class="hljs-comment">//删除第i个结点</span><br>count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(pre-&gt;next&amp;&amp;count&lt;i)&#123;<span class="hljs-comment">//找到第i-1个</span><br>        pre=pre-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;给出序号超出链表长度!&quot;</span>);<br>    &#125;<br>q=pre-&gt;next;<br>pre-&gt;next=q-&gt;next;<span class="hljs-comment">//删除</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放</span><br><span class="hljs-comment">//创建(头插法)</span><br><span class="hljs-comment">//创建(尾插法)</span><br><span class="hljs-comment">//逆置</span><br>Node *tmp,*p;<br>p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br>head-&gt;next=<span class="hljs-literal">NULL</span><span class="hljs-comment">//头结点指针置空 形成空链表</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        tmp=p-&gt;next;<span class="hljs-comment">//暂存p的后继</span><br>        p-&gt;next=head-&gt;next;<span class="hljs-comment">//p插入头结点后面</span><br>        head-&gt;next=p;<br>        p=tmp;<span class="hljs-comment">//继续处理下一个结点</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.双链表</strong></p><p><img src="https://i.loli.net/2020/12/12/b3M71k2lcBr5LN6.jpg" alt="插入"></p><p><img src="https://i.loli.net/2020/12/12/lpADuRx4MjfSGYi.jpg" alt="删除"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在p前插入s</span><br>s-&gt;prior=p-&gt;prior; <span class="hljs-comment">//1.p原先的前驱成为s的前驱</span><br>   p-&gt;prior-&gt;next=s; <span class="hljs-comment">//2.s成为p原先的前驱的后继</span><br>s-&gt;next=p;  <span class="hljs-comment">//3.s的后继是p</span><br>p-&gt;prior=s; <span class="hljs-comment">//4.修改p的前驱为s</span><br><span class="hljs-comment">//其中 4可以提前到3前 但不能到1,2前 否则会丢失结点</span><br><span class="hljs-comment">//删除p</span><br>p-&gt;prior-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=p-&gt;prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p><strong>3.单循环链表</strong> 往往不带头结点 往往只设尾指针</p><p><strong>4.双循环链表</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>0_绪论</title>
    <link href="/2020/12/12/0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/12/12/0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>​     <strong>数据(data)</strong>是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p>​     <strong>数据元素(data element)</strong>是数据的<u>基本单位</u>，在计算机程序中通常作为一个整体进行考虑和处理。</p><p>​     <strong>数据项(Data Item)</strong>数据项是数据的不可分割的<u>最小单位</u>。</p><p>​     <strong>数据对象(data object)</strong>是性质相同的数据元素的<u>集合</u>，是数据的一个子集。</p><p><img src="https://i.loli.net/2020/12/11/XLBtmuz6pUNMwK5.jpg"></p><p>​     <strong>如图: 数据对象由若干数据元素组成，数据元素由若干数据项组成</strong></p><p>​     <strong>数据结构(data structure)</strong>又称逻辑结构，是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下四类基本结构：<u>集合</u>、<u>线性结构</u>、<u>树形结构</u>、<u>图状结构</u>。</p><p>​     <strong>存储结构（物理结构）</strong>是数据结构在计算机中的表示（又称映像）。表示数据元素之间的关联方式有:  <u>顺序存储方式</u>、<u>链式存储方式</u>、索引存储方式、散列存储方式</p><p>​     <strong>数据类型(data type)</strong>是一个值的集合和定义在这个值集上的一组操作的总称。</p><p>​     <strong>抽象数据类型(AbstractData Type)</strong>是指一个数学模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。</p><p>​     评价<strong>算法的好坏</strong>有四个方面的因素: <u>1.正确性</u> <u>2.易读性</u> <u>3.健壮性</u> <u>4.时空性</u></p><p>​     <strong>时间复杂度</strong>的计算: 找出基本操作, 估算算法的计算量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/10/Hello-World/"/>
    <url>/2020/12/10/Hello-World/</url>
    
    <content type="html"><![CDATA[<p>Hiii! This is my first blog, can’t wait to share my tech ideas with u guys!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
