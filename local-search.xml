<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>chap6查找复习题</title>
    <link href="/2020/12/22/chap6%E6%9F%A5%E6%89%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap6%E6%9F%A5%E6%89%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>在表长为ｎ的链表中进行顺序查找，等概率情况下查找成功的ASL为（ <strong>(n+1)/2</strong> ）</p></li><li><p>折半查找有序表（4，6，10，12，20，30，50，70，88，100），若查找元素58，则它将依次与表中（ <strong>20，70，30，50</strong>  ）比较大小，查找结果是失败</p></li><li><p>对22个记录的有序表作折半查找，查找失败时，至少需要比较（ 4 ）次关键字</p><p><code>其折半查找的判定树深度为 log2(22) + 1=5，且该判定树不是满二叉树，即查找失败时至多比较 5 次，至少比较 4 次</code></p></li><li><p>链表适用于（ <strong>顺序</strong> ）查找</p></li><li><p>设哈希表长为14，哈希函数是H(key)=key%11，表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的结点加到表中，用二次探测再散列法解决冲突，则放入的位置是(  9 ) </p><p><code>49%11=5被占用了（5+1^2）%11=6还是被占用了</code></p><p><code>（5-1^2）%11=4被占用了（5+2^2）%11=9未被占用，所以在9的位置放入49</code></p></li><li><p>适用于折半查找的表的存储方式及元素排列要求为( <strong>顺序方式存储，元素有序</strong> )</p></li><li><p>对长度为3的顺序表做顺序查找，若查找第1个元素的概率为1/2.，查找第2个元素的概率为1/3，查找第3个元素的概率为1/6，则成功查找表中任一元素的平均查找长度为（ 5/3 ）</p><p><code>求期望</code></p></li><li><p>一个哈希表中有n个元素，用哈希法进行查找的平均查找长度为（ <strong>O(1)</strong> ）</p></li><li><p>设哈希表的长度为m，采用除留余数法：H(key)=key % p，一般选择p为（ <strong>小于或等于m的最大质数</strong>  ）</p></li><li><p>哈希表的平均查找长度（ <strong>与处理冲突的方法有关而与表的长度无关</strong> ）</p></li></ol><h4>二、填空题</h4><ol><li><p>在数据的存放<strong>无规律的线性表</strong>中进行检索的最佳方法是 <strong><u>顺序查找</u></strong> </p></li><li><p>折半查找有序表（4，6，12，20，28，38，50，70，88，100），若查找表中元素20，它将依次与表中元素  <u>28，6，12，20</u> 比较大小。</p></li><li><p>线性有序表（a1，a2，a3，…，a256)是从小到大排列的，对一个给定的值k，用二分法检索表中与k相等的元素，在查找不成功的情况下，最多需要检索 <u>8</u> 次。设有100个结点，用二分法查找时，最大比较次数是  <u>7</u></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">100</span>/<span class="hljs-number">2</span>  取<span class="hljs-number">50</span> 一次 <br><span class="hljs-attribute">50</span>/<span class="hljs-number">2</span>  取<span class="hljs-number">25</span> 二次<br><span class="hljs-attribute">25</span>/<span class="hljs-number">2</span>  取<span class="hljs-number">13</span> 三次<br><span class="hljs-attribute">13</span>/<span class="hljs-number">2</span> 取<span class="hljs-number">7</span> 四次<br><span class="hljs-attribute">7</span>/<span class="hljs-number">2</span> 取 <span class="hljs-number">4</span> 五次<br><span class="hljs-attribute">4</span>/<span class="hljs-number">2</span> 取<span class="hljs-number">2</span> 六次<br><span class="hljs-attribute">2</span>再来个二分必出结果  七次<br></code></pre></td></tr></table></figure></li><li><p>在各种查找方法中，平均查找长度与记录个数n无关的查找方法是 <strong><u>哈希查找</u></strong></p></li><li><p>哈希法存储的基本思想是由   <strong><u>关键字的值</u></strong> 决定数据的存储地址</p></li><li><p>有一个表长为m的散列表，初始状态为空，现将n（n&lt;m）个不同的关键码插入到散列表中，解决冲突的方法是用线性探测法。如果这n个关键码的散列地址都相同，则探测的总次数是        <u>n(n-1)/2</u> (而任一元素查找次数 ≤n-1)</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">插入第一个关键码时，检查<span class="hljs-symbol">x</span>位置，结果为空，直接插入，探测次数为<span class="hljs-number">0</span>；<br>插入第二个关键码时，检查<span class="hljs-symbol">x</span>位置，结果不为空，采用线性探测法，继续探测<span class="hljs-symbol">x</span>+<span class="hljs-number">1</span>位置，结果为空，插入，探测次数为<span class="hljs-number">1</span>；<br>……<br>插入第n个关键码时，<span class="hljs-symbol">x</span>位置不为空，从<span class="hljs-symbol">x</span>+<span class="hljs-number">1</span>位置开始探测，直至探测到<span class="hljs-symbol">x</span>+(n<span class="hljs-number">-1</span>)位置时才为空（这里假设<span class="hljs-symbol">x</span>+(n<span class="hljs-number">-1</span>)&lt;m），执行插入操作，探测次数为n<span class="hljs-number">-1</span>次。<br>所以，总的探测次数是一个等差数列<br></code></pre></td></tr></table></figure></li></ol><h4>三、判断题</h4><ol><li><p>有n个数存放在一维数组中，在进行顺序查找时，这n个数的排列有序或无序其平均查找长度不是<del>不同</del>。</p><p><code>平均查找长度是指：等概率下依次查找所有元素的比较次数。</code></p><p><code>所以无论有序无序，平均长度=(1+2+3+4+...+n )/ n，只与元素个数有关</code></p></li><li><p>折半查找的效率不是<del>肯定高于</del>顺序查找</p></li><li><p>在二叉排序树中插入一个新结点，该新结点<strong>肯定是叶子结点</strong>。</p></li><li><p>一棵二叉排序树的先序遍历序列正好是待排序数据的非递减序列</p><p><code>任一结点的键值大于其左孩子(及其子孙)的键值且小于其右孩子(及其子孙)的键值。</code></p><p><code>因此，中序LNR遍历一棵二叉排序树所得的结点访问序列是键值的递增序列。</code></p></li><li><p>n个结点的二叉排序树有多种，其中<strong>树的高度最小的二叉排序树是最佳的</strong>。</p></li><li><p>哈希函数的选择<strong>原则之一是函数比较简单且能在较短时间内计算出结果</strong>。</p></li><li><p>在哈希检索中，“比较”操作一般不<del>是不可避免的</del>。（  ）</p></li><li><p>哈希函数不是<del>越复杂越好，因为这样随机性好，冲突概率小。</del>哈希函数越复杂，则时间就会越多</p></li></ol><h4>四、计算题</h4><ol><li>画出对长度为10的有序表进行折半查找的判定树，并求其等概率时查找成功的平均查找长度。</li></ol><p>​     <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521091807507_243FFB1D3538098C4D8461885A5761FE"></p><ol start="2"><li>在一 棵空的二叉排序树中依次插入关键字序列为12，7，17，11，16，2，13，9，21，4，请画出所得到的二叉排序树。</li></ol><p>​     <img src="https://uploadfiles.nowcoder.com/images/20170304/5437584_1488613304796_072774B6B658B3603E1AA7198722775C"></p><ol start="3"><li><p>已知长度为12的表：（Jan, Feb, Mar, Apr, May, June, July, Aug, Sep, Oct, Nov, Dec）</p><p>(1)  试按表中元素的顺序依次插入一棵初始为空的二叉排序树，画出插入完成之后的二叉排序树，并求其在等概率的情况下查找成功的平均查找长度。</p><p>(2)  若对表中元素先进行排序构成有序表，求在等概率的情况下对此有序表进行折半查找时查找成功的平均查找长度。</p><p>(3)  按表中元素顺序构造一棵平衡二叉排序树，并求其在等概率的情况下查找成功的平均查找长度。</p></li></ol><p>​      <img src="https://i.loli.net/2020/12/22/omfLEDeZBFpQSXt.png"></p><ol start="4"><li><p>假定对有序表：（3，4，5，7，24，30，42，54,  63，72，87，95）进行折半查找，回答下列问题：</p><p>（1）画出描述折半查找过程的判定树；</p><p>（2）若查找元素54，需依次与哪些元素比较？</p><p>（3）若查找元素90，需依次与哪些元素比较？</p><p>（4）假定每个元素的查找概率相等，求查找成功时的平均查找长度。<img src="https://i.loli.net/2020/12/22/WdItqr4x1oe3ZmC.png"></p></li><li><p>选取散列函数H（key）=（3*key）%11，用线性探测法处理冲突，对下列关键码序列{22，41，53，8，46，30，1，31，66}构造一个哈希地址空间为0～10，表长为11的哈希表，。</p></li></ol><p><img src="https://i.loli.net/2020/12/22/N3PCxDWUGbhAwH4.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap5图复习题</title>
    <link href="/2020/12/22/chap5%E5%9B%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap5%E5%9B%BE%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>在一个图中，所有顶点的度数之和等于图的边数的（ <strong>2</strong> ）倍 <code>握手定理</code></p></li><li><p>在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（ <strong>1</strong> ）倍  <code>握手定理</code></p></li><li><p>有8个结点的无向图最多有（  28 ）条边 <code>无向完全图, 边数最多为 n(n-1) / 2</code></p></li><li><p>有8个结点的无向连通图最少有（  7 ）条边 <code>生成树</code></p></li><li><p>有8个结点的有向完全图有（  56 ）条边<code>有向完全图, 边数最多为 n(n-1)</code></p></li><li><p>用邻接表表示图进行广度优先遍历时，通常是采用（ <strong>队列</strong> ）来实现算法的。</p></li><li><p>用邻接表表示图进行深度优先遍历时，通常是采用（ <strong>栈</strong> ）来实现算法的。           </p></li><li><p>矩阵如下，根据深度优先搜索算法，从顶点0出发的遍历序列是（ 0423165 或0134256 ）</p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492275499282_09A1B17F411ECE39BF54DF820D121458"></p><img src="https://uploadfiles.nowcoder.com/images/20190327/466357877_1553651974781_ACED241801E307EE7A39612F85A94EBF" style="zoom:33%;" /><ol start="9"><li><p>图的邻接矩阵同题8，根据广度优先搜索算法，从顶点0出发的遍历序列是（ 0 1 2 3 4 6 5  ）</p></li><li><p>如果从无向图的任一顶点出发进行一次深度优先遍历就能访问图中所有顶点，则该图一定是（  <strong>连通图</strong>  ）。</p></li><li><p>在一个带权连通图G中，权值最小的边一定包含在G的（ <strong>最小</strong> ）生成树中 <code>最小生成树性质</code></p></li><li><p>用邻接表存储图所用空间的大小（  <strong>与图的顶点数和边数都有关</strong> ）。</p></li><li><p>具有n个顶点的连通无向图，其边的个数至少为（ n-1 ）<code>生成树</code></p></li><li><p>已知图的邻接表如下，根据深度优先搜索算法，从顶点0出发的遍历序列是（  0 1 2 3  ）</p><p><code>深度优先遍历 相当于树的先序遍历, 通常借助栈实现. 先进后出</code></p></li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492275927189_558B658E00BC3736CC3E5F6683BA1EF4"></p><ol start="15"><li><p>已知图的邻接表如下，根据广度优先搜索算法，从顶点0出发的遍历序列是（ 0 3 2 1 ）   </p><p><code>广度优先遍历，相当于树的层序遍历，通常借助队列(先进先出)实现算法。题中从0出发，即0入队，邻接表访问顺序为3，2，1，则入队顺序也为3，2，1</code></p></li></ol><img src="https://iknow-pic.cdn.bcebos.com/5882b2b7d0a20cf46b8bdc1576094b36adaf99e4" style="zoom: 50%;" /><ol start="16"><li><p><strong>深度</strong>优先遍历类似于二叉树的（  <strong>先序遍历</strong> ）</p></li><li><p><strong>广度</strong>优先遍历类似于二叉树的（  <strong>层次遍历</strong> ）</p></li></ol><h4>二、填空题</h4><ol><li><p>图的存储结构最常用的有 <strong><u>邻接矩阵</u></strong> 、<strong><u>邻接表</u></strong> </p><p>遍历图的方法有： <strong><u>深度优先遍历</u></strong> 、 <strong><u>广度优先遍历</u></strong> 等</p></li><li><p>有向图G用邻接表矩阵存储，其第i行的所有元素之和等于顶点i的  <strong><u>出度</u></strong>  </p></li><li><p>如果n个顶点的图是一个环，则它有  <strong><u>n</u></strong>  棵生成树  </p><p><code>n个顶点形成的环有n条边，若得到生成树只需要删除这n条边中的任意一条即可，所以得到n棵生成树</code></p></li><li><p>n个顶点e条边的图，若采用邻接矩阵存储，则空间复杂度为  <strong><u>O(n^2)</u></strong>  </p><p><code>采用邻接矩阵存储，则不论&lt;Vi，Vj&gt;是否有路径，每条边都会遍历到。矩阵大小n*n，即时间复杂度O(n^2)</code></p></li><li><p>n个顶点e条边的图，若采用邻接表存储，则空间复杂度为  <strong><u>O(n+e)</u></strong> </p><p><code>采用邻接表存储，每个结点访问一次，每条有路径的边访问一次，则时间复杂度O(n+e)</code></p></li><li><p>设有一稀疏图G，则G采用 <strong><u>邻接表</u></strong>  存储较省空间</p></li><li><p>设有一稠密图G，则G采用 <strong><u>邻接矩阵</u></strong>  存储较省空间</p></li><li><p>图的逆邻接表存储结构只适用于 <strong><u>有向图</u></strong></p></li><li><p>图的深度优先遍历序列 <strong><u>不是</u></strong> 唯一的</p></li><li><p>n个顶点e条边的图采用邻接矩阵存储，<strong>深度</strong>优先遍历算法的时间复杂度为 <strong><u>O(n^2)</u></strong> ；</p><p>若采用邻接表存储时，该算法的时间复杂度为  <strong><u>O(n+e)</u></strong> </p></li><li><p>n个顶点e条边的图采用邻接矩阵存储，<strong>广度</strong>优先遍历算法的时间复杂度为  <strong><u>O(n^2)</u></strong>；</p><p>若采用邻接表存储，该算法的时间复杂度为  <strong><u>O(n+e)</u></strong> </p></li><li><p>Prim算法求具有n个顶点e条边的图的最小生成树的时间复杂度为 <strong><u>O(n^2)</u></strong> ；用克鲁斯卡尔(Kruskal)算法的时间复杂度是 <strong><u>O(elog2e)</u></strong> 。</p></li><li><p>若要求一个稀疏图G的最小生成树，最好用 <strong><u>克鲁斯卡尔(Kruskal)</u></strong> 算法来求解。</p></li><li><p>若要求一个稠密图G的最小生成树，最好用 <strong><u>普里姆(Prim)</u></strong>  算法来求解。</p></li><li><p>用Dijkstra算法求某一顶点到其余各顶点间的最短路径是按路径长度  <strong><u>递增</u></strong>  的次序来得到最短路径的</p></li><li><p>求最短路径的Dijkstra算法的时间复杂度是  <strong><u>O(n^2)</u></strong>  </p></li><li><p>拓扑排序算法是通过重复选择具有  <strong><u>0</u></strong>  个前驱顶点的过程来完成的</p></li></ol><h4>三、判断题</h4><ol><li><p>一个图的邻接矩阵表示是唯一的，邻接表表示不<del>是唯一的</del>。 </p><p><code>邻接表每个节点后面连接的节点顺序随意</code></p></li><li><p>有向图用邻接矩阵存储，顶点i的<del>入度</del>等于矩阵中第i行非零元素个数之和。<code>行对应入度</code></p></li><li><p>若一个图的邻接矩阵不是对称矩阵，则该图一定是有向图。</p></li><li><p>一个无向图的邻接矩阵一定是对称矩阵。</p></li><li><p>图的简单路径是指顶点和<del>边</del>都不重复的路径。<code>只有顶点不重复!!</code></p></li><li><p>连通图的生成树是一个极小连通子图。</p></li><li><p>一个连通图的生成树是一个极小连通子图，它含有图中的全部定点，但只有足以构成树的n-1条边，且生成树不唯一。</p></li><li><p>对于非连通的无向图进行深度优先搜索可以得到一个生成森林。</p></li><li><p>BFS生成树的高度不<del>一定小于</del>DFS生成树的高度。</p><p><code>树高的话，可以理解为顶点到结点的距离</code></p><p><code>对于 BFS生成树  每个结点到根结点都是最短距离, 而DFS没有这个限制</code></p><p><code>因此，DFS生成树的树高&gt;= BFS生成树的树高 (一个顶点的图相等)</code></p></li><li><p>拓扑排序可以判断一个有向图是否存在回路。</p><p><code>DFS搜索可以通过测试生成树是否有背边来判断是否有环</code></p><p><code>拓扑排序的，如果有环的话，则没有处理完所有的节点，栈或者队列就已经空了</code></p></li></ol><h4>四、简答题</h4><ol><li><p>表示有50个顶点、15条边的有向图的邻接矩阵有多少个矩阵元素？该矩阵是否是稀疏矩阵？</p><p>50*50=2500 有2500个矩阵元素，15/2500=0.006&lt;0.05 该矩阵是稀疏矩阵</p></li><li><p>有n个顶点的<strong>无向图</strong>最多有几条边，最少有几条边；如果该图是连通图，则该图最多有几条边，最少有几条边？</p><p>无向图最多有n(n-1)/2边，最少有0条边。</p><p>无向连通图最多有n(n-1)/2边，最少有n-1条边。</p></li><li><p>有n个顶点的<strong>有向图</strong>最多有几条边，最少有几条边；如果该图是强连通图，则该图最多有几条边，最少有几条边？</p><p>有向图最多有n(n-1)边，最少有0条边。</p><p>强连通图最多有n(n-1)边，最少有n条边。</p></li><li><p>对下面所示的有向图，请回答：该图是强连通图吗？若不是，请画出其强连通分量。</p><p><img src="https://i.loli.net/2020/12/21/T3sWQukIhPZcdSg.png"></p><p>该图不是强连通图。有6个强连通分量，即各个顶点。</p></li></ol><h4>五、应用题</h4><ol><li>已知如图所示的有向图，请给出该图的:                                                                                                                                               </li></ol><p><img src="https://i.loli.net/2020/12/21/1ojnQyYFRDVuWEi.png"></p><p>（1） 每个顶点的入/出度；</p><p>  ID(1)=3    OD(1)=0 </p><p>  ID(2)=2    OD(2)=2 </p><p>  ID(3)=1    OD(3)=2 </p><p>  ID(4)=1    OD(4)=3 </p><p>  ID(5)=2    OD(5)=1 </p><p>  ID(6)=2    OD(6)=3</p><p>（2）邻接矩阵</p><p>  0  0  0  0  0  0 </p><p>  1  0  0  1  0  0 </p><p>  0  1  0  0  0  1 </p><p>  0  0  1  0  1  1 </p><p>  1  0  0  0  0  0 </p><p>  1  1  0  0  1  0</p><p>（3）  邻接表  <code>出度</code></p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521086932795_A452989AA861993B1F6D4CE6396C8CE2"></p><p>（4）  逆邻接表 <code>入度</code></p><p>​                                           <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521086943162_417CEE45EB97602D1D4FC1429A18A0FD"></p><ol start="2"><li>请对下图的无向带权图：</li></ol><p>（1）  写出它的邻接矩阵，按普里姆算法求其最小生成树；</p><p>（2）  写出它的邻接表，按克鲁斯卡尔算法求其最小生成树。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087479012_6CE28496EAA7968C3C38F82FBC2CD075"></p><p><strong>按普里姆算法求最小生成树：设起点为a，当多条边权值相同时，选择编号最小的顶点 </strong></p><p><strong>按克鲁斯卡尔算法求最小生成树，当多条边权值相同时，选择编号最小的顶点</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087483662_AF8DF9DA070E8B3E1AC54D28C9C14BC9"></p><p>3.已知二维数组表示的图的邻接矩阵如下图所示。试分别画出自顶点1出发进行遍历所得的深度优先生成树和广度优先生成树。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087313183_BED18D4C133F07F79E60B9CD2FF5DBB0"></p><p>​                              <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087320400_CB22EA229F451D9F806696F0C6A7598F"></p><p>4.试利用Dijkstra算法求图中从顶点a到其他各顶点间的最短路径，写出执行算法过程中各步的状态。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521088547962_BDE791E8999B948575588967608A9215"></p><p> <img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521088528706_3D342AF356857AE11EDDBD81CBB6EEC5"></p><ol start="5"><li>给定下列网G: </li></ol><p>(1) 试着找出网G的最小生成树，画出其逻辑结构图；</p><p>(2) 用两种不同的表示法画出网G的存储结构图；</p><p>(3) 用C语言（或其他算法语言）定义其中一种表示法（存储结构）的数据类型。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342672256_424F704615EDB69A73B0429C42ACF599"></p><p>1）<br><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342763225_A466F9E5793528FDD92ABCE4DC6DA8DC"><br>（2）邻接矩阵：<br><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342824956_581E2A3C4CEED6F16D58A0F18B7CCEDC"><br>邻接表：<br><img src="https://uploadfiles.nowcoder.com/images/20170416/5437584_1492342836488_E39B6FABFA0A76274B20BD223FA85EE8"></p><p>(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INFINITY INT_MAX<span class="hljs-comment">//最大值∞</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VERTEX_NUM 20<span class="hljs-comment">//假设的最大顶点数(可取为 7)</span></span><br>Typedef <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    DG, DN, AG,AN <br>&#125;GraphKind; <span class="hljs-comment">//有向/无向图,有向/无向网 </span><br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">ArcCell</span>&#123;</span>          <span class="hljs-comment">//弧(边)结点的定义</span><br>VRType adj;   <span class="hljs-comment">//顶点间关系,无权图取 1 或 0;  有权图取权值类型</span><br>InfoType *info;  <span class="hljs-comment">//该弧相关信息的指针</span><br>&#125;ArcCell, AdjMatrix [ MAX_VERTEX_NUM ] [MAX_VERTEX_NUM ];<br>Typedef <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>       <span class="hljs-comment">//圈的定义</span><br>VertexType vexs[MAX_VERTEX_NUM];   <span class="hljs-comment">//顶点表，用一维向量即可</span><br>AdiMatrix arcs;    <span class="hljs-comment">//邻接矩阵</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap4树和二叉树复习题</title>
    <link href="/2020/12/22/chap4%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap4%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>不含任何结点的空树（ <strong>是一棵树也是一棵二叉树</strong> ）</p></li><li><p>一棵有n个结点的树的所有结点的度数之和为（  <strong>n-1</strong> ）<code>特值法 取n=1</code></p></li><li><p>在二叉树中某一个结点的深度为3，高度为4，则该树的高度是（ 6 ）</p><p><code>深度和高度是相对于两个相反方向的 高度是从下往上</code></p></li><li><p>设高度为h的二叉树中只有度为0和度为2的结点，则该树的结点数<strong>至多</strong>为（ <strong>2^h-1</strong> ）</p></li><li><p>设高度为h的二叉树中只有度为0和度为2的结点，则该树的结点数<strong>至少</strong>为（ <strong>2h-1</strong> ）</p><p><img src="https://i.loli.net/2020/12/20/fsDCwEPT64l1xHq.png"></p></li><li><p>高度为h的满二叉树中有n个结点，其中有m个叶结点，则正确的等式是（  <strong>n=2h-1</strong> ）</p><p><code>这种题不要只代一组数 容易出错!!</code></p></li><li><p>二叉树是非线性数据结构，所以（ <strong>顺序存储结构和链式存储结构都能存储</strong>  ）</p></li><li><p>一棵完全二叉树有25个叶结点，则该树最少有（ 49 ）个结点  (前5行满(1,2,4,8,16) 第6行有18个叶子)</p></li><li><p>假设一个三叉树的结点数为36，则该树的最小高度为（ 4 ）<code>满树的情况下</code></p></li><li><p>设二叉树有n个结点，则二叉链表中<strong>非空指针</strong>数为（ <strong>n-1</strong> ）</p><p><code>在有N个结点的二叉链表中必定有2N个链域--左右指针</code></p><p><code>除根结点外，其余N-1个结点都有一个父结点</code></p><p><code>所以，一共有N-1个非空链域，其余2N-（N-1）=N+1个为空链域</code></p></li><li><p>先序序列和中序序列正好相反的二叉树是（ <strong>左单枝树</strong> ）</p></li><li><p>后序序列和中序序列正好相反的二叉树是（ <strong>右单枝树</strong> ）</p></li><li><p>把一棵树转换为二叉树后，这棵二叉树的形态是（ <strong>唯一的</strong> ）</p></li><li><p>将一棵树T转换为孩子—兄弟链表表示的二叉树H，则T的后根序遍历是H 的（ <strong>中序遍历</strong> ）</p><img src="http://uploadfiles.nowcoder.com/images/20150905/710976_1441459044912_ACED241801E307EE7A39612F85A94EBF" style="zoom: 67%;" /><p><code>树转化为二叉树 先序遍历对应二叉树的先序遍历 后序遍历对应二叉树的中序遍历</code></p></li></ol><h4>二、填空题</h4><ol><li><p>在一棵有n个结点的二叉树中，若度为2的结点数为n2，度为1的结点数为n1，度为0的结点数为n0，则该树可能出现的最大高度是 <strong><u>n</u></strong> ，其叶结点数为 <strong><u>1</u></strong>  ，而该树可能出现的最小高度是 <img src="https://i.loli.net/2020/12/20/l5t317YzxavjkAw.png"> ，其叶结点数为 <strong><u>n2+1</u></strong>  。</p><p><code>最大高度 单枝树    最小高度 满二叉树</code></p></li><li><p>一棵完全二叉树有12个叶结点，则该树最多有  <u>24</u>  个结点。</p><p><code>计算：n0=1 叶子结点是双分支节点数加1 n2=n0-1=11 单分支节点数为1或者0，最多则选择1 n=n0+n2+1=12+11+1=24</code></p></li><li><p>已知二叉树的先序序列为ABDCEF，中序序列为DBAECF，则该树的后序序列为<u>DBEFCA</u></p></li></ol><img src="https://i.loli.net/2020/12/20/UoHlrTGZ4stphwd.jpg" style="zoom: 12%;" /><ol start="4"><li><p>二叉树的层次遍历需要使用  <strong><u>队列</u></strong>  辅助才能实现。 </p></li><li><p>设二叉树有n个结点，则二叉链表中<strong>空指针</strong>数为 <strong><u>n+1</u></strong></p></li><li><p>由3个结点所构成的二叉树有  <u>5</u>种形态</p><p><code>h(n)=C(2n,n)/(n+1) (n=1,2,3,...)</code></p></li><li><p>一棵深度为6的满二叉树有 <u> 31</u>  个分支结点和 <u>32</u> 个叶子。</p><p><code>满二叉树没有度为1的结点，分支结点数就是度为2的结点数 即1+2+4+8+16</code> </p></li><li><p>一棵具有257个结点的完全二叉树，它的深度为  <u>9</u>  </p><p><code>含有n个结点的完全二叉树的深度为 log2(n +1) </code></p></li><li><p>设一棵完全二叉树有700个结点，则共有  <u>350</u> 个叶子结点。</p><p><code>完全二叉树n=n0+n2+1 n2=n0-1</code></p></li><li><p>设一棵完全二叉树具有1000个结点，则此完全二叉树有 <u>500</u> 个叶子结点，有 <u>499</u>  个度为2的结点，有  <u>1</u>  个结点只有非空左子树，有 <u>0</u> 个结点只有非空右子树。</p></li><li><p>一棵有n(n&gt;1)个结点的k叉树，可能的最大深度为 <strong><u>n</u></strong> ，可能的最小深度为  <strong><u>2</u></strong>  。</p></li></ol><h4>三、判断题</h4><ol><li><p>满二叉树是完全二叉树</p></li><li><p>二叉树的先序序列和中序序列可以唯一确定此二叉树</p></li><li><p>Huffman树中包括度为0、度为1和<del>度为2</del>的结点 (只有01结点)</p></li><li><p>若二叉树用二叉链表存储，则n个结点的二叉链表中有n-1个非空指针域</p></li><li><p>二叉树中每个结点的两棵子树的高度差不一定<del>等于1</del></p></li><li><p>二叉树中每个结点的两棵子树是有序的 </p></li><li><p>二叉树中每个结点不一定<del>有两棵非空子树或有两棵空子树</del></p></li><li><p>二叉树中所有结点个数是<del>2^(k-1)-1</del>，其中k是树的深度<img src="https://i.loli.net/2020/12/20/ltiqNUTsKXZDkHg.png"></p></li><li><p>二叉树中所有结点，如果不存在非空左子树，<del>则不存在非空右子树</del><img src="https://i.loli.net/2020/12/20/jmMHcivwAZJxCE3.png"></p></li><li><p>对于一棵非空二叉树，根结点为第1层，则第i层上最多能有<del>2^i -1个结点</del>  应该是2^(i-1)个</p></li><li><p>用二叉链表法（link-rlink）存储包含n个结点的二叉树，结点的2n个指针区域中有n+1个为空指针</p></li><li><p>具有12个结点的完全二叉树有5个度为2的结点</p></li></ol><h4>四、应用题</h4><ol><li><p>在一棵度为4的树中，有20个度为4的结点， 10个度为3的结点， 1个度为2的结点，10个度为1的结点，请计算树中度为0的结点个数。</p><p><strong>任何一棵树中，结点个数比分支个数多一</strong> </p><p>分支个数等于20*4+10 *3+1 *2+10 *1=122 </p><p>所以这棵树一共有123个结点 </p><p>度不为零的结点数目为20+10+1+10=41 </p><p>所以叶子结点也就是度为零的结点个数为123-41=82</p></li><li><p>一棵二叉树有1024个结点，其中有叶子结点465个，计算树中度为2和度为1的结点各有多少个</p><p>因n0=n2+1，所以n2=465-1=464，n1=1024-465-464=95</p></li><li><p>请画出一棵先序序列和中序序列相同的二叉树（注：空树和只有根结点的树除外）</p><p><u>右单枝树</u>的先序序列与中序序列相同</p></li><li><p>已知二叉树的层次遍历序列为ABCDEFG，中序序列为DBFEGAC，请画出该树。</p><p><img src="https://i.loli.net/2020/12/21/1TEGVRBZctfWuIX.gif"></p></li><li><p>给定如图所示二叉树T，请画出与其对应的中序线索二叉树。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170415/5437584_1492271590744_CCC6F71D85A05E24BA5EA3BDC35B34BF"></p><p>要遵循中序遍历的轨迹来画出每个前驱和后继。</p><p>中序遍历序列：55 40 25 60 28 08 33 54</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">线索二叉树就是对这个序列中每个数判断其有没有左右子树<br>没有左子树就加前驱<span class="hljs-punctuation">,</span> 没有右子树就加后继 <br>序列中首元素左子树指空 序列中尾元素右子树指空<br>感谢<span class="hljs-keyword">c</span>佬的指导qaq<br></code></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/images/20170415/5437584_1492271737042_CFC9E40405E371BC3173FCF74DB8B357"></p></li><li><p>试写出如图所示的二叉树分别按先序、中序、后序遍历时得到的结点序列。</p><img src="https://i.loli.net/2020/12/21/D2ELYVFybfKS4wk.png" style="zoom:67%;" /><p>​    DLR：A B D F J G K C E H I L M</p><p>​    LDR:  B F J D G K A C H E L I M</p><p>​    LRD：J F K G D B H L M I E C A</p></li><li><p>把如图所示的树转化成二叉树。</p></li></ol><p><img src="https://i.loli.net/2020/12/21/WwD49Aid6gjaYLv.png"></p><p>​                                             <img src="https://i.loli.net/2020/12/21/4SsVBxGmIFnzC3H.png"></p><p>​        </p>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap3栈和队列复习题</title>
    <link href="/2020/12/22/chap3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>栈中元素的进出原则是(  <strong>后进先出</strong> )</p></li><li><p>已知一个栈的进栈序列为1, 2, …, n，其输出序列是p1, p2, … , pn ，若p1=n，则pi=（ <strong>n-i+1</strong> ）</p></li><li><p>一个栈的输入序列为：a b c d e，则下列不可能是栈的输出序列的是（ <strong>e d a c b</strong> ）</p><p><strong>规律：某数a右侧比a小的数构成的子列必须严格降序</strong></p></li><li><p>判定一个栈ST（ 最多元素为m0 ）为空的条件是( <strong>ST-&gt;top=0 </strong>)</p></li><li><p>判定一个队列QU（最多元素为m0）为满队列的条件是( <strong>QU-&gt;rear-QU-&gt;front == m0</strong> )</p></li><li><p>数组Q[n]用来表示一个循环队列，f为当前队列头元素的前一位置，r为队尾元素的位置，假定队列中元素的个数小于n，计算队列中元素的公式为( <strong>（n＋r－f）% n </strong>)</p></li><li><p>栈和队列的共同点是（ <strong>只允许在端点处插入和删除元素</strong> ）。</p></li><li><p>用单链表表示的链式队列的队头在链表的（  <strong>表头</strong>  ）位置。</p></li><li><p>设计一个判别表达式中左，右括号是否配对出现的算法，采用（ <strong>栈</strong> ）结构最佳。</p></li><li><p>用不带头结点的单链表存储队列时,其队头指针指向队头结点,其队尾指针指向队尾结点，则在进行删除操作时( <strong>队头,队尾指针都可能要修改</strong> )。 </p></li><li><p>设循环队列Q的最大长度为m，rear为尾指针，则入队时的操作为（ <strong>Q.rear=(Q.rear+1) % m</strong> ）。</p></li></ol><h4>二、填空题</h4><ol><li><p>栈和队列都是 <strong><u>线性</u></strong>  结构，对于栈只能在 <strong><u>栈顶</u></strong> 插入和删除元素；对于队列只能在 <strong><u>队尾</u></strong> 插入和 <strong><u>队首</u></strong> 删除元素。</p></li><li><p>栈是一种特殊的线性表，允许插入和删除运算的一端称为 <strong><u>栈顶</u></strong>。不允许插入和删除运算的一端称为 <strong><u>栈底</u></strong> 。</p></li><li><p>在具有n个单元的循环队列中，队满时共有<strong><u>n-1</u></strong>个元素。</p></li><li><p>向栈中插入元素的操作是先<strong><u>存入元素</u></strong>，后<strong><u>移动栈顶指针</u></strong>。</p></li><li><p>带表头结点的空循环链表的长度等于 <strong><u>0</u></strong>。</p></li><li><p>设循环队列Q[maxsize]的队头指针为front，队尾指针为rear，则该队列的队满条件是  <strong><u>Q.front==(Q.rear+1)%maxsize</u></strong>  。</p></li></ol><h4>三、判断题</h4><ol><li><p>栈和队列是操作受限的线性表。</p></li><li><p>线性表的每个结点不是<del>只能是简单类型</del>，而链表的每个结点可以是复杂类型。因为线性表是逻辑结构概念，可以顺序存储或链式储，与元素数据类型无关。</p></li><li><p>在表结构中最常用的是线性表，栈和队列不是<del>不太常用</del>。</p></li><li><p>栈对所有插入、删除操作仅限于在表的一端进行，是一种后进先出型结构。</p></li><li><p>对于不同的使用者，一个表结构既可以是栈，也可以是队列，也可以是线性表。</p></li><li><p>栈和链表不一定<del>是两种不同的数据结构</del>。</p></li><li><p>栈和队列不<del>是一种非线性数据结构</del>。</p><p>常见的线性表：栈，队列，一维数组，串，双队列</p><p>非线性：图，树，二维数组，**数组，广义表</p></li><li><p>栈和队列的存储方式既可是顺序方式，也可是链接方式。             </p></li><li><p>队列的插入与删除操作分别在表的两端进行，不是一种<del>先进后出</del>型结构，是先进先出。</p></li><li><p>一个栈的输入序列是12345，则栈的输出序列不是<del>不可能是12345</del>。</p></li><li><p>两个栈共享一片连续内存空间时，为提高内存利用率，减少溢出机会，<strong>应把两个栈的栈底分别设在这片内存空间的两端。</strong></p></li></ol><h4>五、算法阅读题</h4><ol><li><p>写出下列程序段的输出结果（栈的元素类型SElem Type为char）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123; <br><br>    Stack S;  Char x,y;<br><br>    InitStack(S);<br><br>    X=’c’; y=’k’;<br><br>    Push(S,x);  Push(S,’a’);  Push(S,y);  Pop(S,x);   <br><br>    Push(S,’t’);  Push(S,x);  Pop(S,x);   Push(S,’s’);<br><br>    <span class="hljs-keyword">while</span>(!StackEmpty(S))<br><br>    &#123;  Pop(S,y);  <span class="hljs-built_in">printf</span>(y);  &#125;<br><br>    <span class="hljs-built_in">printf</span>(x);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>解: </p><p>Push(S,x)后栈内为 c，Push(S, ‘a’)；Push(S,y)后栈内为cak; Pop(S,x)后出栈k, 此时x=k，栈内为 ca; </p><p>Push(S, ‘t’)后栈内为 cat; Push(S,x)后栈内为catk; Pop(S,x)后出栈k,此时x=k,栈内为cat; Push(S, ‘s’)后，栈内为cats; Pop(S,y) printf(y)循环打印栈内元素stac , printf(x)打印出k ，故结果为stack</p></li><li><p>写出下列程序段的输出结果（队列中的元素类型QElem Type为char）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123; <br>    Queue Q; <br><br>    <span class="hljs-function">Init <span class="hljs-title">Queue</span> <span class="hljs-params">(Q)</span></span>;<br><br>    Char  x=’e’;  y=’c’;<br><br>    EnQueue (Q,’h’);  EnQueue (Q,’r’);  <br><br>    EnQueue (Q, y);  DeQueue (Q,x);   <br><br>    EnQueue (Q,x);   DeQueue (Q,x);   <br><br>    EnQueue (Q,’a’); <br><br>    <span class="hljs-keyword">while</span>(!QueueEmpty(Q))<br><br>    &#123;  DeQueue (Q,y);  <span class="hljs-built_in">printf</span>(y);  &#125;<br><br>    <span class="hljs-built_in">printf</span>(x);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>答：输出为“char”。</p></li><li><p>简述以下算法的功能（栈和队列的元素类型均为int）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">alg</span><span class="hljs-params">(Queue &amp;Q)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123; <br>    Stack S;  <span class="hljs-keyword">int</span> d;<br><br>    InitStack(S);<br><br>    <span class="hljs-keyword">while</span>(!QueueEmpty(Q))<br><br>    &#123;  DeQueue (Q,d); Push(S,d);  &#125;;<br><br>    <span class="hljs-keyword">while</span>(!StackEmpty(S))<br><br>    &#123;  Pop(S,d);   EnQueue (Q,d);  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>答：该算法的功能是：利用堆栈做辅助，将队列中的数据元素进行逆置。</p></li></ol><h4>五、简答题</h4><ol><li><p>说明线性表、栈与队的异同点。</p><p>相同点：</p><p>都是线性结构，都是逻辑结构的概念。</p><p>都可以用顺序存储或链表存储；</p><p>栈和队列是两种特殊的线性表，即受限的线性表，只是对插入、删除运算加以限制。</p><p>不同点：</p><p>①运算规则不同，线性表为随机存取，而栈是只允许在一端进行插入、删除运算，因而是后进先出表LIFO；队列是只允许在一端进行插入、另一端进行删除运算，因而是先进先出表FIFO。</p><p>② 用途不同，堆栈用于子程调用和保护现场，队列用于多道作业处理、指令寄存及其他运算等等。</p></li><li><p>设有编号为1，2，3，4的四辆列车，顺序进入一个栈式结构的车站，具体写出这四辆列车开出车站的所有可能的顺序。</p><p>答：至少有14种。</p><p>① 全进之后再出情况，只有1种：4，3，2，1</p><p>② 进3个之后再出的情况，有3种，3,4,2,1 3,2,4,1 3,2,1,4</p><p>③ 进2个之后再出的情况，有5种，2,4,3,1  2,3,4,1  2,1, 3,4 2,1,4,3 2,1,3,4</p><p>④ 进1个之后再出的情况，有5种，1,4,3,2 1,3,2,4 1,3,4,2 1, 2,3,4 1,2,4,3</p></li><li><p>假设正读和反读都相同的字符序列为“回文”，例如，‘abba’和‘abcba’是回文，‘abcde’ 和‘ababab’则不是回文。假设一字符序列已存入计算机，请分析用线性表、堆栈和队列等方式正确输出其回文的可能性？</p><p>线性表是随机存储，可以实现，靠循环变量从表尾开始打印输出；</p><p>堆栈是后进先出，也可以实现，靠正序入栈、逆序出栈即可；</p><p>队列是先进先出，不易实现。</p><p>哪种方式最好，要具体情况具体分析。</p><p>若正文在机内已是顺序存储，则直接用线性表从后往前读取即可，或将堆栈栈顶设置到数组末尾，然后直接用POP动作实现。</p><p>若正文是单链表形式存储，则等同于队列，需开辅助空间，可以从链首开始入栈，全部入栈后再依次输出。</p></li><li><p>顺序队列的“假溢出”是怎样产生的？如何知道循环队列是空还是满？</p><p>一般的一维数组队列的<u>尾指针已经到了数组的上界</u>，不能再有入队操作，但<u>其实数组中还有空位置</u>，这就叫<u>“假溢出”</u>。</p><p>采用<u>循环队列</u>是解决假溢出的途径。</p><p>另外，解决队满、队空的办法有三：</p><p>①  设置一个布尔变量以区别队满还是队空；</p><p>②  浪费一个元素的空间，用于区别队满还是队空。</p><p>③  使用一个计数器记录队列中元素个数（即队列长度）。</p><p>我们常采用法②，即队头指针、队尾指针中有一个指向实元素，而另一个指向空闲元素。</p><p>判断循环队列队空标志是： f=rear   队满标志是：f=(r+1)%N</p></li><li><p>设循环队列的容量为40（序号从0到39），现经过一系列的入队和出队运算后，有  ① front=11，rear=19;  ② front=19，rear=11；问在这两种情况下，循环队列中各有元素多少个？</p><p>答：用队列长度计算公式： (N＋r－f)% N</p><p>① L=（40＋19－11）% 40=8        </p><p>② L=（40＋11－19）% 40=32</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap2线性结构复习题</title>
    <link href="/2020/12/22/chap2%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap2%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>顺序存储结构的优点是（<strong>存储密度大</strong>）</p></li><li><p>下面关于线性表的叙述中，<u>错误</u>的是（线性表采用顺序存储，便于进行插入和删除操作）</p></li><li><p>线性表是具有n个（<strong>数据元素</strong>）的有限序列（n&gt;0）。</p></li><li><p>若某线性表最常用的操作是存取任一<u>指定序号</u>的元素和在线性表的最后进行插入和删除元素，则利用（<strong>顺序表</strong>）存储方式最节省时间。</p></li><li><p>某线性表中最常用的操作是在<u>最后一个元素之后插入</u>一个元素和<u>删除第一个元素</u>，则采用（<strong>仅有尾指针的单循环链表</strong>）存储方式最节省运算时间。</p></li><li><p>对于一个头指针为head的带头结点的单链表，判定该链表为空表的条件是（<strong>head→next==NULL</strong>）。</p></li><li><p>链表<u>不具有</u>的特点是（可随机访问任一元素） </p></li><li><p>下面的叙述正确的是（<strong>线性表在链式存储时，查找第i个元素的时间同i的值成正比</strong>）</p></li><li><p>对于顺序存储的线性表，访问结点和增加、删除结点的时间复杂度分别为（<strong>O(1)，O(n)</strong>）。</p></li><li><p>非空的循环单链表head的指向尾结点的指针变量p满足（<strong>p-&gt;link=head</strong>）。</p></li><li><p>若长度为n的线性表采用顺序存储结构，在第i个位置插入一个元素的算法的时间复杂度为（<strong>O(n)</strong>）(1&lt;=i&lt;=n+1)。</p></li><li><p>在单链表指针为p的结点之后插入指针为s的结点，正确的操作是（<strong>s-&gt;next=p-&gt;next;  p-&gt;next=s;</strong>）。</p></li><li><p>利用双向链表作线性表的存储结构的优点是（<strong>提高按关系查找数据元素的速度</strong>）。</p></li><li><p>若长度为n的非空顺序表，在表的第i个位置插入一个新元素，i的合法值是（<strong>1≤i≤n+1</strong>）。</p></li><li><p>已知L是带头结点的单链表，则删除首元结点的语句是（<strong>L-&gt;next=L-&gt;next-&gt;next;</strong>）。</p></li><li><p>已知单链表A的长度为m，单链表B的长度为n，若将B链接在A的末尾，在没有尾指针的情况下，算法的时间复杂度为（<strong>O(m)</strong>）。</p></li><li><p>设一个链表最常用的操作是在<u>末尾插入结点和删除尾结点</u>，则选用(<strong>带头结点的双循环链表</strong>)最节省时间。</p></li></ol><h4>二、填空题</h4><ol><li><p>在一个长度为n的顺序表中第i个元素（1≤i≤n）之前插入一个元素时，需向后移动 <strong><u>n-i+1</u></strong>个元素。</p></li><li><p>当线性表的元素<code>总数基本稳定</code>，且<code>很少进行插入和删除操作</code>，但要求以最快的速度存取线性表中的元素时，应采用 <strong><u>顺序</u></strong> 存储结构。</p></li><li><p>对于一个有n个结点的单链表，在给定值为x的结点后插入一个新结点的时间复杂度为 <strong><u>O(n)</u></strong>。</p></li><li><p>根据链式存储结构中每一个结点包含的指针个数，可以将线性链表分成<strong><u>单链表</u></strong>和多重链表。</p></li><li><p>链接存储的特点是利用<strong><u>指针</u></strong>来表示数据元素之间的逻辑关系。</p></li><li><p>顺序存储结构是通过<strong><u>物理位置相邻</u></strong>表示元素之间的关系的;链式存储结构是通过<strong><u>指针</u></strong>表示元素之间的关系的。</p></li><li><p>循环单链表的最大优点是：<strong><u>从任一结点出发都可访问到链表中每一个元素</u></strong>。</p></li><li><p>带头结点的单循环链表L，L为空表的条件是：<strong><u>L-&gt;next==L</u></strong>。</p></li></ol><h4>三、判断题</h4><ol><li><p>对任何数据结构链式存储结构不是<del>一定优于顺序存储结构</del>。(   )</p></li><li><p>线性表采用链表存储时，结点和结点内部的存储空间不是<del>可以是不连续的</del>。(   )</p></li><li><p>顺序存储方式插入和删除时效率太低，因此它不是<del>不如链式存储方式好</del>。(   )</p></li><li><p>所谓静态链表不是<del>一直不发生变化的链表</del>。类似于数组方法实现的，是顺序的存储结构(   )</p></li><li><p>线性表的特点是不是<del>每个元素都有一个前驱和一个后继</del>。(   )</p></li><li><p>取线性表的第i个元素的时间不一定<del>同i的大小有关</del>。这要分是顺序存储结构还是链式存储结构 (   )</p></li><li><p>线性表不是<del>只能用顺序存储结构实现</del>。(   )</p></li><li><p>顺序存储结构的主要缺点是不利于插入或删除操作。</p></li></ol><h4>四、简答题</h4><ol><li><p>对于线性表中的插入操作，分别写出在顺序存储结构下和链式存储结构下的时间复杂度。</p><p>顺序O(n)  链式O(1)</p></li><li><p>线性结构的特点是什么？</p><p>1．集合中必存在唯一的一个”第一个元素”；</p><p>2．集合中必存在唯一的一个”最后的元素”；</p><p>3．除最后元素之外，其它数据元素均有唯一的”后继”；</p><p>4．除第一元素之外，其它数据元素均有唯一的”前驱”。</p><p>数据元素之间存在着“一对一”的线性关系</p></li><li><p>说明在线性表的链式存储结构中，头指针与头结点之间的根本区别；头结点与首元结点的关系。</p><p><strong>头指针</strong>是指向链表第一个节点的指针。若链表设有头结点，则头指针指向头结点；若链表没有设头结点，则头指针指向首元结点。</p><p><strong>头结点</strong>是在首元结点之前附设的一个节点，其指针域指向首元结点。头结点的数据域可以不存储任何信息，也可以储存与数据类型相同的其他附加信息。</p><p><strong>首元结点</strong>是指链表中存储第一个数据元素的节点。</p><p><img src="https://img2020.cnblogs.com/blog/2031479/202005/2031479-20200519210025364-1093899923.jpg"></p></li><li><p>在单链表和双向链表中，能否从当前结点出发访问到任何一个结点?</p><p>在单链表中不能从当前结点（若当前结点不是第一结点）出发访问到任何一个结点，<u>链表只能从头指针开始，访问到链表中每个结点</u>。在<u>双链表中</u>求前驱和后继都容易，从<u>当前结点</u>向前到第一结点，向后到最后结点，<u>可以访问到任何一个结点</u>。</p></li><li><p>顺序表在插入或删除元素时一般需要移动元素，如果想不移动多个元素就实现插入和删除，应该如何处理？</p><p>设顺序表长度为n </p><p>插入元素时，直接将新元素插在第n+1个位置</p><p>删除第i个元素时，将第n个元素补到第i个位置</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chap1绪论复习题</title>
    <link href="/2020/12/22/chap1%E7%BB%AA%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/12/22/chap1%E7%BB%AA%E8%AE%BA%E5%A4%8D%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4>一、选择题</h4><ol><li><p>从逻辑结构上可以把数据结构分为 (<strong>线性结构和非线性结构</strong>)。</p></li><li><p>顺序存储表示中数据元素之间的逻辑关系是由（<strong>存储位置</strong>）表示的。</p></li><li><p>链式存储表示中数据元素之间的逻辑关系是由（<strong>指针</strong>）表示的。</p></li><li><p>若某算法的时间复杂度是O(n2 ) ，表明该算法（<strong>执行时间与n2成正比</strong>）。</p></li><li><p>算法的时间复杂度与（<strong>问题规模</strong>）有关。</p></li><li><p>算法必须具备（<strong>可行性，确定性，有穷性</strong>）这3个特性</p></li><li><p>下面程序段的时间复杂度为（<strong>O(m×n)</strong>）。</p><p>for( i=0; i&lt;m; i++)</p><p>  for(j=0; j&lt;n; j++)</p><p>​    a[i][j]=i*j;</p></li><li><p>以下程序段中，S语句的执行次数是（<strong>n(n+1)/2</strong>）  </p><p>for( i=1; i&lt;=n; i++)</p><p> for(j=i; j&lt;=n; j++) </p><p>   S；</p></li></ol><h4>二、填空题</h4><ol><li><p>数据元素之间的4种基本结构是：<strong><u>集合</u>、<u>线性结构</u> 、 <u>树形结构</u> 、<u>图状结构</u></strong>。</p></li><li><p>线性结构中元素的关系是<strong> <u>一对一</u></strong>，树形结构中元素的关系是<strong> <u>一对多</u></strong>，图形结构中元素的关系是<strong> <u>多对多</u></strong>。</p></li><li><p>顺序存储结构中数据元素的存储位置与其<strong><u>逻辑顺序</u></strong>是对应的。</p></li><li><p>算法效率的度量方法有：<strong><u>事后统计方法</u></strong>和<strong><u>事前分析估算方法</u></strong>。</p></li><li><p>一个好算法应达到的目标有：<strong><u>正确性</u></strong> 、 <strong><u>可读性</u></strong>、 <strong><u>健壮性</u></strong> 、 <strong><u>执行时间短</u></strong> 、 <strong><u>存储量低</u></strong> 。</p></li><li><p>抽象数据类型可细分为3种：<strong><u>原子类型</u> </strong>、 <strong><u>固定聚合类型</u></strong> 和 <strong><u>可变聚合类型</u></strong> 。</p></li><li><p>抽象数据类型的定义一般包括3方面：<strong><u>数据对象的定义</u></strong> 、 <strong><u>数据关系的定义</u></strong> 、<strong><u>基本操作的定义</u></strong>。</p></li></ol><h4>三、判断题</h4><ol><li><p>数据结构主要研究非数值型数据。</p></li><li><p>数据的逻辑结构相同则对应的存储结构<u>不一定</u>也相同。</p></li><li><p>数据的逻辑结构独立于其存储结构。</p></li><li><p><u>数据项</u>是数据的<u>最小单位</u>    <u>数据元素</u>是<u>基本单位</u></p></li><li><p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称。</p></li><li><p>数据的逻辑结构与数据元素本身的内容和形式无关。</p></li><li><p>数据的逻辑结构不是<del>指数据的各数据项之间的逻辑关系</del>, 逻辑结构是元素间关系，而不是元素内容间关系 </p></li><li><p>抽象数据类型不<del>只是一个数学模型</del>, 它是指一个数学模型以及定义在此数学模型上的一组操作。</p></li><li><p>算法和程序不是<del>原则上没有区别</del>，程序不等于算法。但是，通过程序设计可以在计算机上实现算法。</p></li><li><p>数据结构是数据元素的集合和该集合中各数据元素之间关系的集合。</p></li><li><p>顺序存储方式不是<del>只能用于线性结构</del>，比如存储树状结构。还有图的邻接矩阵也是顺序存储</p></li></ol><h4>四、简答题</h4><ol><li><p>什么是数据结构，写出数据结构的形式定义。</p><p>数据结构是指同一数据元素类中各数据元素之间存在的关系。</p></li><li><p>什么是算法，算法的5个特性是什么？</p><p>算法是解决特定问题求解步骤的描述  </p><p>五个基本特性：输入、输出、有穷性、确定性和可行性。</p></li><li><p>数据的逻辑结构分为线性结构和非线性结构,这两类结构各自的特点是什么?</p><p>数据元素之间存在着“一对一”的线性关系</p><p>一个结点元素可能对应多个直接前驱和多个后继。</p></li></ol><h4>五、应用题</h4><p><img src="https://i.loli.net/2020/12/15/hqumrIwPZGdkJTs.png"></p><ol start="2"><li>写出以下各函数的功能，并求出其时间复杂度。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;   <br>    <span class="hljs-keyword">int</span>  i, x;<br>i=<span class="hljs-number">2</span>;<br>x=(<span class="hljs-keyword">int</span> )<span class="hljs-built_in">sqrt</span>(n);<br><span class="hljs-keyword">while</span>(i&lt;=x)&#123;  <br>        <span class="hljs-keyword">if</span> (n%i==<span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<br>   i++;<br>&#125;<br><span class="hljs-keyword">if</span> ( i&gt;x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//功能是判断n是否为素数 ，时间复杂度为O(√n ) </span><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;  <br>     <span class="hljs-keyword">int</span> i, p=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;   <br>          p=p*i;<br>           sum=sum+p;<br>       &#125;<br>      <span class="hljs-keyword">return</span>(sum);<br>   &#125;<br><span class="hljs-comment">//功能是计算1!+2!+…+n! ，时间复杂度为O(n ) </span><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;  <br>     <span class="hljs-keyword">int</span> i, j, p, sum=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>          p=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=i; j++) <br>            p=p*j;<br>         sum=sum+p;<br>      &#125;<br><span class="hljs-keyword">return</span>(sum);<br>   &#125;<br><span class="hljs-comment">//功能是计算1!+2!+…+n! ，时间复杂度为O(n2 ) </span><br></code></pre></td></tr></table></figure><h4>六 、算法题</h4><ol><li><p>编写算法计算1!+2!+…+n!，并使算法的时间复杂度为O(n)。</p><p>算法思想：用循环实现阶乘的累加求和，注意在求n!时，使用前一次循环中已经求出的(n-1)!的结果。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; <br>    <span class="hljs-keyword">int</span> i; <br><span class="hljs-keyword">double</span> p=<span class="hljs-number">1</span>, sum=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>( i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123; <br>        p=p*i;  <br>sum=sum+p;  <br>&#125;<br>  <span class="hljs-keyword">return</span>(sum);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>编写算法计算2i (i=0,1,2,…,n)，并将计算结果存入数组a中，设计算机中允许的最大整数值为MAXINT，则当2k &gt;MAXINT（0≤k≤n）时，应进行出错处理。</p><p>算法思想：先判断n的取值是否合法，若非法则直接退出程序，若n合法则继续计算2i，在计算2i时，需要判断2i的值是否大于MAXINT/2，这个条件其实就是判断2i+1的值是否大于MAXINT</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arrsize 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXINT  65535</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[ ], <span class="hljs-keyword">int</span> n)</span></span>&#123;   <br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span> || n&gt;arrsize) &#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n  error!\n&quot;</span>);  <br>   <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <br>&#125;<br>   a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[0]=%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);<br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;  <br>       a[i]=a[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>;  <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d]=%d\n&quot;</span>, i, a[i]);<br>       <span class="hljs-keyword">if</span>( a[i]&gt;MAXINT/<span class="hljs-number">2</span> )&#123; <br>           <span class="hljs-built_in">printf</span>(“i=%d, ERROR!\n”, i+<span class="hljs-number">1</span>)；  <br>   <span class="hljs-keyword">break</span>;  <br>&#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DSReviewPaper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10_排序</title>
    <link href="/2020/12/22/10-%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/12/22/10-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4>插入排序</h4><ul><li><p>直接插入排序 <code>就是选择第一个元素之后，在从后面选择小的，往前插</code></p><p><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp"></p></li><li><p>折半插入排序</p></li><li><p>表插入排序</p></li><li><p>希尔排序</p></li></ul><h4>冒泡排序</h4><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp"></p><p>每两个挨着比，每趟最大的沉底</p><h4>快速排序</h4><p><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp"></p><p>用第一个数字，依次和后面的每个比较，然后拆分成2部分，一部分小于等于，一部分大于，依次类推即可</p><h4>选择排序</h4><p><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp"></p><p>每次选择最小的和未排序的第一个元素交换</p><h4>堆排序</h4><p>最小堆：任一结点的值都不大于它的两个孩子的值 </p><p>最大堆：任一结点的值都不小于它的两个孩子的值</p><p>画出二叉树，然后调整为堆即可</p><h4>归并排序</h4><p><img src="https://pic3.zhimg.com/80/v2-145011b5968388bd76e3b91853b136f6_720w.jpg"></p><p>二二合并排序</p><h4>基数排序</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>9_查找</title>
    <link href="/2020/12/22/9-%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/12/22/9-%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3>    查找</h3><h4>基本概念</h4><p>查找表: 是由同一类型的<u>数据元素</u>构成的集合</p><p>查找(Searching）就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素</p><p>静态查找表(StaticS Search Table): 只做查找操作的查找表</p><p>动态查找表(Dynamic Search Table): 在查找过程中，向表中插入不存在的数据元素，或者从表中删除某个数据元素</p><p>通常用“数据元素的键值与给定值的比较次数”作为衡量查找算法好坏的依据，称上述比较次数为<code>查找长度</code></p><p><strong>查找成功时的平均查找长度(ASL): </strong>需和指定key进行比较的关键字的个数的期望值</p><h4>顺序表查找</h4><p>适合于存储结构为<u>顺序存储</u>或<u>链接存储</u>的线性表。</p><p>查找成功 ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</p><p>等概率情况下 <img src="https://img2018.cnblogs.com/blog/1539112/201901/1539112-20190108141052350-17425507.gif"></p><p>时间复杂度 O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//每次循环都要对i是否越界超过n做判断</span><br>           <span class="hljs-keyword">if</span>(a[i]==key)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,i);<br>               <span class="hljs-keyword">return</span> i;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回0表示查找失败</span><br>   &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">//改进法 设置哨兵</span><br>       <span class="hljs-keyword">int</span> i<br>       a[<span class="hljs-number">0</span>]=key;<span class="hljs-comment">//a[0]为关键字值--哨兵</span><br>       i=n;<span class="hljs-comment">//循环从尾部开始</span><br>       <span class="hljs-keyword">while</span>(a[i]!=key)&#123;<br>           i--;<br>       &#125;<br>       <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回0则说明查找失败</span><br>   &#125;<br></code></pre></td></tr></table></figure><h4>有序表查找</h4><ul><li><p><strong>二分查找</strong></p><p>前提条件是需要<u>有序表顺序存储</u>，如果无序则要先进行排序操作 </p><p>时间复杂度 O(logn) 比顺序查找有了质的飞跃</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,mid,high;<br>       low=<span class="hljs-number">0</span>;<span class="hljs-comment">//最低下标为记录首位</span><br>       high=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标为记录末位</span><br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=(low+high)/<span class="hljs-number">2</span>;<span class="hljs-comment">//折半 </span><br>           <span class="hljs-keyword">if</span>(a[mid]==value)&#123;<span class="hljs-comment">//中值与查找值相等 查找成功</span><br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<span class="hljs-comment">//中值比查找值大</span><br>               high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标调至中值前一位</span><br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<span class="hljs-comment">//中值比查找值小</span><br>               low=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//最低下标调至中值后一位</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回0查找失败</span><br>   &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-comment">//递归版本</span><br>       <span class="hljs-keyword">int</span> mid=low+(high-low)/<span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">if</span>(low&gt;high)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>       &#125;<br>       <span class="hljs-keyword">if</span>(a[mid]==key)&#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);            <br>           <span class="hljs-keyword">return</span> mid;<br>       &#125;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<br>            <span class="hljs-keyword">return</span> binarySearch(a,key,low,mid<span class="hljs-number">-1</span>);<br>        &#125;<br>       <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<br>           <span class="hljs-keyword">return</span> binarySearch(a,key,mid+<span class="hljs-number">1</span>,high);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>插值查找</strong></p><p>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率</p><p>时间复杂度 O(logn)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,mid,high;<br>       low=<span class="hljs-number">0</span>;<br>       high=n<span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=low+(key-a[low])/(a[high]-a[low])*(high-low);<br>           <span class="hljs-comment">//折半查找中mid=(low+high)/2</span><br>           <span class="hljs-keyword">if</span>(a[mid]==key)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<br>               high=mid<span class="hljs-number">-1</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<br>               low=mid+<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>斐波那契查找</strong></p><p>基于二分查找算法，通过运用黄金比例的概念在数列中选择查找点进行查找</p><p>时间复杂度 O(logn)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibonacciSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,high,mid,i,k;<br>       low=<span class="hljs-number">0</span>;<span class="hljs-comment">//最低下标为记录首位</span><br>       high=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标为记录末位</span><br>       k=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(n&gt;F[k]<span class="hljs-number">-1</span>)<span class="hljs-comment">//计算n位于斐波那契数列的位置</span><br>           k++;<br>       <span class="hljs-keyword">for</span>(i=n;i&lt;F[k]<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//将不满的数值补全</span><br>           a[i]=a[n];<br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=low+F[k<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<span class="hljs-comment">//计算当前分隔的下标</span><br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<span class="hljs-comment">//当前分隔大于查找值</span><br>               high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标调至mid-1</span><br>               k=k<span class="hljs-number">-1</span>;<span class="hljs-comment">//斐波那契数列下标-1</span><br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<span class="hljs-comment">//当前分隔小于查找值</span><br>               low=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//最低下标调至mid+1</span><br>               k=k<span class="hljs-number">-2</span>;<span class="hljs-comment">//斐波那契数列下标-2</span><br>           &#125;<br>           <span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">if</span>(mid&lt;=n)<span class="hljs-comment">//不是补全数值</span><br>                   <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">//返回下标</span><br>               <span class="hljs-keyword">else</span><br>                   <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//是补全数值返回n</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>   &#125;<br><br></code></pre></td></tr></table></figure><p>斐波那契查找算法的核心在于:</p><p>1)当a[mid]=key时，查找就成功<br>2)当a[mid]&gt;key时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个<br>3)当a[mid]&lt;key时，新范围是第mid+1个到第high 个，此时范围个数为F[k-2]-1个</p><h4>二叉排序树</h4><p>一棵二叉排序树（又称二叉查找树）<u>有可能是一棵空树</u> 否则满足如下性质</p><ol><li><p>若它的左子树不空，则左子树上所有结点的键值均小于它的根结点键值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的键值均小于它的根结点键值；</p></li><li><p>根的左、右子树也分别为二叉排序树。</p></li></ol><p><strong>对二叉查找树进行中序遍历，即可得到有序递增的数列。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTNode</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTR</span>=</span>Node *lchild,*rchild;<br>    &#125;biTNode,*biTree;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-a0b152e7dd56541e095f17fa3f3e06bc_r.jpg" alt="bst的平均查找长度示例"></p><h4>散列表(哈希表)</h4><p><code>存储位置=f(关键字)</code></p><p><strong>构造散列函数的方法</strong></p><ol><li><p><strong>直接定值法</strong> 取关键字的某个线性函数值作为散列地址 <code>f(key)=a*key+b</code></p></li><li><p><strong>数字分析法</strong> 事先知道关键字的分布且关键字若干位分布较均匀</p></li><li><p><strong>平方取中法</strong> 关键字平方取中间位 </p></li><li><p><strong>除留余数法</strong> <code>f(key) = key mod p (p&lt;=m) 表长为m</code></p><p>若散列表表长为m，通常p为小于或等于表长(最好接近m)的最小质数或不包含小于20质因子的合数</p></li><li><p><strong>随机数法</strong> 选一个随机数 取关键字的随机函数值作为其散列地址 f(key) = random(key)</p></li></ol><p><strong>处理散列冲突方法</strong></p><ol><li><p><strong>开放定址法</strong></p><p>只要在散列表未填满时，总是能找到不发生冲突的地址</p><ul><li><p><u>线性探测法</u></p><p><img src="https://i.loli.net/2020/12/20/bGBJrcZfmSh5IwP.png"></p><p>求余数，然后放到对应的位置上，如果位置上有数据元素了，那么就向后移动，移动到没有数据元素的位置上，然后占坑</p><p>平均查找长度 ASL = 元素查找次数总和 / 散列表长度 (下例中为16/11)</p><p><img src="https://pic4.zhimg.com/v2-ebc7c60b4f6c02ea79d760ef6202b8af_b.webp"></p></li><li><p><u>二次探测法</u></p><p><img src="https://i.loli.net/2020/12/20/gnmTr4zFQxLvPp6.png"></p><p>平方运算不让关键字都聚集在某一块区域</p></li><li><p><u>随机探测法</u></p><p><img src="https://i.loli.net/2020/12/20/YeRK9zWSZv4dyNo.png"></p><p>冲突时 对于位移量di采用随机函数计算得到</p></li></ul></li><li><p><strong>再散列函数法</strong></p><p><img src="https://i.loli.net/2020/12/20/Us1ZgamIbORAP8X.png"></p></li><li><p><strong>链地址法</strong></p><p><img src="https://pic3.zhimg.com/v2-1294c9705e969924685cdaa85b27f8f6_r.jpg"></p><p>平均查找长度ASL = (查找次数 * 个数) / 关键字个数 </p></li><li><p><strong>公共溢出区法</strong></p><p>为所有冲突的关键字建立了一个公共的溢出区存放</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> *elem;<span class="hljs-comment">//数据元素存储基址 动态分配数组</span><br>        <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//当前数据元素个数</span><br>    &#125;hashTable;<br><span class="hljs-keyword">int</span> length=<span class="hljs-number">0</span>;<span class="hljs-comment">//全局定义表长</span><br><span class="hljs-comment">//初始化散列表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initHash</span><span class="hljs-params">(hashTable *H)</span></span>&#123;<br>        length=HASHSIZE;<br>        H-&gt;count=length;<span class="hljs-comment">//初始化散列表长度为数组长度</span><br>        H-&gt;elem=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(m*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            H-&gt;elem[i]=NULLKEY;<span class="hljs-comment">//赋值为空值</span><br>        &#125;<br>    &#125;<br><span class="hljs-comment">//散列函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> key%m;<span class="hljs-comment">//除留余数法</span><br>    &#125;<br><span class="hljs-comment">//插入关键字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertHash</span><span class="hljs-params">(hashTable *H,<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> addr=hashFunc(key);<span class="hljs-comment">//求散列地址</span><br>        <span class="hljs-keyword">while</span>(H-&gt;elem[addr]!=NULLKEY)&#123;<span class="hljs-comment">//如果不为空 则冲突</span><br>            addr=(addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//开放定址法线性探测</span><br>        &#125;<br>        H-&gt;elem[addr]=key;<span class="hljs-comment">//直到有空位后插入关键字</span><br>    &#125;<br><span class="hljs-comment">//查找关键字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchHash</span><span class="hljs-params">(hashTable H,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> *addr)</span></span>&#123;<br>        *addr=hashFunc(key);<span class="hljs-comment">//求散列地址</span><br>        <span class="hljs-keyword">while</span>(H.elem[*addr]!=key)&#123;<span class="hljs-comment">//如果不为空 则冲突</span><br>            *addr=(*addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//开放定址法的线性探测</span><br>            <span class="hljs-keyword">if</span>(H.elem[*addr]==NULLKEY || *addr==hashFunc(key))&#123;<span class="hljs-comment">//循环回原点</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;关键字不存在!&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>8_图</title>
    <link href="/2020/12/22/8-%E5%9B%BE/"/>
    <url>/2020/12/22/8-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3>    图</h3><h4>基本概念:</h4><p><strong>图的分类: </strong>有向图和无向图</p><p><strong>弧、弧头、弧尾: </strong>有向图的边称为弧。无向图叫做边。</p><p><strong>无向完全图: </strong>任何两点之间都有边的无向图。 </p><p><strong>有向完全图: </strong>任何两点之间都有弧的有向图。</p><p><strong>权：</strong>图的边附带数值，这个数值叫权。</p><p><strong>带权图: </strong>每条边都带权的图称为带权图。</p><p><strong>顶点的度、入度、出度: </strong>1. 无向图中顶点v的度是与该顶点相关联的边的数目，记为D(v)。 2. 有向图中，把以顶点v为终点的弧的数目称为v的入度，记为ID(v)；把以顶点v为始点的弧的数目称为v的出度，记为OD(v)。有向图顶点v的度为入度和出度之和，即D（v） = ID（v）+ OD（v）。</p><p><strong>简单路径: </strong>序列中<u>顶点</u>不重复出现的路径。</p><p><strong>回路: </strong>第一个顶点和最后一个顶点相同的路径。</p><p><strong>简单回路(简单环): </strong>除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。</p><p><strong>生成树(不唯一):</strong> n个顶点有n-1条边的无向图。权值最小的生成树是<strong>最小生成树(唯一)</strong>。</p><p><strong>强连通图:</strong> 有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路</p><p><strong>连通图:</strong> 无向图中，如果任意两个顶点之间都能够连通</p><h4>基本性质</h4><ul><li><p><strong>无向完全图</strong>, 边数最多为 n(n-1) / 2</p></li><li><p><strong>有向完全图</strong>, 边数最多为 n(n-1)</p></li><li><p><strong>有向强连通图</strong>, 边数最多为 n(n-1), 最少有n条边</p></li><li><p><strong>无向连通图</strong>, 边数最多为 n(n-1) / 2, 边数最少为 n-1条边   即生成树</p></li><li><p><strong>无向非连通图</strong>, 边数最多为 (n-1)(n-2)/2条边</p></li><li><p>树是图的特例 是无环无向图</p></li><li><p>握手定理</p><p>在无向图G=&lt;V,E&gt;中, 所有的节点的<strong>度数总和等于边数的2倍</strong></p><p>在有向图G=&lt;V,E&gt;中, 所有节点的度数的总和等于边数的2倍，所有节点的入度之和等于所有节点的出度之和</p></li></ul><h4>图的存储结构</h4><ul><li><p>点表示–所有顶点保存到数组</p></li><li><p>边表示</p><p><strong>邻接矩阵</strong></p><p>(矩阵中标记1，有边，标记0，没有边)</p><p><img src="https://i.loli.net/2020/12/15/K4AzwrFHQJmnvOT.png"></p><p><u>无向图</u>的邻接矩阵是一个<u>对称矩阵</u> <u>第i行或第i列</u>非零元素个数表示顶点v的度</p><p><u>有向图</u>的邻接矩阵<u>不一定</u>对称 (双向的有向图对称) <u>第i行</u>非零元素个数表示顶点v的<u>出度</u> <u>第i列</u>非零元素个数表示顶点v的<u>入度</u></p><p><strong>邻接表</strong></p><p>(顺序存储与链式存储相结合的存储方法)<img src="https://i.loli.net/2020/12/15/jzFGaKRWXQIsP7h.png"><code>∧符号，表示结束，没有连接的顶点了</code></p><p><u>无向图</u>的邻接表 第i个顶点的<u>度</u>为第i个链表的结点数</p><p><u>有向图</u>的邻接表 第i个顶点的<u>出度</u>为第i个链表的结点数 <u>入度</u>要遍历整个邻接表 找下标为i的结点</p></li></ul><h4>图的遍历</h4><p><strong>从图的某个顶点出发，系统地访问图的每个顶点，并且每个顶点只被访问一次。</strong></p><p><strong>1.深度优先搜索</strong></p><p>(往下走，走不动了，返回上一级再走)</p><img src="https://i.loli.net/2020/12/15/DTrNKIFMmH2PgkO.png" style="zoom:67%;" /><p><strong>2.广度优先搜索</strong></p><p>(顺着一个顶点，然后都遍历完)</p><img src="https://i.loli.net/2020/12/15/uvpTe58bEQmgSqZ.png" style="zoom:67%;" /><h4>最小生成树</h4><p><strong>(所有生成树中权总和最小的生成树)</strong></p><p>构造方法:</p><ul><li><strong>Prim算法</strong></li></ul><img src="https://i.loli.net/2020/12/15/mnlBOgecfLJ98Nk.png" alt="Prim" style="zoom: 50%;" /><ul><li><p><strong>Kruskal算法</strong></p><p>先对边按权值从小到大排序, 每次从剩余的边中选取一个最小的边。</p><img src="https://img-blog.csdn.net/20150816113249128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="zoom: 50%;" /></li></ul><h4>最短路径</h4><ul><li>Dijkstra算法</li></ul><img src="https://img-blog.csdn.net/20160330150629186" style="zoom:67%;" /><ul><li>Floyd算法</li></ul><h4>拓扑排序</h4><p>AOV网: 用顶点表示活动的有向图</p><p>工程或者某种流程可以分为若干个小的工程或阶段，这些小的工程或阶段就称为活动。</p><p> 如果以图中的顶点来表示活动，有向边表示活动之间的优先关系。</p><p><img src="https://i.loli.net/2020/12/15/LxbmKU6QSI8Cc4g.png"></p><p>拓扑排序: 一个有向无环图（DAG）的所有顶点的线性序列。</p><p>该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li></ol><p>基本步骤如下：</p><ol><li>图中选择一个入度为0的顶点，输出该顶点</li><li>从图中删除该顶点及相关联的弧，调整被删弧的弧头结点的入度（入度减1）</li><li>重复执行上述两个步骤，<u>直到所有的入度为0</u></li></ol><p><img src="https://i.loli.net/2020/12/15/jEUabHSgTWGJFys.png" alt="example"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>7_Huffman树及算法</title>
    <link href="/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>哈夫曼树与哈夫曼算法</h3><p><strong>哈夫曼树不唯一、时刻考虑权值最小</strong></p><p><strong>路径: </strong>从一个结点到另一个结点的分支序列</p><p><strong>路径长度:  </strong>根结点到L层结点路径长度L-1 (完全二叉树是总路径长度最短的二叉树)</p><h4>Huffman树: </h4><p>由n个带权值的叶结点构成的二叉树中,树的最大带权长度(WPL)最小的二叉树称为最优二叉树</p><p><img src="https://i.loli.net/2020/12/15/hWX4R9MKypGocqS.png" alt="example"></p><p><img src="https://i.loli.net/2020/12/15/jVy6DCFdxcSOANl.gif"></p><h4>huffman编码</h4><p>例题: 设某通讯系统中一个待传输的文本有6个不同字符，它们的出现频率分别是0.5,0.8,1.4,2.2,2.3,2.8，试设计哈夫曼编码</p><p><img src="https://i.loli.net/2020/12/15/A6p9vIMjdKyXUm8.png"></p><p>出现频率为0.5的字符编码为1000 出现频率为0.8的字符编码为1001 出现频率为1.4的字符编码为101 出现频率为2.2的字符编码为00 出现频率为2.3的字符编码为01 出现频率为2.8的字符编码为11</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6_树和森林</title>
    <link href="/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <url>/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<h3>树</h3><p><strong>核心概念: </strong>线性结构中一个结点至多只有一个直接后继，树形结构一个结点可以有一个或多个直接后继</p><h4>相关术语:</h4><ul><li>结点的度: 结点拥有的子树数</li><li>叶子节点: 度为0的结点</li><li>分支节点: 度不为0的结点</li><li>树的度: 树内各结点的度的最大值, 就是把所有结点的度求和</li><li>结点的层次: 根为第一层, 其余结点的层次为其双亲的层次加1</li><li>结点间关系: Parent Child</li><li>树的深度/高度: 树中结点最大层次</li><li>森林: m棵不相交的树的集合</li></ul><h4>树的存储结构:</h4><p><strong>1.双亲表示法</strong></p><p><strong>2.孩子表示法</strong></p><p><strong>3.孩子兄弟表示法</strong></p><h4>树、森林与二叉树的关系: </h4><p><strong>树到二叉树手工模拟: </strong></p><p><img src="https://i.loli.net/2020/12/15/jMkBR4lWhDS3JUt.gif" alt="树到二叉树"></p><p>​     1).连线(兄弟节点加线) 2).删线(只保留左孩子) 3).旋转(顺时针45)</p><p>​     <strong>将结点的孩子放在左子树 结点的兄弟放在右子树 形态唯一!!!</strong></p><p><strong>森林转换成二叉树</strong></p><p><img src="https://i.loli.net/2020/12/15/GfUBmqkdy94aJ83.png" alt="森林到二叉树"></p><p>​    1).每棵树转换成相应的二叉树 2).各棵二叉树的根结点看做是兄弟连接起来</p><p><strong>二叉树到树手工模拟</strong></p><p><img src="https://img-blog.csdnimg.cn/20190629154649448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDY4ODIxNw==,size_16,color_FFFFFF,t_70" alt="二叉树到树"></p><p>​    1).连线(结点与其子树的右孩子) 2).删线(双亲与右孩子) 3).旋转(逆时针45)</p><h4>树和森林的遍历:</h4><p><strong>树的遍历</strong>:</p><ul><li>先序遍历: 访问根结点 依次先序遍历根的各棵子树</li><li>后序遍历: 依次后序遍历根的各棵子树 访问根结点</li><li>层次遍历: 访问根结点 依次从左到右访问结点</li></ul><p><strong>森林的遍历</strong></p><ul><li>先序遍历森林</li></ul><p>访问森林中第一棵树的根结点<br>先序遍历森林中第一棵树的根结点子树组成的森林<br>先序遍历除去第一棵树之外其余的树组成的森林</p><ul><li>中序遍历森林</li></ul><p>中序遍历森林中第一棵树的根结点的子树组成的森林<br>访问第一棵树的根结点<br>中序遍历除去第一棵树之外其余的树组成的森林</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5_二叉树算法</title>
    <link href="/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>二叉树存储结构:</h3><h4>1.顺序存储结构</h4><p>一般只用于完全二叉树</p><h4>2.链式存储结构--二叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左右孩子指针</span><br>    &#125;biTree;<br></code></pre></td></tr></table></figure><p><strong>遍历二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        preOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//先先序遍历左子树</span><br>        preOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//再先序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//2.中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//中序遍历左子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        inOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//中序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//3.后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        postOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//后序遍历左子树</span><br>        postOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//后序遍历右子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(*t)-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>    &#125;<br><span class="hljs-comment">//4.层序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        biTree *tmp=t;<br>        circleQueue *q;<br>        q=initQueue();<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;根结点为空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            enQueue(q,*tmp);<span class="hljs-comment">//根结点入队</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(q.rear!=q.front)&#123;<span class="hljs-comment">//队不为空</span><br>            p=q.getEle();<span class="hljs-comment">//取队首元素</span><br>            deQueue();<span class="hljs-comment">//出队一个元素</span><br>            <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树不为空</span><br>                enQueue(q,p-&gt;lchild);<span class="hljs-comment">//左子树入队</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//右子树不为空</span><br>                enQueue(q,p-&gt;rchild);<span class="hljs-comment">//右子树入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//已知前序中序可确定一棵二叉树</span><br><span class="hljs-comment">//已知后序中序可确定一棵二叉树</span><br></code></pre></td></tr></table></figure><p><strong>创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createBiTree</span><span class="hljs-params">(biTree *t)</span></span>&#123;<span class="hljs-comment">//前序建立</span><br>       <span class="hljs-keyword">int</span> newValue;<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;newValue);<br>       <span class="hljs-keyword">if</span>(newValue==<span class="hljs-string">&quot;#&quot;</span>)&#123;<br>           *t=<span class="hljs-literal">NULL</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           *t=(biTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(biTree));<br>           <span class="hljs-keyword">if</span>(!*t)<br>               <span class="hljs-built_in">exit</span>(OVERFLOW);<br>           (*t)-&gt;data=newValue;<span class="hljs-comment">//生成根结点</span><br>           createBiTree(&amp;(*t)-&gt;lChild);<span class="hljs-comment">//构造左子树</span><br>           createBiTree(&amp;(*t)-&gt;rChild);<span class="hljs-comment">//构造右子树</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>求结点总数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNum</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> total)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           total=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>       total=<span class="hljs-number">1</span>+getNum(t-&gt;lchild)+getNum(t-&gt;child);<span class="hljs-comment">//左结点数+右结点数+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> height)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           height=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">int</span> lh=getHeight(t-&gt;left);<br>           <span class="hljs-keyword">int</span> rh=getHeight(t-&gt;right);<br>           height=((lh&gt;rh)?lh:rh)+<span class="hljs-number">1</span>;<span class="hljs-comment">//树的高度为左右子树高度大者+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求叶子数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getLeaves</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> leaves)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           leaves=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((t-&gt;lchild==<span class="hljs-literal">NULL</span>)&amp;&amp;(t-&gt;rchild==<span class="hljs-literal">NULL</span>))&#123;<span class="hljs-comment">//只有一个根结点</span><br>           leaves=<span class="hljs-number">1</span>;<br>&#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           leaves=getLeaves(t-&gt;lchild)+getLeaves(t-&gt;rchild);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4_二叉树理论</title>
    <link href="/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/"/>
    <url>/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3>二叉树</h3><h4>概念：</h4><p>二叉树是n(n≥0)个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相交的左子树和右子树组成，其中左子树和右子树也均为二叉树。二叉树的任一结点都有两棵子树（<code>它们中的任何一个都可以是空子树</code>），并且这两棵子树之间有次序关系，交换位置就成为一棵不同的二叉树。</p><h4>性质:</h4><ul><li><strong>性质1：</strong>二叉树第i (i≥1) 层上至多有2^(i-1)个结点。</li><li><strong>性质2：</strong>深度为k (k≥1) 的二叉树至多有2^(k)-1个结点</li><li><strong>性质3：</strong>对任何一棵二叉树, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。</li><li><strong>性质4：</strong>含有n个结点的完全二叉树的深度为 log2(n +1) 或 log2n +1</li><li><strong>性质5：</strong>如果对一棵有n个结点的完全二叉树的结点按<code>层序编号</code>（从第一层到最后一层，每层从左到右），对任一结点i（1≤i≤n）有：<ol><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲编号为 ⌊ i/2 ⌋ 。</li><li>如果2i&gt;n，则结点i无左右孩子（结点i为叶子结点）；否则其左孩子编号为 2i 。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则右孩子编号为 2i+1 。</li></ol></li></ul><h4>特殊二叉树:</h4><p><strong>1.斜树: </strong>左斜树 右斜树 结点个数与深度相同</p><p><strong>2.满二叉树: </strong>所有分支结点都存在左子树右子树 非叶子结点度数一定为2 深度为k(k≥1) 有2^(k)-1个结点</p><p><strong>3.完全二叉树: </strong>编号为i的结点与同样深度的满二叉树中编号为i的结点位置完全相同</p><p><img src="https://i.loli.net/2020/12/14/zlpoHNaALK6YGOw.png"></p><p><strong>完全二叉树就是除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点.</strong></p><p><strong>满二叉树一定是完全二叉树 完全二叉树不一定满</strong></p><h4>二叉树的遍历:</h4><ul><li><p>先序NLR</p><p><img src="https://i.loli.net/2020/12/15/ESZFVAXh7GsyHB6.gif" alt="先序"></p></li><li><p>中序LNR</p><p><img src="https://i.loli.net/2020/12/15/87S3i1rXVcsvxK4.gif" alt="中序"></p></li><li><p>后序LRN</p><p><img src="https://i.loli.net/2020/12/15/6X8MJ1DjoF5TKAv.gif" alt="后序"></p></li></ul><p><img src="https://i.loli.net/2020/12/14/rHIfCwJyQzclnmp.png" alt="example"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3_队列</title>
    <link href="/2020/12/14/3-%E9%98%9F%E5%88%97/"/>
    <url>/2020/12/14/3-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3>队列(Queue)---先进先出的线性表(First In First Out)</h3><img src="https://i.loli.net/2020/12/14/AlndLPCGHyRxYoa.png" alt="image.png" style="zoom:100%;" /><h4>0.特点:</h4><p>一端插入另一端删除</p><h4>1.顺序队列</h4><p>由于顺序队列容易假溢出 于是通常采用循环队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//顺序队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><br></code></pre></td></tr></table></figure><p><strong>1.1循环队列</strong></p><img src="https://i.loli.net/2020/12/14/MCPjGc8pWY13zKR.png" alt="image.png" style="zoom:100%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">引入循环队列:<br>区别队空队满方法:<br><span class="hljs-number">1.</span>牺牲一个存储空间<br>    <span class="hljs-number">2.</span>引入一个标志变量区别空余与不空<br>    <span class="hljs-number">3.</span>使用计数器<br> 牺牲一个存储空间<br>    (Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front;<span class="hljs-comment">//满队列条件</span><br>Q.rear=Q.front;<span class="hljs-comment">//空队列条件</span><br><span class="hljs-keyword">int</span> total=(Q.rear-Q.front+MAXSIZE)%MAXSIZE<span class="hljs-comment">//队列元素个数</span><br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//入队</span><br>Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//出队</span><br><span class="hljs-comment">//循环队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><span class="hljs-comment">//队列初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(sqQueue *Q)</span></span>&#123;<br>        Q.front=<span class="hljs-number">0</span>;<br>        Q.rear=<span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-comment">//入队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满!&quot;</span>);<br>        &#125;<br>        Q-&gt;data[Q-&gt;rear]=newValue;<span class="hljs-comment">//将值赋值给队尾</span><br>        Q-&gt;rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//尾指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//出队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *oldValue= Q-&gt;data[Q-&gt;front]; <span class="hljs-comment">//将队头元素赋值为oldValue</span><br>        Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//头指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//取队首元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getEle</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *myValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *myValue= Q-&gt;data[(Q-&gt;front+<span class="hljs-number">1</span>)%MAXSIZE];<br>        <br>    &#125;<br><br></code></pre></td></tr></table></figure><h4>2.链式队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链式队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span> <span class="hljs-comment">//结点结构</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>    &#125;QNode,*QueuePtr;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//队列链表结构</span><br>        QueuePtr front,rear;<span class="hljs-comment">//队头队尾指针</span><br>    &#125;LQueue;<br><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/SqC8izdylpIKvbf.png" alt="链式队列"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        QueuePtr temp = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow&quot;</span>);<span class="hljs-comment">//存储分配失败</span><br>        &#125;<br>        temp-&gt;data = e;<br>        temp-next = <span class="hljs-literal">NULL</span>;<br>        (Q-&gt;rear)-&gt;next = temp;<span class="hljs-comment">//新结点赋值给原队尾结点的后继</span><br>        Q-&gt;rear = temp;<span class="hljs-comment">//temp设置为尾结点 rear指向temp</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/Ly2lxoZ1SVNCrB4.png" alt="链式队列入队"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<br>        QueuePtr temp;<br>        <span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        temp=Q-&gt;front-&gt;next;<span class="hljs-comment">//队头结点赋值给temp</span><br>        *e=temp-&gt;data;<br>        Q-&gt;front-&gt;next=temp-&gt;next;<span class="hljs-comment">//原头结点后继temp-&gt;next赋值给头结点后继</span><br>        <span class="hljs-keyword">if</span>(Q-&gt;rear==temp)&#123;<span class="hljs-comment">//若队头是队尾 则删除后将rear指向头结点</span><br>            Q-&gt;rear=Q-&gt;front;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(temp);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2_栈</title>
    <link href="/2020/12/12/2-%E6%A0%88/"/>
    <url>/2020/12/12/2-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3>栈(Stack)---后进先出的线性表(Last In First Out)</h3><h4>1.顺序栈</h4><p>  栈空时 栈顶指针top==-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<br>        <span class="hljs-keyword">int</span> top; <span class="hljs-comment">//栈顶指针</span><br>    &#125;sqStack;<br><span class="hljs-comment">//栈的初始化 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(sqStack *s)</span></span>&#123;<br>        s-&gt;top=<span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//进栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s-&gt;top==MAXSIZE<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈满!&quot;</span>);<br>        &#125;<br>        s-&gt;top++; <span class="hljs-comment">//栈顶指针加一</span><br>        s-&gt;data[s-&gt;top]=newValue;<br>&#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br>*oldValue=s-&gt;data[s-&gt;top]; <span class="hljs-comment">//暂存被删除元素的值</span><br>s-&gt;top--; <span class="hljs-comment">//栈顶指针减一</span><br>&#125;<br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(sqStack s)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> topE=s-&gt;data [s-&gt;top];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素:%d&quot;</span>,topE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双栈情况:</strong></p><p>  双栈的两个栈底分别设置在数组的两端，栈顶分为是top1,top2</p><p>  两个栈顶在中间相遇，条件为 （top1+1=top2）发生上溢</p><p>  判断栈空条件: 一个是 top=0 另一个是top = maxsize -1 </p><h4>2.链栈</h4><p>(一个只能采用头插法插入或删除的链表)</p><p><img src="https://i.loli.net/2020/12/14/wd4CXlIvhELuSYt.png" alt="头插法"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span> *<span class="hljs-title">next</span>;</span><br>    &#125;linkStack;<br><span class="hljs-comment">//入栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(linkStack *top,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        linkStack *newNode=(linkStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linkStack));<br>        newNode-&gt;data=newValue;<br>        newNode-&gt;next=top;<br>        top=newNode;<span class="hljs-comment">//类比无头结点插入</span><br>    &#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断栈不为空</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            linkStack *oldNode=top;<span class="hljs-comment">//暂存栈顶元素</span><br>            top=top-&gt;next;<span class="hljs-comment">//弹出栈顶元素</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;弹出元素: %d&quot;</span>,oldNode-&gt;data);<br>            <span class="hljs-built_in">free</span>(oldNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//始终从同一个位置入栈出栈</span><br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(top==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素: %d&quot;</span>,top-&gt;data);<br>        &#125;<br>&#125;<br><span class="hljs-comment">//清空栈 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        linkStack *myNode;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            myNode=top;<br>            top=top-&gt;next;<br>            <span class="hljs-built_in">free</span>(myNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//求栈中元素个数 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            count++;<br>            top=top-&gt;next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>3.栈的应用</h4><p><strong>中缀表达式转后缀表达式</strong></p><p>​    首先将各种运算符（包括括号）的优先级排列如下（数字越大，优先级越高）：</p><p>​    1：（</p><p>​    2：+ -</p><p>​    3：* /</p><p>​    4：）</p><p>​    对输入的中缀表达式从左到右遍历：</p><p>​        1）如果遇到数字，直接添加到后缀表达式末尾；</p><p>​        2）如果遇到运算符+、-、*、/：</p><p>​            若栈空，则直接将此运算符压入栈。</p><p>​            若栈非空，则查看栈顶元素, 如果栈顶元素优先级&gt;=此操作符级别，则弹出栈顶元素，将元素添加到后缀表达式中，并继续进行上述判断。如果不满足上述判断或者栈为空，将这个运算符入栈。要注意的是，经过上述步骤，这个运算符最终一定会入栈。</p><p>​        3）如果遇到括号：</p><p>​            左括号直接入栈。</p><p>​            右括号，弹出栈中第一个左括号前所有的操作符，并将左括号弹出。（右括号不入栈）</p><p>​        4）字符串遍历结束后，如果栈不为空，则弹出栈中所有元素，将它们添加到后缀表达式的末尾，直到栈为空。</p><p><strong>后缀表达式求值:</strong></p><p>​    准备一个数字栈。从左到右扫描后缀表达式，如果是数字，放入数字栈。</p><p>​    如果是符号，从数字栈中弹出两个数字，第一个取出的数字为右运算数，第二个为左运算数，进行运算。然后将结果放进数字栈中。</p><p>​    如此反复，直到读完整个表达式后，留在数字栈中的那个数字就是最终结果。</p><p><strong>中缀表达式求值:</strong></p><p>  将前面的两步结合起来</p><p>  准备一个数字栈和一个符号栈。从左到右遍历中缀表达式。如果遇到数字，入数字栈。</p><p>  如果遇到符号（四个运算符以及括号），跟前面的“中缀表达式转后缀表达式”过程一样，对符号栈进行处理。处理过程中，对每一个出栈的运算符：+ - * /，根据“计算后缀表达式”的方法，计算结果（跟数字栈配合）。</p><p>  如果遍历完中缀表达式后符号栈还非空，就继续出符号栈的运算符，计算，直到符号栈为空。最后数字栈剩下的数字就是结果。</p><p>【参考资料】</p><p>[1] <a href="https://blog.csdn.net/sinat_27908213/article/details/80273557">https://blog.csdn.net/sinat_27908213/article/details/80273557</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1_线性表</title>
    <link href="/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4>线性表的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data[MAXSIZE];<br>    <span class="hljs-keyword">int</span> length;<br>&#125;sqList;<br><span class="hljs-comment">//取元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getElem</span><span class="hljs-params">(sqList L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//取第i个元素</span><br>        <span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>||i&lt;<span class="hljs-number">1</span>||i&gt;L.length)&#123;<span class="hljs-comment">//表空或者i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L.data[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//用指针存储</span><br>    &#125;<br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> e)</span></span>&#123; <span class="hljs-comment">//第i位插入e</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==MAXSIZE)&#123;<span class="hljs-comment">//顺序表满</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满无法插入&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;=L-&gt;length)&#123;<span class="hljs-comment">//可插入</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=L-&gt;length<span class="hljs-number">-1</span>;x&gt;=i<span class="hljs-number">-1</span>;x--)&#123;<span class="hljs-comment">//从第i到最后的元素都后移一位</span><br>                L-&gt;data[x+<span class="hljs-number">1</span>]=L-&gt;data[x]; <br>            &#125;<br>        &#125;<br>        L-&gt;data[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">//对第i位进行赋值</span><br>        L-&gt;length++;<span class="hljs-comment">//表长加一</span><br>    &#125;<br><span class="hljs-comment">//删除操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//删除第i位</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L-&gt;data[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(i&lt;L-&gt;length)&#123;<span class="hljs-comment">//如果删除的不是最后一个位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=i;x&lt;L-&gt;length;x++)&#123;<span class="hljs-comment">//被删除元素后的元素全部前移</span><br>                L-&gt;data[x<span class="hljs-number">-1</span>]=L-&gt;data[x];<br>            &#125;<br>        &#125;<br>         L-&gt;length--;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>线性表的链式存储</h4><p><strong>0.链表的特点</strong></p><p>(1)不要求用地址连续的存储空间在储，每个结点在运行时动态生成。结点的存储空间在物理位置上可以相邻，也可以不相邻;<br>(2)插入和删除操作不需要移动元素，只需修改指针，满足经常插入和删除结点的需求;<br>(3)链表不具备顺序表随机存取的优点﹔<br>(4)空间开销比较大，因链表结点增加了指示元素间关系的指针域<br>(5)链表是存储动态变化数据的理想选择。</p><p><strong>1.单链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//无头结点插入 新插入的x作为首元结点</span><br>    s-&gt;next=head;<br>head=s;<br><br> <span class="hljs-comment">//有头结点插入</span><br>s-&gt;next=head-&gt;next;<br>head-&gt;next=s;<br><span class="hljs-comment">//遍历traverse 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>        p=p-&gt;next;<br>        count++;<span class="hljs-comment">//用count求表长</span><br>    &#125;<br><span class="hljs-comment">//查找 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=theValue)&#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">else</span>&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position: %d&quot;</span>,count);<br>&#125;<br><span class="hljs-comment">//插入 </span><br>pre=head;<span class="hljs-comment">//在结点p之前插入</span><br><span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;pre-&gt;next!=p)&#123;<br>        pre=pre-&gt;next;<br>    &#125;<br><span class="hljs-keyword">if</span>(!pre)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p结点不存在!&quot;</span>);<br>    &#125;<br>Node *s=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>s-&gt;data=value;<br>s-&gt;next=pre-&gt;next;<br>pre-&gt;next=s;<span class="hljs-comment">//插入新结点</span><br><span class="hljs-comment">//删除</span><br>pre=head;<span class="hljs-comment">//删除第i个结点</span><br>count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(pre-&gt;next&amp;&amp;count&lt;i)&#123;<span class="hljs-comment">//找到第i-1个</span><br>        pre=pre-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;给出序号超出链表长度!&quot;</span>);<br>    &#125;<br>q=pre-&gt;next;<br>pre-&gt;next=q-&gt;next;<span class="hljs-comment">//删除</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放</span><br><span class="hljs-comment">//创建(头插法)</span><br><span class="hljs-comment">//创建(尾插法)</span><br><span class="hljs-comment">//逆置</span><br>Node *tmp,*p;<br>p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br>head-&gt;next=<span class="hljs-literal">NULL</span><span class="hljs-comment">//头结点指针置空 形成空链表</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        tmp=p-&gt;next;<span class="hljs-comment">//暂存p的后继</span><br>        p-&gt;next=head-&gt;next;<span class="hljs-comment">//p插入头结点后面</span><br>        head-&gt;next=p;<br>        p=tmp;<span class="hljs-comment">//继续处理下一个结点</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.双链表</strong></p><p><img src="https://i.loli.net/2020/12/12/b3M71k2lcBr5LN6.jpg" alt="插入"></p><p><img src="https://i.loli.net/2020/12/12/lpADuRx4MjfSGYi.jpg" alt="删除"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在p前插入s</span><br>s-&gt;prior=p-&gt;prior; <span class="hljs-comment">//1.p原先的前驱成为s的前驱</span><br>   p-&gt;prior-&gt;next=s; <span class="hljs-comment">//2.s成为p原先的前驱的后继</span><br>s-&gt;next=p;  <span class="hljs-comment">//3.s的后继是p</span><br>p-&gt;prior=s; <span class="hljs-comment">//4.修改p的前驱为s</span><br><span class="hljs-comment">//其中 4可以提前到3前 但不能到1,2前 否则会丢失结点</span><br><span class="hljs-comment">//删除p</span><br>p-&gt;prior-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=p-&gt;prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p><strong>3.单循环链表</strong> 往往不带头结点 往往只设尾指针</p><p><strong>4.双循环链表</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>0_绪论</title>
    <link href="/2020/12/12/0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/12/12/0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>​     <strong>数据(data)</strong>是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p>​     <strong>数据元素(data element)</strong>是数据的<u>基本单位</u>，在计算机程序中通常作为一个整体进行考虑和处理。</p><p>​     <strong>数据项(Data Item)</strong>数据项是数据的不可分割的<u>最小单位</u>。</p><p>​     <strong>数据对象(data object)</strong>是性质相同的数据元素的<u>集合</u>，是数据的一个子集。</p><p><img src="https://i.loli.net/2020/12/11/XLBtmuz6pUNMwK5.jpg"></p><p>​     <strong>如图: 数据对象由若干数据元素组成，数据元素由若干数据项组成</strong></p><p>​     <strong>数据结构(data structure)</strong>又称逻辑结构，是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下四类基本结构：<u>集合</u>、<u>线性结构</u>、<u>树形结构</u>、<u>图状结构</u>。</p><p>​     <strong>存储结构（物理结构）</strong>是数据结构在计算机中的表示（又称映像）。表示数据元素之间的关联方式有:  <u>顺序存储方式</u>、<u>链式存储方式</u>、索引存储方式、散列存储方式</p><p>​     <strong>数据类型(data type)</strong>是一个值的集合和定义在这个值集上的一组操作的总称。</p><p>​     <strong>抽象数据类型(AbstractData Type)</strong>是指一个数学模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。</p><p>​     评价<strong>算法的好坏</strong>有四个方面的因素: <u>1.正确性</u> <u>2.易读性</u> <u>3.健壮性</u> <u>4.时空性</u></p><p>​     <strong>时间复杂度</strong>的计算: 找出基本操作, 估算算法的计算量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/10/Hello-World/"/>
    <url>/2020/12/10/Hello-World/</url>
    
    <content type="html"><![CDATA[<p>Hiii! This is my first blog, can’t wait to share my tech ideas with u guys!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
