<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>10_排序</title>
    <link href="/2020/12/22/10-%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/12/22/10-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h4>插入排序</h4><ul><li><p>直接插入排序 <code>就是选择第一个元素之后，在从后面选择小的，往前插</code></p><p><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp"></p></li><li><p>折半插入排序</p></li><li><p>表插入排序</p></li><li><p>希尔排序</p></li></ul><h4>冒泡排序</h4><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp"></p><p>每两个挨着比，每趟最大的沉底</p><h4>快速排序</h4><p><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp"></p><p>用第一个数字，依次和后面的每个比较，然后拆分成2部分，一部分小于等于，一部分大于，依次类推即可</p><h4>选择排序</h4><p><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp"></p><p>每次选择最小的和未排序的第一个元素交换</p><h4>堆排序</h4><p>最小堆：任一结点的值都不大于它的两个孩子的值 </p><p>最大堆：任一结点的值都不小于它的两个孩子的值</p><p>画出二叉树，然后调整为堆即可</p><h4>归并排序</h4><p><img src="https://pic3.zhimg.com/80/v2-145011b5968388bd76e3b91853b136f6_720w.jpg"></p><p>二二合并排序</p><h4>基数排序</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>9_查找</title>
    <link href="/2020/12/22/9-%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/12/22/9-%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3>    查找</h3><h4>基本概念</h4><p>查找表: 是由同一类型的<u>数据元素</u>构成的集合</p><p>查找(Searching）就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素</p><p>静态查找表(StaticS Search Table): 只做查找操作的查找表</p><p>动态查找表(Dynamic Search Table): 在查找过程中，向表中插入不存在的数据元素，或者从表中删除某个数据元素</p><p>通常用“数据元素的键值与给定值的比较次数”作为衡量查找算法好坏的依据，称上述比较次数为<code>查找长度</code></p><p><strong>查找成功时的平均查找长度(ASL): </strong>需和指定key进行比较的关键字的个数的期望值</p><h4>顺序表查找</h4><p>适合于存储结构为<u>顺序存储</u>或<u>链接存储</u>的线性表。</p><p>查找成功 ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</p><p>等概率情况下 <img src="https://img2018.cnblogs.com/blog/1539112/201901/1539112-20190108141052350-17425507.gif"></p><p>时间复杂度 O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//每次循环都要对i是否越界超过n做判断</span><br>           <span class="hljs-keyword">if</span>(a[i]==key)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,i);<br>               <span class="hljs-keyword">return</span> i;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回0表示查找失败</span><br>   &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-comment">//改进法 设置哨兵</span><br>       <span class="hljs-keyword">int</span> i<br>       a[<span class="hljs-number">0</span>]=key;<span class="hljs-comment">//a[0]为关键字值--哨兵</span><br>       i=n;<span class="hljs-comment">//循环从尾部开始</span><br>       <span class="hljs-keyword">while</span>(a[i]!=key)&#123;<br>           i--;<br>       &#125;<br>       <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回0则说明查找失败</span><br>   &#125;<br></code></pre></td></tr></table></figure><h4>有序表查找</h4><ul><li><p><strong>二分查找</strong></p><p>前提条件是需要<u>有序表顺序存储</u>，如果无序则要先进行排序操作 </p><p>时间复杂度 O(logn) 比顺序查找有了质的飞跃</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,mid,high;<br>       low=<span class="hljs-number">0</span>;<span class="hljs-comment">//最低下标为记录首位</span><br>       high=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标为记录末位</span><br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=(low+high)/<span class="hljs-number">2</span>;<span class="hljs-comment">//折半 </span><br>           <span class="hljs-keyword">if</span>(a[mid]==value)&#123;<span class="hljs-comment">//中值与查找值相等 查找成功</span><br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<span class="hljs-comment">//中值比查找值大</span><br>               high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标调至中值前一位</span><br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<span class="hljs-comment">//中值比查找值小</span><br>               low=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//最低下标调至中值后一位</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回0查找失败</span><br>   &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<span class="hljs-comment">//递归版本</span><br>       <span class="hljs-keyword">int</span> mid=low+(high-low)/<span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">if</span>(low&gt;high)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>       &#125;<br>       <span class="hljs-keyword">if</span>(a[mid]==key)&#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);            <br>           <span class="hljs-keyword">return</span> mid;<br>       &#125;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<br>            <span class="hljs-keyword">return</span> binarySearch(a,key,low,mid<span class="hljs-number">-1</span>);<br>        &#125;<br>       <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<br>           <span class="hljs-keyword">return</span> binarySearch(a,key,mid+<span class="hljs-number">1</span>,high);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>插值查找</strong></p><p>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率</p><p>时间复杂度 O(logn)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,mid,high;<br>       low=<span class="hljs-number">0</span>;<br>       high=n<span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=low+(key-a[low])/(a[high]-a[low])*(high-low);<br>           <span class="hljs-comment">//折半查找中mid=(low+high)/2</span><br>           <span class="hljs-keyword">if</span>(a[mid]==key)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position is: %d&quot;</span>,mid);<br>               <span class="hljs-keyword">return</span> mid;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<br>               high=mid<span class="hljs-number">-1</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<br>               low=mid+<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>   &#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>斐波那契查找</strong></p><p>基于二分查找算法，通过运用黄金比例的概念在数列中选择查找点进行查找</p><p>时间复杂度 O(logn)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibonacciSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> low,high,mid,i,k;<br>       low=<span class="hljs-number">0</span>;<span class="hljs-comment">//最低下标为记录首位</span><br>       high=n<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标为记录末位</span><br>       k=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(n&gt;F[k]<span class="hljs-number">-1</span>)<span class="hljs-comment">//计算n位于斐波那契数列的位置</span><br>           k++;<br>       <span class="hljs-keyword">for</span>(i=n;i&lt;F[k]<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//将不满的数值补全</span><br>           a[i]=a[n];<br>       <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>           mid=low+F[k<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<span class="hljs-comment">//计算当前分隔的下标</span><br>           <span class="hljs-keyword">if</span>(a[mid]&gt;key)&#123;<span class="hljs-comment">//当前分隔大于查找值</span><br>               high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//最高下标调至mid-1</span><br>               k=k<span class="hljs-number">-1</span>;<span class="hljs-comment">//斐波那契数列下标-1</span><br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;key)&#123;<span class="hljs-comment">//当前分隔小于查找值</span><br>               low=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//最低下标调至mid+1</span><br>               k=k<span class="hljs-number">-2</span>;<span class="hljs-comment">//斐波那契数列下标-2</span><br>           &#125;<br>           <span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">if</span>(mid&lt;=n)<span class="hljs-comment">//不是补全数值</span><br>                   <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">//返回下标</span><br>               <span class="hljs-keyword">else</span><br>                   <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//是补全数值返回n</span><br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//查找失败</span><br>   &#125;<br><br></code></pre></td></tr></table></figure><p>斐波那契查找算法的核心在于:</p><p>1)当a[mid]=key时，查找就成功<br>2)当a[mid]&gt;key时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个<br>3)当a[mid]&lt;key时，新范围是第mid+1个到第high 个，此时范围个数为F[k-2]-1个</p><h4>二叉排序树</h4><p>一棵二叉排序树（又称二叉查找树）<u>有可能是一棵空树</u> 否则满足如下性质</p><ol><li><p>若它的左子树不空，则左子树上所有结点的键值均小于它的根结点键值；</p></li><li><p>若它的右子树不空，则右子树上所有结点的键值均小于它的根结点键值；</p></li><li><p>根的左、右子树也分别为二叉排序树。</p></li></ol><p><strong>对二叉查找树进行中序遍历，即可得到有序递增的数列。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTNode</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTR</span>=</span>Node *lchild,*rchild;<br>    &#125;biTNode,*biTree;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-a0b152e7dd56541e095f17fa3f3e06bc_r.jpg" alt="bst的平均查找长度示例"></p><h4>散列表(哈希表)</h4><p><code>存储位置=f(关键字)</code></p><p><strong>构造散列函数的方法</strong></p><ol><li><p><strong>直接定值法</strong> 取关键字的某个线性函数值作为散列地址 <code>f(key)=a*key+b</code></p></li><li><p><strong>数字分析法</strong> 事先知道关键字的分布且关键字若干位分布较均匀</p></li><li><p><strong>平方取中法</strong> 关键字平方取中间位 </p></li><li><p><strong>除留余数法</strong> <code>f(key) = key mod p (p&lt;=m) 表长为m</code></p><p>若散列表表长为m，通常p为小于或等于表长(最好接近m)的最小质数或不包含小于20质因子的合数</p></li><li><p><strong>随机数法</strong> 选一个随机数 取关键字的随机函数值作为其散列地址 f(key) = random(key)</p></li></ol><p><strong>处理散列冲突方法</strong></p><ol><li><p><strong>开放定址法</strong></p><p>只要在散列表未填满时，总是能找到不发生冲突的地址</p><ul><li><p><u>线性探测法</u></p><p><img src="https://i.loli.net/2020/12/20/bGBJrcZfmSh5IwP.png"></p><p>求余数，然后放到对应的位置上，如果位置上有数据元素了，那么就向后移动，移动到没有数据元素的位置上，然后占坑</p><p>平均查找长度 ASL = 元素查找次数总和 / 散列表长度 (下例中为16/11)</p><p><img src="https://pic4.zhimg.com/v2-ebc7c60b4f6c02ea79d760ef6202b8af_b.webp"></p></li><li><p><u>二次探测法</u></p><p><img src="https://i.loli.net/2020/12/20/gnmTr4zFQxLvPp6.png"></p><p>平方运算不让关键字都聚集在某一块区域</p></li><li><p><u>随机探测法</u></p><p><img src="https://i.loli.net/2020/12/20/YeRK9zWSZv4dyNo.png"></p><p>冲突时 对于位移量di采用随机函数计算得到</p></li></ul></li><li><p><strong>再散列函数法</strong></p><p><img src="https://i.loli.net/2020/12/20/Us1ZgamIbORAP8X.png"></p></li><li><p><strong>链地址法</strong></p><p><img src="https://pic3.zhimg.com/v2-1294c9705e969924685cdaa85b27f8f6_r.jpg"></p><p>平均查找长度ASL = (查找次数 * 个数) / 关键字个数 </p></li><li><p><strong>公共溢出区法</strong></p><p>为所有冲突的关键字建立了一个公共的溢出区存放</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> *elem;<span class="hljs-comment">//数据元素存储基址 动态分配数组</span><br>        <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//当前数据元素个数</span><br>    &#125;hashTable;<br><span class="hljs-keyword">int</span> length=<span class="hljs-number">0</span>;<span class="hljs-comment">//全局定义表长</span><br><span class="hljs-comment">//初始化散列表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initHash</span><span class="hljs-params">(hashTable *H)</span></span>&#123;<br>        length=HASHSIZE;<br>        H-&gt;count=length;<span class="hljs-comment">//初始化散列表长度为数组长度</span><br>        H-&gt;elem=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(m*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            H-&gt;elem[i]=NULLKEY;<span class="hljs-comment">//赋值为空值</span><br>        &#125;<br>    &#125;<br><span class="hljs-comment">//散列函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> key%m;<span class="hljs-comment">//除留余数法</span><br>    &#125;<br><span class="hljs-comment">//插入关键字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertHash</span><span class="hljs-params">(hashTable *H,<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> addr=hashFunc(key);<span class="hljs-comment">//求散列地址</span><br>        <span class="hljs-keyword">while</span>(H-&gt;elem[addr]!=NULLKEY)&#123;<span class="hljs-comment">//如果不为空 则冲突</span><br>            addr=(addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//开放定址法线性探测</span><br>        &#125;<br>        H-&gt;elem[addr]=key;<span class="hljs-comment">//直到有空位后插入关键字</span><br>    &#125;<br><span class="hljs-comment">//查找关键字</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchHash</span><span class="hljs-params">(hashTable H,<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> *addr)</span></span>&#123;<br>        *addr=hashFunc(key);<span class="hljs-comment">//求散列地址</span><br>        <span class="hljs-keyword">while</span>(H.elem[*addr]!=key)&#123;<span class="hljs-comment">//如果不为空 则冲突</span><br>            *addr=(*addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//开放定址法的线性探测</span><br>            <span class="hljs-keyword">if</span>(H.elem[*addr]==NULLKEY || *addr==hashFunc(key))&#123;<span class="hljs-comment">//循环回原点</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;关键字不存在!&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>8_图</title>
    <link href="/2020/12/22/8-%E5%9B%BE/"/>
    <url>/2020/12/22/8-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3>    图</h3><h4>基本概念:</h4><p><strong>图的分类: </strong>有向图和无向图</p><p><strong>弧、弧头、弧尾: </strong>有向图的边称为弧。无向图叫做边。</p><p><strong>无向完全图: </strong>任何两点之间都有边的无向图。 </p><p><strong>有向完全图: </strong>任何两点之间都有弧的有向图。</p><p><strong>权：</strong>图的边附带数值，这个数值叫权。</p><p><strong>带权图: </strong>每条边都带权的图称为带权图。</p><p><strong>顶点的度、入度、出度: </strong>1. 无向图中顶点v的度是与该顶点相关联的边的数目，记为D(v)。 2. 有向图中，把以顶点v为终点的弧的数目称为v的入度，记为ID(v)；把以顶点v为始点的弧的数目称为v的出度，记为OD(v)。有向图顶点v的度为入度和出度之和，即D（v） = ID（v）+ OD（v）。</p><p><strong>简单路径: </strong>序列中<u>顶点</u>不重复出现的路径。</p><p><strong>回路: </strong>第一个顶点和最后一个顶点相同的路径。</p><p><strong>简单回路(简单环): </strong>除了第一个顶点和最后一个顶点外，其余顶点不重复的回路。</p><p><strong>生成树(不唯一):</strong> n个顶点有n-1条边的无向图。权值最小的生成树是<strong>最小生成树(唯一)</strong>。</p><p><strong>强连通图:</strong> 有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路</p><p><strong>连通图:</strong> 无向图中，如果任意两个顶点之间都能够连通</p><h4>基本性质</h4><ul><li><p><strong>无向完全图</strong>, 边数最多为 n(n-1) / 2</p></li><li><p><strong>有向完全图</strong>, 边数最多为 n(n-1)</p></li><li><p><strong>有向强连通图</strong>, 边数最多为 n(n-1), 最少有n条边</p></li><li><p><strong>无向连通图</strong>, 边数最多为 n(n-1) / 2, 边数最少为 n-1条边   即生成树</p></li><li><p><strong>无向非连通图</strong>, 边数最多为 (n-1)(n-2)/2条边</p></li><li><p>树是图的特例 是无环无向图</p></li><li><p>握手定理</p><p>在无向图G=&lt;V,E&gt;中, 所有的节点的<strong>度数总和等于边数的2倍</strong></p><p>在有向图G=&lt;V,E&gt;中, 所有节点的度数的总和等于边数的2倍，所有节点的入度之和等于所有节点的出度之和</p></li></ul><h4>图的存储结构</h4><ul><li><p>点表示–所有顶点保存到数组</p></li><li><p>边表示</p><p><strong>邻接矩阵</strong></p><p>(矩阵中标记1，有边，标记0，没有边)</p><p><img src="https://i.loli.net/2020/12/15/K4AzwrFHQJmnvOT.png"></p><p><u>无向图</u>的邻接矩阵是一个<u>对称矩阵</u> <u>第i行或第i列</u>非零元素个数表示顶点v的度</p><p><u>有向图</u>的邻接矩阵<u>不一定</u>对称 (双向的有向图对称) <u>第i行</u>非零元素个数表示顶点v的<u>出度</u> <u>第i列</u>非零元素个数表示顶点v的<u>入度</u></p><p><strong>邻接表</strong></p><p>(顺序存储与链式存储相结合的存储方法)<img src="https://i.loli.net/2020/12/15/jzFGaKRWXQIsP7h.png"><code>∧符号，表示结束，没有连接的顶点了</code></p><p><u>无向图</u>的邻接表 第i个顶点的<u>度</u>为第i个链表的结点数</p><p><u>有向图</u>的邻接表 第i个顶点的<u>出度</u>为第i个链表的结点数 <u>入度</u>要遍历整个邻接表 找下标为i的结点</p></li></ul><h4>图的遍历</h4><p><strong>从图的某个顶点出发，系统地访问图的每个顶点，并且每个顶点只被访问一次。</strong></p><p><strong>1.深度优先搜索</strong></p><p>(往下走，走不动了，返回上一级再走)</p><img src="https://i.loli.net/2020/12/15/DTrNKIFMmH2PgkO.png" style="zoom:67%;" /><p><strong>2.广度优先搜索</strong></p><p>(顺着一个顶点，然后都遍历完)</p><img src="https://i.loli.net/2020/12/15/uvpTe58bEQmgSqZ.png" style="zoom:67%;" /><h4>最小生成树</h4><p><strong>(所有生成树中权总和最小的生成树)</strong></p><p>构造方法:</p><ul><li><strong>Prim算法</strong></li></ul><img src="https://i.loli.net/2020/12/15/mnlBOgecfLJ98Nk.png" alt="Prim" style="zoom: 50%;" /><ul><li><p><strong>Kruskal算法</strong></p><p>先对边按权值从小到大排序, 每次从剩余的边中选取一个最小的边。</p><img src="https://img-blog.csdn.net/20150816113249128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="zoom: 50%;" /></li></ul><h4>最短路径</h4><ul><li>Dijkstra算法</li></ul><img src="https://img-blog.csdn.net/20160330150629186" style="zoom:67%;" /><ul><li>Floyd算法</li></ul><h4>拓扑排序</h4><p>AOV网: 用顶点表示活动的有向图</p><p>工程或者某种流程可以分为若干个小的工程或阶段，这些小的工程或阶段就称为活动。</p><p> 如果以图中的顶点来表示活动，有向边表示活动之间的优先关系。</p><p><img src="https://i.loli.net/2020/12/15/LxbmKU6QSI8Cc4g.png"></p><p>拓扑排序: 一个有向无环图（DAG）的所有顶点的线性序列。</p><p>该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li></ol><p>基本步骤如下：</p><ol><li>图中选择一个入度为0的顶点，输出该顶点</li><li>从图中删除该顶点及相关联的弧，调整被删弧的弧头结点的入度（入度减1）</li><li>重复执行上述两个步骤，<u>直到所有的入度为0</u></li></ol><p><img src="https://i.loli.net/2020/12/15/jEUabHSgTWGJFys.png" alt="example"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>7_Huffman树及算法</title>
    <link href="/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/7-Huffman%E6%A0%91%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>哈夫曼树与哈夫曼算法</h3><p><strong>哈夫曼树不唯一、时刻考虑权值最小</strong></p><p><strong>路径: </strong>从一个结点到另一个结点的分支序列</p><p><strong>路径长度:  </strong>根结点到L层结点路径长度L-1 (完全二叉树是总路径长度最短的二叉树)</p><h4>Huffman树: </h4><p>由n个带权值的叶结点构成的二叉树中,树的最大带权长度(WPL)最小的二叉树称为最优二叉树</p><p><img src="https://i.loli.net/2020/12/15/hWX4R9MKypGocqS.png" alt="example"></p><p><img src="https://i.loli.net/2020/12/15/jVy6DCFdxcSOANl.gif"></p><h4>huffman编码</h4><p>例题: 设某通讯系统中一个待传输的文本有6个不同字符，它们的出现频率分别是0.5,0.8,1.4,2.2,2.3,2.8，试设计哈夫曼编码</p><p><img src="https://i.loli.net/2020/12/15/A6p9vIMjdKyXUm8.png"></p><p>出现频率为0.5的字符编码为1000 出现频率为0.8的字符编码为1001 出现频率为1.4的字符编码为101 出现频率为2.2的字符编码为00 出现频率为2.3的字符编码为01 出现频率为2.8的字符编码为11</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6_树和森林</title>
    <link href="/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <url>/2020/12/15/6-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<h3>树</h3><p><strong>核心概念: </strong>线性结构中一个结点至多只有一个直接后继，树形结构一个结点可以有一个或多个直接后继</p><h4>相关术语:</h4><ul><li>结点的度: 结点拥有的子树数</li><li>叶子节点: 度为0的结点</li><li>分支节点: 度不为0的结点</li><li>树的度: 树内各结点的度的最大值, 就是把所有结点的度求和</li><li>结点的层次: 根为第一层, 其余结点的层次为其双亲的层次加1</li><li>结点间关系: Parent Child</li><li>树的深度/高度: 树中结点最大层次</li><li>森林: m棵不相交的树的集合</li></ul><h4>树的存储结构:</h4><p><strong>1.双亲表示法</strong></p><p><strong>2.孩子表示法</strong></p><p><strong>3.孩子兄弟表示法</strong></p><h4>树、森林与二叉树的关系: </h4><p><strong>树到二叉树手工模拟: </strong></p><p><img src="https://i.loli.net/2020/12/15/jMkBR4lWhDS3JUt.gif" alt="树到二叉树"></p><p>​     1).连线(兄弟节点加线) 2).删线(只保留左孩子) 3).旋转(顺时针45)</p><p>​     <strong>将结点的孩子放在左子树 结点的兄弟放在右子树 形态唯一!!!</strong></p><p><strong>森林转换成二叉树</strong></p><p><img src="https://i.loli.net/2020/12/15/GfUBmqkdy94aJ83.png" alt="森林到二叉树"></p><p>​    1).每棵树转换成相应的二叉树 2).各棵二叉树的根结点看做是兄弟连接起来</p><p><strong>二叉树到树手工模拟</strong></p><p><img src="https://img-blog.csdnimg.cn/20190629154649448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDY4ODIxNw==,size_16,color_FFFFFF,t_70" alt="二叉树到树"></p><p>​    1).连线(结点与其子树的右孩子) 2).删线(双亲与右孩子) 3).旋转(逆时针45)</p><h4>树和森林的遍历:</h4><p><strong>树的遍历</strong>:</p><ul><li>先序遍历: 访问根结点 依次先序遍历根的各棵子树</li><li>后序遍历: 依次后序遍历根的各棵子树 访问根结点</li><li>层次遍历: 访问根结点 依次从左到右访问结点</li></ul><p><strong>森林的遍历</strong></p><ul><li>先序遍历森林</li></ul><p>访问森林中第一棵树的根结点<br>先序遍历森林中第一棵树的根结点子树组成的森林<br>先序遍历除去第一棵树之外其余的树组成的森林</p><ul><li>中序遍历森林</li></ul><p>中序遍历森林中第一棵树的根结点的子树组成的森林<br>访问第一棵树的根结点<br>中序遍历除去第一棵树之外其余的树组成的森林</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5_二叉树算法</title>
    <link href="/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/15/5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3>二叉树存储结构:</h3><h4>1.顺序存储结构</h4><p>一般只用于完全二叉树</p><h4>2.链式存储结构--二叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">biTree</span> *<span class="hljs-title">lChild</span>,*<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左右孩子指针</span><br>    &#125;biTree;<br></code></pre></td></tr></table></figure><p><strong>遍历二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.前序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        preOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//先先序遍历左子树</span><br>        preOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//再先序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//2.中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//中序遍历左子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*t-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>        inOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//中序遍历右子树</span><br>    &#125;<br><span class="hljs-comment">//3.后序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(*t==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        postOrderTraverse(t-&gt;lChild);<span class="hljs-comment">//后序遍历左子树</span><br>        postOrderTraverse(t-&gt;rChild);<span class="hljs-comment">//后序遍历右子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(*t)-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>    &#125;<br><span class="hljs-comment">//4.层序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">levelTraverse</span><span class="hljs-params">(biTree *t)</span></span>&#123;<br>        biTree *tmp=t;<br>        circleQueue *q;<br>        q=initQueue();<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;根结点为空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            enQueue(q,*tmp);<span class="hljs-comment">//根结点入队</span><br>        &#125;<br>        <span class="hljs-keyword">while</span>(q.rear!=q.front)&#123;<span class="hljs-comment">//队不为空</span><br>            p=q.getEle();<span class="hljs-comment">//取队首元素</span><br>            deQueue();<span class="hljs-comment">//出队一个元素</span><br>            <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树不为空</span><br>                enQueue(q,p-&gt;lchild);<span class="hljs-comment">//左子树入队</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//右子树不为空</span><br>                enQueue(q,p-&gt;rchild);<span class="hljs-comment">//右子树入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//已知前序中序可确定一棵二叉树</span><br><span class="hljs-comment">//已知后序中序可确定一棵二叉树</span><br></code></pre></td></tr></table></figure><p><strong>创建二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createBiTree</span><span class="hljs-params">(biTree *t)</span></span>&#123;<span class="hljs-comment">//前序建立</span><br>       <span class="hljs-keyword">int</span> newValue;<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;newValue);<br>       <span class="hljs-keyword">if</span>(newValue==<span class="hljs-string">&quot;#&quot;</span>)&#123;<br>           *t=<span class="hljs-literal">NULL</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           *t=(biTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(biTree));<br>           <span class="hljs-keyword">if</span>(!*t)<br>               <span class="hljs-built_in">exit</span>(OVERFLOW);<br>           (*t)-&gt;data=newValue;<span class="hljs-comment">//生成根结点</span><br>           createBiTree(&amp;(*t)-&gt;lChild);<span class="hljs-comment">//构造左子树</span><br>           createBiTree(&amp;(*t)-&gt;rChild);<span class="hljs-comment">//构造右子树</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>求结点总数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNum</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> total)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           total=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>       total=<span class="hljs-number">1</span>+getNum(t-&gt;lchild)+getNum(t-&gt;child);<span class="hljs-comment">//左结点数+右结点数+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求高度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> height)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           height=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">int</span> lh=getHeight(t-&gt;left);<br>           <span class="hljs-keyword">int</span> rh=getHeight(t-&gt;right);<br>           height=((lh&gt;rh)?lh:rh)+<span class="hljs-number">1</span>;<span class="hljs-comment">//树的高度为左右子树高度大者+1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>求叶子数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getLeaves</span><span class="hljs-params">(biTree *t,<span class="hljs-keyword">int</span> leaves)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//空树</span><br>           leaves=<span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((t-&gt;lchild==<span class="hljs-literal">NULL</span>)&amp;&amp;(t-&gt;rchild==<span class="hljs-literal">NULL</span>))&#123;<span class="hljs-comment">//只有一个根结点</span><br>           leaves=<span class="hljs-number">1</span>;<br>&#125;<br>       <span class="hljs-keyword">else</span>&#123;<br>           leaves=getLeaves(t-&gt;lchild)+getLeaves(t-&gt;rchild);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4_二叉树理论</title>
    <link href="/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/"/>
    <url>/2020/12/14/4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3>二叉树</h3><h4>概念：</h4><p>二叉树是n(n≥0)个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相交的左子树和右子树组成，其中左子树和右子树也均为二叉树。二叉树的任一结点都有两棵子树（<code>它们中的任何一个都可以是空子树</code>），并且这两棵子树之间有次序关系，交换位置就成为一棵不同的二叉树。</p><h4>性质:</h4><ul><li><strong>性质1：</strong>二叉树第i (i≥1) 层上至多有2^(i-1)个结点。</li><li><strong>性质2：</strong>深度为k (k≥1) 的二叉树至多有2^(k)-1个结点</li><li><strong>性质3：</strong>对任何一棵二叉树, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。</li><li><strong>性质4：</strong>含有n个结点的完全二叉树的深度为 log2(n +1) 或 log2n +1</li><li><strong>性质5：</strong>如果对一棵有n个结点的完全二叉树的结点按<code>层序编号</code>（从第一层到最后一层，每层从左到右），对任一结点i（1≤i≤n）有：<ol><li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲编号为 ⌊ i/2 ⌋ 。</li><li>如果2i&gt;n，则结点i无左右孩子（结点i为叶子结点）；否则其左孩子编号为 2i 。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则右孩子编号为 2i+1 。</li></ol></li></ul><h4>特殊二叉树:</h4><p><strong>1.斜树: </strong>左斜树 右斜树 结点个数与深度相同</p><p><strong>2.满二叉树: </strong>所有分支结点都存在左子树右子树 非叶子结点度数一定为2 深度为k(k≥1) 有2^(k)-1个结点</p><p><strong>3.完全二叉树: </strong>编号为i的结点与同样深度的满二叉树中编号为i的结点位置完全相同</p><p><img src="https://i.loli.net/2020/12/14/zlpoHNaALK6YGOw.png"></p><p><strong>完全二叉树就是除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点.</strong></p><p><strong>满二叉树一定是完全二叉树 完全二叉树不一定满</strong></p><h4>二叉树的遍历:</h4><ul><li><p>先序NLR</p><p><img src="https://i.loli.net/2020/12/15/ESZFVAXh7GsyHB6.gif" alt="先序"></p></li><li><p>中序LNR</p><p><img src="https://i.loli.net/2020/12/15/87S3i1rXVcsvxK4.gif" alt="中序"></p></li><li><p>后序LRN</p><p><img src="https://i.loli.net/2020/12/15/6X8MJ1DjoF5TKAv.gif" alt="后序"></p></li></ul><p><img src="https://i.loli.net/2020/12/14/rHIfCwJyQzclnmp.png" alt="example"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3_队列</title>
    <link href="/2020/12/14/3-%E9%98%9F%E5%88%97/"/>
    <url>/2020/12/14/3-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3>队列(Queue)---先进先出的线性表(First In First Out)</h3><img src="https://i.loli.net/2020/12/14/AlndLPCGHyRxYoa.png" alt="image.png" style="zoom:100%;" /><h4>0.特点:</h4><p>一端插入另一端删除</p><h4>1.顺序队列</h4><p>由于顺序队列容易假溢出 于是通常采用循环队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//顺序队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><br></code></pre></td></tr></table></figure><p><strong>1.1循环队列</strong></p><img src="https://i.loli.net/2020/12/14/MCPjGc8pWY13zKR.png" alt="image.png" style="zoom:100%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">引入循环队列:<br>区别队空队满方法:<br><span class="hljs-number">1.</span>牺牲一个存储空间<br>    <span class="hljs-number">2.</span>引入一个标志变量区别空余与不空<br>    <span class="hljs-number">3.</span>使用计数器<br> 牺牲一个存储空间<br>    (Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front;<span class="hljs-comment">//满队列条件</span><br>Q.rear=Q.front;<span class="hljs-comment">//空队列条件</span><br><span class="hljs-keyword">int</span> total=(Q.rear-Q.front+MAXSIZE)%MAXSIZE<span class="hljs-comment">//队列元素个数</span><br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//入队</span><br>Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//出队</span><br><span class="hljs-comment">//循环队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<span class="hljs-comment">//存储队列中的数据元素</span><br>        <span class="hljs-keyword">int</span> front;<span class="hljs-comment">//指向队列首元素的前一个单元</span><br>        <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">//指向实际的队列尾元素单元</span><br>    &#125;sqQueue;<br><span class="hljs-comment">//队列初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initQueue</span><span class="hljs-params">(sqQueue *Q)</span></span>&#123;<br>        Q.front=<span class="hljs-number">0</span>;<br>        Q.rear=<span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-comment">//入队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXSIZE==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满!&quot;</span>);<br>        &#125;<br>        Q-&gt;data[Q-&gt;rear]=newValue;<span class="hljs-comment">//将值赋值给队尾</span><br>        Q-&gt;rear=(Q.rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//尾指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//出队 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *oldValue= Q-&gt;data[Q-&gt;front]; <span class="hljs-comment">//将队头元素赋值为oldValue</span><br>        Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//头指针后移 若到最后则转到数组头部</span><br>    &#125;<br><span class="hljs-comment">//取队首元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getEle</span><span class="hljs-params">(sqQueue *Q,<span class="hljs-keyword">int</span> *myValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Q.rear==Q.front)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队空!&quot;</span>);<br>        &#125;<br>        *myValue= Q-&gt;data[(Q-&gt;front+<span class="hljs-number">1</span>)%MAXSIZE];<br>        <br>    &#125;<br><br></code></pre></td></tr></table></figure><h4>2.链式队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链式队列定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span> <span class="hljs-comment">//结点结构</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>    &#125;QNode,*QueuePtr;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//队列链表结构</span><br>        QueuePtr front,rear;<span class="hljs-comment">//队头队尾指针</span><br>    &#125;LQueue;<br><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/SqC8izdylpIKvbf.png" alt="链式队列"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        QueuePtr temp = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>        <span class="hljs-keyword">if</span>(temp!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow&quot;</span>);<span class="hljs-comment">//存储分配失败</span><br>        &#125;<br>        temp-&gt;data = e;<br>        temp-next = <span class="hljs-literal">NULL</span>;<br>        (Q-&gt;rear)-&gt;next = temp;<span class="hljs-comment">//新结点赋值给原队尾结点的后继</span><br>        Q-&gt;rear = temp;<span class="hljs-comment">//temp设置为尾结点 rear指向temp</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/14/Ly2lxoZ1SVNCrB4.png" alt="链式队列入队"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">(LQueue *Q,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<br>        QueuePtr temp;<br>        <span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        temp=Q-&gt;front-&gt;next;<span class="hljs-comment">//队头结点赋值给temp</span><br>        *e=temp-&gt;data;<br>        Q-&gt;front-&gt;next=temp-&gt;next;<span class="hljs-comment">//原头结点后继temp-&gt;next赋值给头结点后继</span><br>        <span class="hljs-keyword">if</span>(Q-&gt;rear==temp)&#123;<span class="hljs-comment">//若队头是队尾 则删除后将rear指向头结点</span><br>            Q-&gt;rear=Q-&gt;front;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(temp);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2_栈</title>
    <link href="/2020/12/12/2-%E6%A0%88/"/>
    <url>/2020/12/12/2-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3>栈(Stack)---后进先出的线性表(Last In First Out)</h3><h4>1.顺序栈</h4><p>  栈空时 栈顶指针top==-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data[MAXSIZE];<br>        <span class="hljs-keyword">int</span> top; <span class="hljs-comment">//栈顶指针</span><br>    &#125;sqStack;<br><span class="hljs-comment">//栈的初始化 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initStack</span><span class="hljs-params">(sqStack *s)</span></span>&#123;<br>        s-&gt;top=<span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//进栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s-&gt;top==MAXSIZE<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈满!&quot;</span>);<br>        &#125;<br>        s-&gt;top++; <span class="hljs-comment">//栈顶指针加一</span><br>        s-&gt;data[s-&gt;top]=newValue;<br>&#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(sqStack s,<span class="hljs-keyword">int</span> *oldValue)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br>*oldValue=s-&gt;data[s-&gt;top]; <span class="hljs-comment">//暂存被删除元素的值</span><br>s-&gt;top--; <span class="hljs-comment">//栈顶指针减一</span><br>&#125;<br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(sqStack s)</span></span>&#123;<br>s-&gt;top==<span class="hljs-number">-1</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> topE=s-&gt;data [s-&gt;top];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素:%d&quot;</span>,topE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双栈情况:</strong></p><p>  双栈的两个栈底分别设置在数组的两端，栈顶分为是top1,top2</p><p>  两个栈顶在中间相遇，条件为 （top1+1=top2）发生上溢</p><p>  判断栈空条件: 一个是 top=0 另一个是top = maxsize -1 </p><h4>2.链栈</h4><p>(一个只能采用头插法插入或删除的链表)</p><p><img src="https://i.loli.net/2020/12/14/wd4CXlIvhELuSYt.png" alt="头插法"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span>&#123;</span><br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linkStack</span> *<span class="hljs-title">next</span>;</span><br>    &#125;linkStack;<br><span class="hljs-comment">//入栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushStack</span><span class="hljs-params">(linkStack *top,<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br>        linkStack *newNode=(linkStack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linkStack));<br>        newNode-&gt;data=newValue;<br>        newNode-&gt;next=top;<br>        top=newNode;<span class="hljs-comment">//类比无头结点插入</span><br>    &#125;<br><span class="hljs-comment">//出栈 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断栈不为空</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            linkStack *oldNode=top;<span class="hljs-comment">//暂存栈顶元素</span><br>            top=top-&gt;next;<span class="hljs-comment">//弹出栈顶元素</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;弹出元素: %d&quot;</span>,oldNode-&gt;data);<br>            <span class="hljs-built_in">free</span>(oldNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//始终从同一个位置入栈出栈</span><br><span class="hljs-comment">//取栈顶元素 时间复杂度O(1) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTop</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(top==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈空!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈顶元素: %d&quot;</span>,top-&gt;data);<br>        &#125;<br>&#125;<br><span class="hljs-comment">//清空栈 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        linkStack *myNode;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            myNode=top;<br>            top=top-&gt;next;<br>            <span class="hljs-built_in">free</span>(myNode);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//求栈中元素个数 时间复杂度O(n) 空间复杂度O(1)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countStack</span><span class="hljs-params">(linkStack *top)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(top!=<span class="hljs-literal">NULL</span>)&#123;<br>            count++;<br>            top=top-&gt;next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>3.栈的应用</h4><p><strong>中缀表达式转后缀表达式</strong></p><p>​    首先将各种运算符（包括括号）的优先级排列如下（数字越大，优先级越高）：</p><p>​    1：（</p><p>​    2：+ -</p><p>​    3：* /</p><p>​    4：）</p><p>​    对输入的中缀表达式从左到右遍历：</p><p>​        1）如果遇到数字，直接添加到后缀表达式末尾；</p><p>​        2）如果遇到运算符+、-、*、/：</p><p>​            若栈空，则直接将此运算符压入栈。</p><p>​            若栈非空，则查看栈顶元素, 如果栈顶元素优先级&gt;=此操作符级别，则弹出栈顶元素，将元素添加到后缀表达式中，并继续进行上述判断。如果不满足上述判断或者栈为空，将这个运算符入栈。要注意的是，经过上述步骤，这个运算符最终一定会入栈。</p><p>​        3）如果遇到括号：</p><p>​            左括号直接入栈。</p><p>​            右括号，弹出栈中第一个左括号前所有的操作符，并将左括号弹出。（右括号不入栈）</p><p>​        4）字符串遍历结束后，如果栈不为空，则弹出栈中所有元素，将它们添加到后缀表达式的末尾，直到栈为空。</p><p><strong>后缀表达式求值:</strong></p><p>​    准备一个数字栈。从左到右扫描后缀表达式，如果是数字，放入数字栈。</p><p>​    如果是符号，从数字栈中弹出两个数字，第一个取出的数字为右运算数，第二个为左运算数，进行运算。然后将结果放进数字栈中。</p><p>​    如此反复，直到读完整个表达式后，留在数字栈中的那个数字就是最终结果。</p><p><strong>中缀表达式求值:</strong></p><p>  将前面的两步结合起来</p><p>  准备一个数字栈和一个符号栈。从左到右遍历中缀表达式。如果遇到数字，入数字栈。</p><p>  如果遇到符号（四个运算符以及括号），跟前面的“中缀表达式转后缀表达式”过程一样，对符号栈进行处理。处理过程中，对每一个出栈的运算符：+ - * /，根据“计算后缀表达式”的方法，计算结果（跟数字栈配合）。</p><p>  如果遍历完中缀表达式后符号栈还非空，就继续出符号栈的运算符，计算，直到符号栈为空。最后数字栈剩下的数字就是结果。</p><p>【参考资料】</p><p>[1] <a href="https://blog.csdn.net/sinat_27908213/article/details/80273557">https://blog.csdn.net/sinat_27908213/article/details/80273557</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1_线性表</title>
    <link href="/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/12/12/1-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4>线性表的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data[MAXSIZE];<br>    <span class="hljs-keyword">int</span> length;<br>&#125;sqList;<br><span class="hljs-comment">//取元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getElem</span><span class="hljs-params">(sqList L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//取第i个元素</span><br>        <span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>||i&lt;<span class="hljs-number">1</span>||i&gt;L.length)&#123;<span class="hljs-comment">//表空或者i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L.data[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//用指针存储</span><br>    &#125;<br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> e)</span></span>&#123; <span class="hljs-comment">//第i位插入e</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==MAXSIZE)&#123;<span class="hljs-comment">//顺序表满</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满无法插入&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;=L-&gt;length)&#123;<span class="hljs-comment">//可插入</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=L-&gt;length<span class="hljs-number">-1</span>;x&gt;=i<span class="hljs-number">-1</span>;x--)&#123;<span class="hljs-comment">//从第i到最后的元素都后移一位</span><br>                L-&gt;data[x+<span class="hljs-number">1</span>]=L-&gt;data[x]; <br>            &#125;<br>        &#125;<br>        L-&gt;data[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">//对第i位进行赋值</span><br>        L-&gt;length++;<span class="hljs-comment">//表长加一</span><br>    &#125;<br><span class="hljs-comment">//删除操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteList</span><span class="hljs-params">(sqList *L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> *e)</span></span>&#123;<span class="hljs-comment">//删除第i位</span><br>        <span class="hljs-keyword">if</span>(L-&gt;length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//i不在有效位置</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>        &#125;<br>        *e=L-&gt;data[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(i&lt;L-&gt;length)&#123;<span class="hljs-comment">//如果删除的不是最后一个位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=i;x&lt;L-&gt;length;x++)&#123;<span class="hljs-comment">//被删除元素后的元素全部前移</span><br>                L-&gt;data[x<span class="hljs-number">-1</span>]=L-&gt;data[x];<br>            &#125;<br>        &#125;<br>         L-&gt;length--;<br>    &#125;<br></code></pre></td></tr></table></figure><h4>线性表的链式存储</h4><p><strong>0.链表的特点</strong></p><p>(1)不要求用地址连续的存储空间在储，每个结点在运行时动态生成。结点的存储空间在物理位置上可以相邻，也可以不相邻;<br>(2)插入和删除操作不需要移动元素，只需修改指针，满足经常插入和删除结点的需求;<br>(3)链表不具备顺序表随机存取的优点﹔<br>(4)空间开销比较大，因链表结点增加了指示元素间关系的指针域<br>(5)链表是存储动态变化数据的理想选择。</p><p><strong>1.单链表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//无头结点插入 新插入的x作为首元结点</span><br>    s-&gt;next=head;<br>head=s;<br><br> <span class="hljs-comment">//有头结点插入</span><br>s-&gt;next=head-&gt;next;<br>head-&gt;next=s;<br><span class="hljs-comment">//遍历traverse 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>        p=p-&gt;next;<br>        count++;<span class="hljs-comment">//用count求表长</span><br>    &#125;<br><span class="hljs-comment">//查找 时间复杂度O(n)空间复杂度O(1)</span><br>Node *p=head-&gt;next;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=theValue)&#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">else</span>&#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position: %d&quot;</span>,count);<br>&#125;<br><span class="hljs-comment">//插入 </span><br>pre=head;<span class="hljs-comment">//在结点p之前插入</span><br><span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;pre-&gt;next!=p)&#123;<br>        pre=pre-&gt;next;<br>    &#125;<br><span class="hljs-keyword">if</span>(!pre)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p结点不存在!&quot;</span>);<br>    &#125;<br>Node *s=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>s-&gt;data=value;<br>s-&gt;next=pre-&gt;next;<br>pre-&gt;next=s;<span class="hljs-comment">//插入新结点</span><br><span class="hljs-comment">//删除</span><br>pre=head;<span class="hljs-comment">//删除第i个结点</span><br>count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(pre-&gt;next&amp;&amp;count&lt;i)&#123;<span class="hljs-comment">//找到第i-1个</span><br>        pre=pre-&gt;next;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;给出序号超出链表长度!&quot;</span>);<br>    &#125;<br>q=pre-&gt;next;<br>pre-&gt;next=q-&gt;next;<span class="hljs-comment">//删除</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放</span><br><span class="hljs-comment">//创建(头插法)</span><br><span class="hljs-comment">//创建(尾插法)</span><br><span class="hljs-comment">//逆置</span><br>Node *tmp,*p;<br>p=head-&gt;next;<span class="hljs-comment">//p指向首元结点</span><br>head-&gt;next=<span class="hljs-literal">NULL</span><span class="hljs-comment">//头结点指针置空 形成空链表</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        tmp=p-&gt;next;<span class="hljs-comment">//暂存p的后继</span><br>        p-&gt;next=head-&gt;next;<span class="hljs-comment">//p插入头结点后面</span><br>        head-&gt;next=p;<br>        p=tmp;<span class="hljs-comment">//继续处理下一个结点</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.双链表</strong></p><p><img src="https://i.loli.net/2020/12/12/b3M71k2lcBr5LN6.jpg" alt="插入"></p><p><img src="https://i.loli.net/2020/12/12/lpADuRx4MjfSGYi.jpg" alt="删除"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在p前插入s</span><br>s-&gt;prior=p-&gt;prior; <span class="hljs-comment">//1.p原先的前驱成为s的前驱</span><br>   p-&gt;prior-&gt;next=s; <span class="hljs-comment">//2.s成为p原先的前驱的后继</span><br>s-&gt;next=p;  <span class="hljs-comment">//3.s的后继是p</span><br>p-&gt;prior=s; <span class="hljs-comment">//4.修改p的前驱为s</span><br><span class="hljs-comment">//其中 4可以提前到3前 但不能到1,2前 否则会丢失结点</span><br><span class="hljs-comment">//删除p</span><br>p-&gt;prior-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=p-&gt;prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p><strong>3.单循环链表</strong> 往往不带头结点 往往只设尾指针</p><p><strong>4.双循环链表</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>0_绪论</title>
    <link href="/2020/12/12/0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/12/12/0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>​     <strong>数据(data)</strong>是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p>​     <strong>数据元素(data element)</strong>是数据的<u>基本单位</u>，在计算机程序中通常作为一个整体进行考虑和处理。</p><p>​     <strong>数据项(Data Item)</strong>数据项是数据的不可分割的<u>最小单位</u>。</p><p>​     <strong>数据对象(data object)</strong>是性质相同的数据元素的<u>集合</u>，是数据的一个子集。</p><p><img src="https://i.loli.net/2020/12/11/XLBtmuz6pUNMwK5.jpg"></p><p>​     <strong>如图: 数据对象由若干数据元素组成，数据元素由若干数据项组成</strong></p><p>​     <strong>数据结构(data structure)</strong>又称逻辑结构，是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下四类基本结构：<u>集合</u>、<u>线性结构</u>、<u>树形结构</u>、<u>图状结构</u>。</p><p>​     <strong>存储结构（物理结构）</strong>是数据结构在计算机中的表示（又称映像）。表示数据元素之间的关联方式有:  <u>顺序存储方式</u>、<u>链式存储方式</u>、索引存储方式、散列存储方式</p><p>​     <strong>数据类型(data type)</strong>是一个值的集合和定义在这个值集上的一组操作的总称。</p><p>​     <strong>抽象数据类型(AbstractData Type)</strong>是指一个数学模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。</p><p>​     评价<strong>算法的好坏</strong>有四个方面的因素: <u>1.正确性</u> <u>2.易读性</u> <u>3.健壮性</u> <u>4.时空性</u></p><p>​     <strong>时间复杂度</strong>的计算: 找出基本操作, 估算算法的计算量</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/10/Hello-World/"/>
    <url>/2020/12/10/Hello-World/</url>
    
    <content type="html"><![CDATA[<p>Hiii! This is my first blog, can’t wait to share my tech ideas with u guys!</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
